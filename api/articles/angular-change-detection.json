{"title":"[译]angular变更检查历史","uid":"02dceeb1c9680db6bfa35b02b26a819e","slug":"angular-change-detection","date":"2024-08-13T11:34:54.108Z","updated":"2025-07-10T03:02:34.368Z","comments":true,"path":"api/articles/angular-change-detection.json","keywords":null,"cover":"https://img.kidwen.top/file/185cb46c7e9cf3d06d35f.jpg","content":"<p>Angular 是一个组件驱动框架。和其他框架一样，他向用户展示数据并在数据变化后刷新视图。</p>\n<p><img src=\"https://img.kidwen.top/file/cece1e72c854e71964b72.jpg\" alt=\"\"></p>\n<div style=\"text-align: center\">在模版中显示用户数据</div>\n<p>随着项目的增长，我们会创建越来越多的组件，并将他们组合在一起，最后我们会得到下面的组件树。</p>\n<p><img src=\"https://img.kidwen.top/file/300e9fca0ce9148689909.jpg\" alt=\"\"></p>\n<p>但是Angular是如何知道什么时候刷新视图？如何知道数据何时发生变化？如何知道何时运行变更检查？</p>\n<h3 id=\"同步代码的变更检查\">同步代码的变更检查</h3>\n<p>从一个小的例子开始。我们有一个属性 <code>name</code>和一个方法 <code>changeName</code>的组件。当点击按钮时调用 <code>changeName</code>方法并改变 <code>name</code>值。</p>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">@</span><span style=\"color:#B392F0\">Component</span><span style=\"color:#E1E4E8\">(&#123;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">template: </span><span style=\"color:#9ECBFF\">`</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    &#x3C;button (click)=\"changeName();\">Change Name&#x3C;/button></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    &#x3C;p>&#123;&#123; name &#125;&#125;&#x3C;/p></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> AppComponent</span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> ''</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> changeName</span><span style=\"color:#E1E4E8\">() &#123;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'Jane'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;</span></span></code></pre>\n<p>当点击按钮时，<code>changeName</code>方法被调用。因为所有的事情都被Angular封装了，所以我们可以安全的假设 <code>name</code>变更后，angular会运行一些代码来更新视图（而且所有的事情都会被同步）。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>想象中的Angular内部代码</p></blockquote>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">component.</span><span style=\"color:#B392F0\">changename</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Angular会对整个组件树运行变更检查，因为我们可能更新一些在其他组件中用到的service中的数据</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">angular.</span><span style=\"color:#B392F0\">runChangeDetection</span><span style=\"color:#E1E4E8\">();</span></span></code></pre>\n<p>他正常工作了！但是，在多数情况下我们更改数据并不是同步的。比如说一些HTTP请求，或者一些定时器，或者在更新数据前等待一些其他的事件。这就是问题的开始。</p>\n<h3 id=\"异步代码的变更检查\">异步代码的变更检查</h3>\n<p>现在，我们在一秒钟后改变数据。我们可以使用 <code>setTimeout</code>方法。</p>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">@</span><span style=\"color:#B392F0\">Component</span><span style=\"color:#E1E4E8\">(&#123;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">template: </span><span style=\"color:#9ECBFF\">`</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    &#x3C;button (click)=\"changeName();\">Change Name&#x3C;/button></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    &#x3C;p>&#123;&#123; name &#125;&#125;&#x3C;/p></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> AppComponent</span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> ''</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> changeName</span><span style=\"color:#E1E4E8\">() &#123;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        setTimeout</span><span style=\"color:#E1E4E8\">(() </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            this</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'Jane'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        &#125;, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;</span></span></code></pre>\n<p>当我们点击按钮时，会调用 <code>changeName</code>方法并调用 <code>setTimeout</code>方法。<code>setTimeout</code>会等待一秒改变 <code>name</code>值。</p>\n<p>现在我们添加和之前一样的想象中Angular底层代码。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>想象中的Angular内部代码</p></blockquote>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">component.</span><span style=\"color:#B392F0\">changeName</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#6A737D\">// 内部包含 setTimeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 当changeName被调用后直接调用下面的方法</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">angular.</span><span style=\"color:#B392F0\">runChangeDetection</span><span style=\"color:#E1E4E8\">();</span></span></code></pre>\n<p>由于 <code>setTimeout</code>是一个宏任务，所以会在 <code>angular.runChangeDetection</code>方法后面执行。所以即使Angular执行了变更检查，但是页面上的name也没有发生更改。这就是视图不会更新的原因，这就是程序崩溃的地方⚠️（事实上并非如此，因为我们有👇）。</p>\n<h3 id=\"Zone-js\">Zone.js</h3>\n<p>zone.js最早在Angular v2就开始使用了，他是一个浏览器API的猴子补丁库。他可以挂钩浏览器生命周期事件。这意味着什么？这意味着我们可以在浏览器事件之前或者之后运行我们的代码。</p>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#B392F0\">setTimeout</span><span style=\"color:#E1E4E8\">(() </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Hello world'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span></code></pre>\n<p>上面代码会在一秒钟后打印 <code>Hello world</code>。但是如果我们想在 <code>setTimeout</code>之前或者之后执行一些代码该怎么做呢？要知道这是出于业务原因😄。Angular会希望在执行 <code>setTimeout</code>之前后者之后执行一些代码。</p>\n<p><code>Zone.js</code>可以让我们做到这些。我们可以创建一个zone（Angular同样创建了一个zone），并挂钩 <code>setTimeout</code>回调方法。</p>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> zone</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Zone.current.</span><span style=\"color:#B392F0\">fork</span><span style=\"color:#E1E4E8\">(&#123;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    onInvokeTask</span><span style=\"color:#E1E4E8\">: (</span><span style=\"color:#FFAB70\">delegate</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">current</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">target</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">task</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">applyThis</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">applyArgs</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Before setTimeout'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        delegate.</span><span style=\"color:#B392F0\">invokeTask</span><span style=\"color:#E1E4E8\">(target, task, applyThis, applyArgs);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'After setTimeout'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;);</span></span></code></pre>\n<p>我们需要执行 <code>zone.run()</code>方法来运行 <code>zone</code>中的 <code>setTimeout</code>方法。</p>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">zone.</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">(&#123;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    setTimeout</span><span style=\"color:#E1E4E8\">(() </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        console</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Hello world'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#125;);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;);</span></span></code></pre>\n<p>现在我们运行上面的代码会看到如下输出</p>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">Before setTimeout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">Hello world</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">After setTimeout</span></span></code></pre>\n<p>这就是 <code>zone.js</code>的工作原理。它是对浏览器API的猴子补丁，这使我们可以挂钩浏览器事件的生命周期。</p>\n<h3 id=\"Zone-js-Angular\">Zone.js + Angular</h3>\n<p>Angular 会为每一个应用加载 <code>zone.js</code>并创建一个名为 <code>NgZone</code>的zone实例。<code>NgZone</code>包含一个叫做 <code>onMicrotaskEmpty</code>的 <code>可观察（Observable）</code>对象。这个可观察对象在队列中没有微任务时侯会发出一个值。这就是Angular用来知道所有异步代码执行完成并可以安全的执行变更检查的方案。</p>\n<p><img src=\"https://img.kidwen.top/file/25b69b0c34f35c0f0f175.jpg\" alt=\"\"></p>\n<p>我们一起来看一下底层<a href=\"https://github.com/angular/angular/blob/c4de4e1f894001d8f80b70297c5e576f2d11ec6f/packages/core/src/change_detection/scheduling/ng_zone_scheduling.ts#L31\">代码</a>:</p>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ng_zone_scheduling.ts 文件 NgZoneChangeDetectionScheduler 类</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">._onMicrotaskEmptySubscription </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.zone.onMicrotaskEmpty.</span><span style=\"color:#B392F0\">subscribe</span><span style=\"color:#E1E4E8\">(&#123;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    next</span><span style=\"color:#E1E4E8\">: () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.zone.</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">(() </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            this</span><span style=\"color:#E1E4E8\">.applicationRef.</span><span style=\"color:#B392F0\">tick</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        &#125;);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;);</span></span></code></pre>\n<p>我们可以看到上面代码中Angular会在 <code>onMicrotaskEmpty</code>对象发出值后调用 <code>applicationRef.tick()</code>方法。那这个 <code>tick</code>方法是做什么的呢？你还记得我们之前想象Angular底层代码中的 <code>runChangeDetection</code>方法吗？很好，<code>tick</code>方法就是 <code>runChangeDetection</code>方法。他会同步运行整个组件树的变更检查。</p>\n<p>现在Angular知道所有的异步任务完成了，它可以<em>安全</em>的执行变更检查了。</p>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#B392F0\">tick</span><span style=\"color:#E1E4E8\">(): </span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 精简后的代码</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">let</span><span style=\"color:#E1E4E8\"> view </span><span style=\"color:#F97583\">of</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">._views) &#123;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        view.</span><span style=\"color:#B392F0\">detectChanges</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;</span></span></code></pre>\n<p>tick 方法将遍历所有根视图（大多数情况下，我们只有一个根视图/组件，即 AppComponent），并同步运行 detectChanges。</p>\n<h3 id=\"组件标记为脏状态\">组件标记为脏状态</h3>\n<p>Angular还会做一件事情就是当组件内部变化时标记为脏状态。</p>\n<p>这些都是标记为脏状态的操作：</p>\n<ul>\n<li>事件（点击，鼠标悬停等）</li>\n</ul>\n<p>每次我们点击模版中的一个带有监听事件的按钮时，angular会用一个名为<a href=\"https://github.com/angular/angular/blob/c4de4e1f894001d8f80b70297c5e576f2d11ec6f/packages/core/src/render3/instructions/listener.ts#L260\"><code>wrapListenerIn_markDirtyAndPreventDefault</code></a>的函数封装回调函数。正如我们从函数名上看到的，他会标记组件为脏状态。</p>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> wrapListener</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> EventListener</span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> function</span><span style=\"color:#B392F0\"> wrapListenerIn_markDirtyAndPreventDefault</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">e</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> any</span><span style=\"color:#E1E4E8\">) &#123;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 精简后的代码</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        markViewDirty</span><span style=\"color:#E1E4E8\">(startView); </span><span style=\"color:#6A737D\">// 标记组件为脏状态</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;</span></span></code></pre>\n<ul>\n<li>更改输入</li>\n</ul>\n<p>另外，在运行变更检查时，Angular会检查输入框的值是否发生变更(===check)。如何放生了变化，他会把组件标记为脏状态。<a href=\"https://github.com/angular/angular/blob/c4de4e1f894001d8f80b70297c5e576f2d11ec6f/packages/core/src/render3/component_ref.ts#L348\">源码</a></p>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#B392F0\">setInput</span><span style=\"color:#E1E4E8\">(name: string, value: unknown): </span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 如果值没有发生变化则不做操作</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (Object.</span><span style=\"color:#B392F0\">is</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.previousInputValues.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(name), value)) &#123;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 精简后的代码</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    setInputsForProperty</span><span style=\"color:#E1E4E8\">(lView[</span><span style=\"color:#79B8FF\">TVIEW</span><span style=\"color:#E1E4E8\">], lView, dataValue, name, value);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    markViewDirty</span><span style=\"color:#E1E4E8\">(childComponentLView); </span><span style=\"color:#6A737D\">// 将组件标记为脏</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;</span></span></code></pre>\n<ul>\n<li>抛出事件</li>\n</ul>\n<p>要在 Angular 中监听输出排放，我们需要在模板中注册一个事件。正如我们之前看到的，回调 fn 将被封装，当事件发生时，组件将被标记为 dirty。</p>\n<p>让我们看看这个 <a href=\"https://github.com/angular/angular/blob/c4de4e1f894001d8f80b70297c5e576f2d11ec6f/packages/core/src/render3/instructions/mark_view_dirty.ts#L24\">markViewDirty</a> 函数的作用。</p>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">* 标记当前视图和所有祖先为脏状态</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> function</span><span style=\"color:#B392F0\"> markViewDirty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">lView</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> LView</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> LView</span><span style=\"color:#F97583\"> |</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (lView) &#123;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lView[</span><span style=\"color:#79B8FF\">FLAGS</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LViewFlags.Dirty;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#79B8FF\"> parent</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> getLViewParent</span><span style=\"color:#E1E4E8\">(lView);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 一旦找到未附加到任何容器的根视图，就停止向上遍历</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">isRootView</span><span style=\"color:#E1E4E8\">(lView) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">parent) &#123;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> lView;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lView </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parent</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;</span></span></code></pre>\n<p>从注释中可以看出，<code>markViewDirty</code>方法将当前和所有祖先视图标记为脏状态。下面的图片方便我们更好的理解。</p>\n<p><img src=\"https://img.kidwen.top/file/7b18519bb388650b43c17.jpg\" alt=\"\"></p>\n<p>因此，我们点击按钮时，Angular会调用我们的回调方法（changeName），由于这个方法被<strong>wrapListenerIn_markDirtyAndPreventDefault</strong>方法包裹，所以会将组件标记为脏状态。</p>\n<p>正如之前讲的，Angular使用zone.js并用它来封装我们的应用。</p>\n<p><img src=\"https://img.kidwen.top/file/99724a407db3dfa27245c.jpg\" alt=\"\"></p>\n<p>一直到顶部进行脏标记后，<strong>wrapListenerIn_markDirtyAndPreventDefault</strong>会触发并触发zone.js。</p>\n<p><img src=\"https://img.kidwen.top/file/d2d066bbcaa2c15d7ca03.jpg\" alt=\"\"></p>\n<p>由于Angular已经监听了<strong>onMicrotaskEmpty</strong>对象，而且点击事件注册了一个被zone.js包裹的事件监听器,zone知道什么时候事件完成运行，因此它可以想<strong>onMicrotaskEmpty</strong>对象发送一个值。</p>\n<p><img src=\"https://img.kidwen.top/file/d13d86c43fb99b44801cb.jpg\" alt=\"\"></p>\n<p><strong>onMicrotaskEmpty</strong>通知Angular执行变更检查。</p>\n<h3 id=\"组件绑定刷新\">组件绑定刷新</h3>\n<p>每次Angular运行变成检查会从顶层到最子节点检查每个组件。它会检查所有组件（<strong>脏状态</strong>和<strong>非脏状态</strong>）的绑定。如果绑定的值发生变化就会更新视图。</p>\n<p><img src=\"https://img.kidwen.top/file/a8bc5839b5ee902db7c39.jpg\" alt=\"\"></p>\n<p>但是为什么Angular要检查所有的组件而不是只检查脏状态组件呢🤔？</p>\n<p>这是因为Angular的变更检查策略。</p>\n<h3 id=\"OnPush-变更检查策略\">OnPush 变更检查策略</h3>\n<p>Angular有一种变更检查策略命名为<strong>OnPush</strong>。当我们使用这种策略时，Angular会只对标记为脏状态的组件执行变更检查。</p>\n<p>首先我们更改变更检查策略为<strong>OnPush</strong>。</p>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">@</span><span style=\"color:#B392F0\">Component</span><span style=\"color:#E1E4E8\">(&#123;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    changeDetection: ChangeDetectionStrategy.OnPush,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> UserCardComponent</span><span style=\"color:#E1E4E8\"> &#123; &#125;</span></span></code></pre>\n<p>让我们看下面的图片来理解变更检查是如何与<strong>OnPush</strong>策略配合使用的。</p>\n<p><img src=\"https://img.kidwen.top/file/61bd674e63312d37727b3.jpg\" alt=\"\"></p>\n<div style=\"text-align: center;\">某些组件使用<strong>OnPush策略（其子组件隐含为OnPush组件）</strong></div>\n<p>让我们再做一遍之前做的事情，点击组件中的按钮并更改名称。</p>\n<p>首先是<strong>脏标记</strong>阶段。</p>\n<p><img src=\"https://img.kidwen.top/file/7e55725147c22245683ba.jpg\" alt=\"\"></p>\n<p>然后事件监听器会通知zone.js</p>\n<p><img src=\"https://img.kidwen.top/file/23fe5d37542660516bb50.jpg\" alt=\"\"></p>\n<p>当所有异步任务运行完毕后，<strong>onMicrotaskEmpty</strong>方法触发。</p>\n<p><img src=\"https://img.kidwen.top/file/9cf7553dd9ed8d62762ec.jpg\" alt=\"\"></p>\n<p>现在Angular将会运行<strong>tick</strong>方法，他会从上之下遍历组件并检查每个组件。</p>\n<p>如果组件是：</p>\n<ul>\n<li>OnPush + 非脏状态 =&gt; 跳过</li>\n<li>OnPush + 脏状态 =&gt; 检查绑定 =&gt; 刷新绑定 =&gt; 检查子组件</li>\n</ul>\n<p><img src=\"https://img.kidwen.top/file/b230d52b0649a036377fd.png\" alt=\"\"></p>\n<p>如图所示，通过使用<strong>OnPush</strong>策略，Angular会自动跳过组件树中的没有任何更改的部分。</p>\n<h3 id=\"OnPush-Observables-async-pipe\">OnPush + Observables + async pipe</h3>\n<p>当我们使用Angular时，Observable对象一直是我们在状态管理和数据管理时常用的对象。Angular为了支持observables提供了异步管道（<strong>async</strong>）。异步管道监听observable对象并返回最新的值。为了让Angular知道那些值发生了变化，它会调用来自<strong>changeDetectorRef</strong>类（组件中的<strong>changeDetectorRef</strong>）中的<strong>markForCheck</strong>。</p>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">@</span><span style=\"color:#B392F0\">Pipe</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> AsyncPip</span><span style=\"color:#F97583\"> implements</span><span style=\"color:#B392F0\"> OnDestroy</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">PipTransform</span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#F97583\"> constructor</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        private</span><span style=\"color:#FFAB70\"> ref</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> ChangeDetectorRef</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) &#123; &#125;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> transform</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">>(</span><span style=\"color:#FFAB70\">obj</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> Observable</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">>)</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#F97583\"> |</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#B392F0\"> _updateLatestValue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">async</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> any</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> Object</span><span style=\"color:#E1E4E8\">) &#123;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 精简后的代码</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.ref</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">markForCheck</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#6A737D\">// 标记组件需要检查</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;</span></span></code></pre>\n<p><a href=\"https://justangular.com/blog/async-pipe-is-not-pure\">从零开始创建异步管道并了解它的工作原理</a>。</p>\n<p><strong>markForCheck</strong>方法的作用就是调用之前提到的<strong>markViewDirty</strong>方法。</p>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#6A737D\">// view_ref.ts</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">markForCheck</span><span style=\"color:#E1E4E8\">(): </span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    markViewDirty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">._cdRefInjectingView </span><span style=\"color:#F97583\">||</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">._lView);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">```</span></span></code></pre>\n<p>因此，和之前一样，我们在组件中使用管道和使用点击事件一样，它会标记组件为脏状态，Angular后面会对这个组件执行变更检查。</p>\n<p><img src=\"https://img.kidwen.top/file/31f7736f9c5f9325c4336.png\" alt=\"\"></p>\n<p><em>data$ | async</em>管道将组件标记为脏状态。</p>\n<h3 id=\"OnPush-Observables-谁触发了zone-js\">OnPush + Observables + 谁触发了zone.js</h3>\n<p>如果数据在没有发生交互时发生变化很有可能是触发了<strong>setTimeout</strong>或者<strong>setInterval</strong>或者HTTP请求，从而触发了zone.js</p>\n<p>下面是如何破坏监听💣</p>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">@</span><span style=\"color:#B392F0\">Component</span><span style=\"color:#E1E4E8\">(&#123;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    selector: </span><span style=\"color:#9ECBFF\">'app-todos'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    standalone: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    imports: [AsyncPipe, JsonPipe],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    template: </span><span style=\"color:#9ECBFF\">`&#123;&#123; todo$ | async | json &#125;&#125;`</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    changeDetection: ChangeDetectionStrategy.OnPush,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> TodosComponent</span><span style=\"color:#F97583\"> implements</span><span style=\"color:#B392F0\"> OnInit</span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#FFAB70\"> http</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> inject</span><span style=\"color:#E1E4E8\">(HttpClient);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#FFAB70\"> ngZone</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> inject</span><span style=\"color:#E1E4E8\">(NgZone);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#FFAB70\"> todos$</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> of</span><span style=\"color:#E1E4E8\">([] </span><span style=\"color:#F97583\">as</span><span style=\"color:#B392F0\"> Array</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#79B8FF\">any</span><span style=\"color:#E1E4E8\">>);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#B392F0\"> ngOnInit</span><span style=\"color:#E1E4E8\">() &#123;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.ngZone.</span><span style=\"color:#B392F0\">runOutsideAngular</span><span style=\"color:#E1E4E8\">(() </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            setTimeout</span><span style=\"color:#E1E4E8\">(() </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // todos$会被更新但是不会触发zone.js</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                this</span><span style=\"color:#E1E4E8\">.todos$ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">getTodos</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            &#125;);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        &#125;);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#B392F0\"> getTodos</span><span style=\"color:#E1E4E8\">() &#123;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.http.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#79B8FF\">any</span><span style=\"color:#E1E4E8\">>(</span><span style=\"color:#9ECBFF\">'https://jsonplaceholder.typicode.com/todos/1'</span><span style=\"color:#E1E4E8\">).</span><span style=\"color:#B392F0\">pipe</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">shareReplay</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;</span></span></code></pre>\n<p>这里我们做了下面几件事情：</p>\n<ul>\n<li>在<strong>ngOnInit</strong>中，我们调用 <strong>ngZone.runOutsideAngular()</strong> 方法使代码可以在Angular zone外面运行。</li>\n<li>我们使用<strong>setTimeout</strong>方法（跳过第一个正在运行的任务，因为Angular会默认至少执行一次变更检查），并在里面给 <strong>todos$</strong> 赋值（现在数据发生了变更）。</li>\n<li>由于代码在<strong>runOutsideAngular</strong>中执行，因此 <strong>setTimeout</strong>不会在zone中运行，http请求也会被放在zone之外执行。所以没有任何通知给到zonejs</li>\n<li>上面的运行结果就是页面只显示 “[]”</li>\n<li><strong>状态被破坏了🧨!</strong></li>\n</ul>\n<h3 id=\"为什么要把所有祖先都标记为脏状态？\">为什么要把所有祖先都标记为脏状态？</h3>\n<p>很简单，如果不把所有的祖先组件都标记为脏状态，我们很快就能得到一个被破坏的状态，下面介绍如何做。</p>\n<p>在上面的例子上，如果我们只把组件和子组件标记为脏状态。</p>\n<p><img src=\"https://img.kidwen.top/file/87b993f22877a37c5cd60.jpg\" alt=\"\"></p>\n<p>如图所示，我们只对当前组件和子组件标记检查，<strong>tick</strong>触发时，它会执行到使用<strong>OnPush</strong>策略的父组件然后检查父组件是否是脏状态，然后跳过父组件。</p>\n<p><img src=\"https://img.kidwen.top/file/3e2f7ac34c244627db4bb.jpg\" alt=\"\"></p>\n<div style=\"text-align: center;\">使用markForCheck时，如果不把祖先组件标记为脏，就会出现问题</div>\n<h3 id=\"为什么不能只对标记的组件运行变更检查？\">为什么不能只对标记的组件运行变更检查？</h3>\n<p>我们可以使用<strong>ChangeDetectorRef</strong>类中的<strong>detectChanges</strong>来做到这点。但是这有缺点，由于同步执行变更检查，这可能造成性能问题。由于所有操作都在浏览器的任务器中做的，他会阻塞主线程。试想一下，变更检查没过一两秒钟就检查100项组件的变化。这对浏览器的工作压力山大。</p>\n<h3 id=\"markForCheck-vs-detectChanges-（合并运行-vs-同步运行）\">markForCheck vs detectChanges （合并运行 vs 同步运行）</h3>\n<p>当我们执行<strong>markForCheck</strong>只是标记这个组件为脏状态，并不会做其他的事情。所以即使调用<strong>markForCheck</strong>1000次也不会造成任何问题。但是当我们调用<strong>detectChanges</strong>，Angular会执行实际工作，检查绑定和更新需要更新的视图。所以我们应该使用<strong>markForCheck</strong>而不是<strong>detectChanges</strong>。</p>\n<h3 id=\"不可以在下一个浏览器任务中安排-detectChanges-吗？\">不可以在下一个浏览器任务中安排 detectChanges 吗？</h3>\n<p>我们可以，这就是 <a href=\"https://www.rx-angular.io/\">rx-angulard</a> 的 <a href=\"https://www.rx-angular.io/docs/template/api/push-pipe\">push pipe</a> 或 <a href=\"https://www.rx-angular.io/docs/template/api/rx-let-directive\">rxLet</a> 指令的作用。它将变化检测安排在下一个浏览器任务中。但是，对每个组件都这么做并不是个好主意。因为，如果我们有一个包含 100 个项目的列表，而我们为每个项目都安排了变化检测，那么我们就会有 100 个浏览器任务。这对性能也没有好处。</p>\n<h3 id=\"Signals\">Signals</h3>\n<p>前端世界正在向着信号的方向发展。Solid.js、Svelte、Vue、Angular都在创建他们的信号实现方案。因为信号机制是<strong>状态管理</strong>和<strong>状态变化</strong>的更好的方法。</p>\n<p>Angular中的信号为DX带来了很多的好处，我们可以轻松的创建和派生状态，还可以在状态发生变化时执行副作用方法。不需要订阅它们也不需要取消订阅更不用担心内存泄漏问题。</p>\n<p>我们只需要调用它们，它们就会返回当前的值。</p>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> name</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> signal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Jone'</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#6A737D\">// 创建一个信号并初始化一个默认值</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> upperCaseName</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> computer</span><span style=\"color:#E1E4E8\">(() </span><span style=\"color:#F97583\">=></span><span style=\"color:#B392F0\"> name</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toUpperCase</span><span style=\"color:#E1E4E8\">()); </span><span style=\"color:#6A737D\">// 创建一个计算信号</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">public </span><span style=\"color:#B392F0\">effect</span><span style=\"color:#E1E4E8\">(() </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">name</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> ' '</span><span style=\"color:#F97583\"> +</span><span style=\"color:#B392F0\"> upperCaseName</span><span style=\"color:#E1E4E8\">()); </span><span style=\"color:#6A737D\">// 执行副作用方法当name或者uppeerCaseName发生变化</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">name.</span><span style=\"color:#B392F0\">set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Jane'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Jone JONE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Jane JANE</span></span></code></pre>\n<p>我们可以在模版中使用信号，就像调用普通函数一样。</p>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">@</span><span style=\"color:#B392F0\">Component</span><span style=\"color:#E1E4E8\">(&#123;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    template: </span><span style=\"color:#9ECBFF\">`</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        &#x3C;button (click)=\"name.set('Jane')\">Change Name&#x3C;/button></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        &#x3C;p>&#123;&#123; name() &#125;&#125;&#x3C;/p></span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    `</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">expor </span><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AppComponent</span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    public</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> signal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Jone'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;</span></span></code></pre>\n<p>在模版中调用函数是否是一个好主意呢？我觉得如果函数调用代价低那就使用函数调用，它只是一个返回值函数调用（不需要调用任何东西）。</p>\n<p><a href=\"https://itnext.io/its-ok-to-use-function-calls-in-angular-templates-ffdd12b0789e\">参考文章</a></p>\n<h3 id=\"信号和变更检查\">信号和变更检查</h3>\n<p>在Angular V17版本中，Angular变更检查得到了升级🚀！</p>\n<p>Angular模版现在知道信号而不是简单的方法调用。<a href=\"https://github.com/angular/angular/pull/49153\">实现这一目标的PRs之一</a>。</p>\n<p>之前我们使用<strong>async</strong>管道，他会调用<strong>markForCheck</strong>方法，而使用信号，我们只需要正常的调用它们。Angular会注册一个副作用（consumer），这会监听信号改变并标记模版以进行检查。</p>\n<p><img src=\"https://img.kidwen.top/file/9d35367dd8c215bc44b98.jpg\" alt=\"\"></p>\n<p>这样做的好处是我们不再需要异步管道了</p>\n<p>第二个改进变更检查的<a href=\"https://github.com/angular/angular/pull/51537\">PR</a>：这解决了一个与信号无关的问题，但与变更检查本身有关。</p>\n<p>通过使用它引入的机制，下面第三个<a href=\"https://github.com/angular/angular/pull/52302\">PR</a>增加了Global + Local变更检查。</p>\n<p>让我们更好的理解Global + Local变更检查👇：</p>\n<h3 id=\"Local-变更检查\">Local 变更检查</h3>\n<p>我在上面几个PR中为Angular引入两个新标记。</p>\n<p><img src=\"https://img.kidwen.top/file/574107055dc6ceeda1f18.jpg\" alt=\"\"></p>\n<p>它们是如何工作的？</p>\n<p>当模版副作用执行时候，Angular会调用<strong>markViewForRefresh</strong>方法，这会设置当前组件状态为<strong>RefreshView</strong>并且会调用<strong>markAncestorsForTraversal</strong>这会标记所有的祖先为<strong>HAS_CHILD_VIEW_REFRESH</strong>状态。</p>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * 当前组件添加`RefreshView`标识，并对祖先组件添加`HAS_CHILD_VIEW_REFRESH`</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> function</span><span style=\"color:#B392F0\"> markViewForRefresh</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">lView</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> LView</span><span style=\"color:#E1E4E8\">) &#123;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (lView[</span><span style=\"color:#79B8FF\">FLAGS</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> LViewFlags.RefreshView) &#123;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lView[</span><span style=\"color:#79B8FF\">FLAGS</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LViewFlags.RefreshView;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">viewAttachedToChangeDetector</span><span style=\"color:#E1E4E8\">(lView)) &#123;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        markAncestorsForTraversal</span><span style=\"color:#E1E4E8\">(lView);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;</span></span></code></pre>\n<p>下面图示（更新了树结构以展示更多的边缘情况）</p>\n<p><img src=\"https://img.kidwen.top/file/ed491a258349090727287.jpg\" alt=\"\"></p>\n<p>因此，有信号变化的组件会被标上橙色边框，而父代现在有⏬ 图标，表示它们有子代视图需要刷新。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>NOTE: 我们仍然需要zone.js来触发变更检查</p></blockquote>\n<p>一旦 zone.js 启动（原因与之前相同），它就会调用 <strong>appRef.tick()</strong> ，然后我们就可以自上而下地检测变化，并制定一些不同的新规则！</p>\n<h3 id=\"Targeted-Mode-Rules-目标模式规则\">Targeted Mode Rules(目标模式规则)</h3>\n<p>NgZone 在<strong>GlobalMode</strong>下触发变化检测（它将自上而下地检查和刷新所有组件）</p>\n<p>在 <strong>GlobalMode</strong> 中，我们检查 <strong>CheckAlways</strong>（未设置任何更改检测策略的正常组件）和 <strong>Dirty OnPush</strong> 组件</p>\n<h3 id=\"什么触发了TargetedMode\">什么触发了TargetedMode?</h3>\n<ul>\n<li>在<strong>GlobalMode</strong>模式下，当遇到一个非脏状态的<strong>OnPush</strong>策略的组件时会切换到<strong>TargetedMode</strong>!</li>\n</ul>\n<p>在 <strong>TargetedMode</strong> 模式下：</p>\n<ul>\n<li>只有设置了<strong>RefreshView</strong>标识的组件才会刷新视图</li>\n<li>不刷新<strong>CheckAlways</strong>或者常规的脏状态组件视图</li>\n</ul>\n<ul>\n<li>如果我们到达一个带有 <strong>RefreshView</strong> 标记的视图，就会以全局模式遍历子视图</li>\n</ul>\n<p>下面逐一介绍各个部分组成</p>\n<ol>\n<li>\n<p>跟组件是一个普通组件（<strong>CheckAlways</strong>），因此我们可以在需要时检查和刷新绑定，然后继续处理子组件</p>\n<p><img src=\"https://img.kidwen.top/file/1b4db896203bddca045e4.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p>所有的<strong>CheckAlways</strong>组件将继续和之前一样工作。</p>\n<p><img src=\"https://img.kidwen.top/file/5c0892f4ddccc03f746b2.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p><strong>OnPush</strong>将继续以同样的方式工作，因此如果没有标记为脏状态就不会被检查。</p>\n</li>\n<li>\n<p>如果我们检查另外一个<strong>OnPush</strong> + <strong>HAS_CHILD_VIEWS_TO_REFRESH</strong>但不是脏状态的组件，我们就会得到<strong>TargetedMode</strong>的触发器。<img src=\"https://img.kidwen.top/file/5c0892f4ddccc03f746b2.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p>组件本身不会刷新，让我们来看一下子组件吧。</p>\n<p><img src=\"https://img.kidwen.top/file/c5a3abafb729cd731cd24.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p>然后，我们到达一个 <strong>RefreshView</strong> 组件，并进入 <strong>TargetedMode</strong> 模式，这意味着我们会刷新绑定。我们还转换为 <strong>GlobalMode</strong>，以确保 <strong>CheckAlways</strong> 子组件也能正确刷新。</p>\n<p><img src=\"https://img.kidwen.top/file/d81862a36f09a6b4339fd.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p>现在我们处于全局模式（<strong>GlobalMode</strong>），并且有一个<strong>CheckAlways</strong>组件，所以我们只需要正常刷新即可。</p>\n<p><img src=\"https://img.kidwen.top/file/e86245f2f4e47090df110.jpg\" alt=\"\"></p>\n</li>\n</ol>\n<p>这就是新的&quot;目标检查（<strong>Targeted Change Detection</strong>）&quot;的全部内容。</p>\n<p>如果我们看一下最终的树，就会发现当我们到达一个不脏的 OnPush 组件时，我们跳过的组件比以前更多了。</p>\n<p><img src=\"https://img.kidwen.top/file/8b30808ed244f7dad2c93.jpg\" alt=\"\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Targeted Change Detection = OnPush without footguns 🔫</p></blockquote>\n<p>您可以在这款由 Mathieu Riegler 🔨 制作的<a href=\"https://jeanmeche.github.io/angular-change-detection\">应用程序</a>中玩转所有这些变化检测规则。</p>\n<h3 id=\"Zoneless-Angular-让我们从-Angular-中移除-zone-js\">Zoneless Angular - 让我们从 Angular 中移除 zone.js</h3>\n<p>从 Angular 中移除 zone.js 后，我们将只剩下运行但不会更新视图中任何内容的代码（zone.js 的引导时间及其对浏览器造成的所有压力也会被移除）！我们还将 <code>15kb</code> 从 bundle 大小中移除 😎）。因为没有任何东西会触发 appRef.tick()。</p>\n<p>但是，Angular 有一些 API 可以告诉它发生了什么变化。是哪些呢？</p>\n<ul>\n<li>markForCheck（由异步管道使用）</li>\n<li>信号变化</li>\n<li>标记视图脏状态的事件处理程序</li>\n<li>在使用 <strong>setInput()</strong> 动态创建的组件上设置输入</li>\n</ul>\n<p>此外，OnPush 组件的工作原理已经表明，它需要告诉 Angular 有变化。</p>\n<p>因此，我们可以让 Angular 在知道有变化时计划 <strong>tick()</strong> ，而不是让 zone.js 计划 <strong>tick()</strong> 。</p>\n<p><a href=\"https://github.com/angular/angular/pull/53499\">参考</a></p>\n<p>在此 PR（实验性）中，我们可以看到 <strong>markViewDirty</strong> 现在会通知 <strong>changeDetectionScheduler</strong> 有变化。</p>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> function</span><span style=\"color:#B392F0\"> markViewDirty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">lView</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> LView</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> LView</span><span style=\"color:#F97583\">|</span><span style=\"color:#79B8FF\">null</span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lView[</span><span style=\"color:#79B8FF\">ENVIRONMENT</span><span style=\"color:#E1E4E8\">].changeDetectionScheduler?.</span><span style=\"color:#B392F0\">notify</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;</span></span></code></pre>\n<p>调度器应该调度 tick()，正如我们在无分区调度器的其他实验实现中看到的那样。</p>\n<p><a href=\"https://github.com/angular/angular/pull/53579\">参考</a></p>\n<pre class=\"shiki github-dark\" style=\"background-color:#24292e;color:#e1e4e8\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">@</span><span style=\"color:#B392F0\">Injectable</span><span style=\"color:#E1E4E8\">(&#123;providedIn: </span><span style=\"color:#9ECBFF\">'root'</span><span style=\"color:#E1E4E8\">&#125;)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ChangeDetectionSchedulerImpl</span><span style=\"color:#F97583\"> implements</span><span style=\"color:#B392F0\"> ChangeDetectionScheduler</span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#FFAB70\"> appRef</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> inject</span><span style=\"color:#E1E4E8\">(ApplicationRef);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#FFAB70\"> taskService</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> inject</span><span style=\"color:#E1E4E8\">(PendingTasks);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#FFAB70\"> pendingRenderTaskId</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> number</span><span style=\"color:#F97583\">|</span><span style=\"color:#79B8FF\">null</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    notify</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> void</span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.pendingRenderTaskId </span><span style=\"color:#F97583\">!==</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.pendingRenderTaskId </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.taskService.</span><span style=\"color:#B392F0\">add</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        setTimeout</span><span style=\"color:#E1E4E8\">(() </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.appRef.destroyed) &#123;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    this</span><span style=\"color:#E1E4E8\">.appRef.</span><span style=\"color:#B392F0\">tick</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                &#125;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            &#125; </span><span style=\"color:#F97583\">finally</span><span style=\"color:#E1E4E8\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                const</span><span style=\"color:#79B8FF\"> taskId</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.pendingRenderTaskId</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                this</span><span style=\"color:#E1E4E8\">.pendingRenderTaskId </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                this</span><span style=\"color:#E1E4E8\">.taskService.</span><span style=\"color:#B392F0\">remove</span><span style=\"color:#E1E4E8\">(taskId);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            &#125;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        &#125;);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#125;</span></span></code></pre>\n<p>这只是试验性的，但我们可以看到，基本上，它将合并所有 notify() 调用，并只运行一次（在此代码中，每个宏任务只运行一次 - setTimeout，但也许每个微任务只运行一次 - Promise.resolve())。</p>\n<h3 id=\"我们应该从中理解什么？\">我们应该从中理解什么？</h3>\n<p>目前使用 OnPush 变更检测策略的应用程序在无区域的 Angular 世界中也能正常运行。</p>\n<h3 id=\"oneless-Angular-Glo-cal-local-change-detection\">oneless Angular !== Glo-cal (local) change detection</h3>\n<p>Zoneless Angular 与本地变更检测不同。Zoneless Angular 只是从 Angular 中移除 zone.js，并使用 Angular 已有的 API 来安排 tick()。</p>\n<p>真实本地变更检测是一项新功能，它允许我们只对目前使用 OnPush 变更检测策略的组件子树（而不是整个组件树）进行变更检测。</p>\n<h3 id=\"信号变化检测（无-OnPush、无-Zone-js，仅信号）\">信号变化检测（无 OnPush、无 Zone.js，仅信号）</h3>\n<p>信号变化检测将带来的一个功能是本机单向数据流（双向数据绑定，无需头痛）。</p>\n<p>虽然使用 OnPush 和无分区进行全局变化检测非常好，但如果只使用信号组件，我们或许可以做得更好。</p>\n<p>如果我们不必使用 OnPush 呢？或者用 HAS_CHILD_VIEWS_TO_REFRESH 标记父代，然后对整个组件树运行更改检测？如果我们可以只对组件内发生变化的视图运行变化检测呢？</p>\n<p>请阅读 RFC 中的更多内容：<a href=\"https://github.com/angular/angular/discussions/49682\">参考</a></p>\n","feature":true,"text":"Angular 是一个组件驱动框架。和其他框架一样，他向用户展示数据并在数据变化后刷新视图。 在模版中显示用户数据 随着项目的增长，我们会创建越来越多的组件，并...","permalink":"/post/angular-change-detection","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"ANGULAR","slug":"ANGULAR","count":8,"path":"api/categories/ANGULAR.json"}],"tags":[{"name":"angular","slug":"angular","count":5,"path":"api/tags/angular.json"},{"name":"zone.js","slug":"zone-js","count":1,"path":"api/tags/zone-js.json"},{"name":"zoneless","slug":"zoneless","count":1,"path":"api/tags/zoneless.json"},{"name":"local change detection","slug":"local-change-detection","count":1,"path":"api/tags/local-change-detection.json"},{"name":"signals","slug":"signals","count":1,"path":"api/tags/signals.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%98%E6%9B%B4%E6%A3%80%E6%9F%A5\"><span class=\"toc-text\">同步代码的变更检查</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%98%E6%9B%B4%E6%A3%80%E6%9F%A5\"><span class=\"toc-text\">异步代码的变更检查</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Zone-js\"><span class=\"toc-text\">Zone.js</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Zone-js-Angular\"><span class=\"toc-text\">Zone.js + Angular</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E6%A0%87%E8%AE%B0%E4%B8%BA%E8%84%8F%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">组件标记为脏状态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%88%B7%E6%96%B0\"><span class=\"toc-text\">组件绑定刷新</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#OnPush-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%9F%A5%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">OnPush 变更检查策略</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#OnPush-Observables-async-pipe\"><span class=\"toc-text\">OnPush + Observables + async pipe</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#OnPush-Observables-%E8%B0%81%E8%A7%A6%E5%8F%91%E4%BA%86zone-js\"><span class=\"toc-text\">OnPush + Observables + 谁触发了zone.js</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8A%8A%E6%89%80%E6%9C%89%E7%A5%96%E5%85%88%E9%83%BD%E6%A0%87%E8%AE%B0%E4%B8%BA%E8%84%8F%E7%8A%B6%E6%80%81%EF%BC%9F\"><span class=\"toc-text\">为什么要把所有祖先都标记为脏状态？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%8F%AA%E5%AF%B9%E6%A0%87%E8%AE%B0%E7%9A%84%E7%BB%84%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8F%98%E6%9B%B4%E6%A3%80%E6%9F%A5%EF%BC%9F\"><span class=\"toc-text\">为什么不能只对标记的组件运行变更检查？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#markForCheck-vs-detectChanges-%EF%BC%88%E5%90%88%E5%B9%B6%E8%BF%90%E8%A1%8C-vs-%E5%90%8C%E6%AD%A5%E8%BF%90%E8%A1%8C%EF%BC%89\"><span class=\"toc-text\">markForCheck vs detectChanges （合并运行 vs 同步运行）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%BB%E5%8A%A1%E4%B8%AD%E5%AE%89%E6%8E%92-detectChanges-%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">不可以在下一个浏览器任务中安排 detectChanges 吗？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Signals\"><span class=\"toc-text\">Signals</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%A1%E5%8F%B7%E5%92%8C%E5%8F%98%E6%9B%B4%E6%A3%80%E6%9F%A5\"><span class=\"toc-text\">信号和变更检查</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Local-%E5%8F%98%E6%9B%B4%E6%A3%80%E6%9F%A5\"><span class=\"toc-text\">Local 变更检查</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Targeted-Mode-Rules-%E7%9B%AE%E6%A0%87%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99\"><span class=\"toc-text\">Targeted Mode Rules(目标模式规则)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E8%A7%A6%E5%8F%91%E4%BA%86TargetedMode\"><span class=\"toc-text\">什么触发了TargetedMode?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Zoneless-Angular-%E8%AE%A9%E6%88%91%E4%BB%AC%E4%BB%8E-Angular-%E4%B8%AD%E7%A7%BB%E9%99%A4-zone-js\"><span class=\"toc-text\">Zoneless Angular - 让我们从 Angular 中移除 zone.js</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E4%BB%8E%E4%B8%AD%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">我们应该从中理解什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#oneless-Angular-Glo-cal-local-change-detection\"><span class=\"toc-text\">oneless Angular !&#x3D;&#x3D; Glo-cal (local) change detection</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%A1%E5%8F%B7%E5%8F%98%E5%8C%96%E6%A3%80%E6%B5%8B%EF%BC%88%E6%97%A0-OnPush%E3%80%81%E6%97%A0-Zone-js%EF%BC%8C%E4%BB%85%E4%BF%A1%E5%8F%B7%EF%BC%89\"><span class=\"toc-text\">信号变化检测（无 OnPush、无 Zone.js，仅信号）</span></a></li></ol>","author":{"name":"Kidwen","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/38277891?v=4","link":"/","description":"Frontend","socials":{"github":"https://github.com/kidwen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Angular linkedSignal()","uid":"374a67da1401504fdc674bb6037a7b30","slug":"angular-linked-signal","date":"2025-07-03T07:16:16.218Z","updated":"2025-07-10T07:19:02.319Z","comments":true,"path":"api/articles/angular-linked-signal.json","keywords":null,"cover":"https://img.kidwen.top/file/AgACAgUAAyEGAASHUuUOAAM6aGZI5J5sPb08-Fay3kk_hWBxMjYAAkTHMRsn2DBXuesp_uBTHlwBAAMCAAN4AAM2BA.png","text":"随着Angular 19发布，Angular添加了一些新的功能。本文主要介绍Angular linked signal的基础用法和 computed 的区别，以...","permalink":"/post/angular-linked-signal","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"ANGULAR","slug":"ANGULAR","count":8,"path":"api/categories/ANGULAR.json"}],"tags":[{"name":"angular signal","slug":"angular-signal","count":1,"path":"api/tags/angular-signal.json"}],"author":{"name":"Kidwen","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/38277891?v=4","link":"/","description":"Frontend","socials":{"github":"https://github.com/kidwen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"angular v16 signal api 介绍","uid":"67a0811293cd2bc9df0f8e11e20e867f","slug":"angular-signal-api","date":"2023-07-21T08:00:00.000Z","updated":"2026-02-11T06:05:14.085Z","comments":true,"path":"api/articles/angular-signal-api.json","keywords":null,"cover":"/images/angular-signal-api.webp","text":"本文介绍 Angular signal库的 API 接口和一些实现细节。 signal在Angular中是一种具有明确变更语义的值。在 Angular 中，si...","permalink":"/post/angular-signal-api","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"11 mins."},"categories":[{"name":"ANGULAR","slug":"ANGULAR","count":8,"path":"api/categories/ANGULAR.json"}],"tags":[{"name":"angular","slug":"angular","count":5,"path":"api/tags/angular.json"}],"author":{"name":"Kidwen","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/38277891?v=4","link":"/","description":"Frontend","socials":{"github":"https://github.com/kidwen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}