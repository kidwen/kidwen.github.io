{"title":"angular v16 signal 介绍","uid":"a7b5aeb1d279a19d567b0b432761bc79","slug":"frontend/angular-v16","date":"2023-07-13T03:00:00.000Z","updated":"2023-09-04T01:40:38.177Z","comments":true,"path":"api/articles/frontend/angular-v16.json","keywords":null,"cover":"/images/angular-16.png","content":"<p>2023年05月03日，angular v16 正式发布。此次更新添加了<code>Signals</code>作为<code>angular</code>新的响应单元(<code>reactive primitive</code>)。<code>angular</code>的响应式系统依赖于<code>zone.js</code>。但是<code>zone.js</code>对于模型的变更没有提供更细粒度的信息通知。<code>zone.js</code>只能够通知到<code>angular</code>程序中什么时候某些东西可能发生了改变，但是没有给到更多的信息关于发生了什么或者什么东西改变了。这代表着以后的某个版本<code>zone.js</code>将被移除。</p>\n<h2 id=\"Signals-定义\"><a href=\"#Signals-定义\" class=\"headerlink\" title=\"Signals 定义\"></a><code>Signals</code> 定义</h2><p><code>Signals</code> 是值的包装，它能够在值发生变更的时候通知到相应的消费者。<code>Signals</code> 有多种类型。</p>\n<p>一些 <code>Signals</code> 可以通过 <code>mutation Api</code> 直接改变值，这些被称为 <code>writable signals</code>。模型的变更总是通过更改一个或者多个<code>writable signals</code>。</p>\n<p>由于读取<code>signal</code>是通过<code>getter</code>而不是访问普通变量或者值，所以<code>signal</code>可以知道他们在哪里被读取了。而且突变总是通过<code>mutation Api</code>完成的，所以<code>Signals</code>知道什么时候发生变更，并通知消费者有关变更的信息。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><h3 id=\"Signals-特性\"><a href=\"#Signals-特性\" class=\"headerlink\" title=\"Signals 特性\"></a><code>Signals</code> 特性</h3><ul>\n<li>能够通知 <code>Angular</code> 有关影响各个组件的模型更改。</li>\n<li>能够提供对模型的同步访问。</li>\n<li>读取值的时候无副作用。</li>\n<li>_glitch fre_e：读取值永远不应该返回不一致的状态。</li>\n<li>依赖性跟踪应该符合工程学。</li>\n</ul></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><h3 id=\"Signals-优点\"><a href=\"#Signals-优点\" class=\"headerlink\" title=\"Signals 优点\"></a><code>Signals</code> 优点</h3><ul>\n<li>框架可以追踪模板中访问了那些<code>signals</code>，可以获取关于哪些组件被模型中的数据改变所影响的更细粒度的信息。</li>\n<li><code>Signals</code> 可以同步获取到他们的值。</li>\n<li>读值不会造成副作用。</li>\n<li>现代<code>Signals</code>实现是<a href=\"https://en.wikipedia.org/wiki/Reactive_programming#Glitches\">无故障的</a>，并且不会向用户暴露不一致的状态。</li>\n<li><code>Signals</code>实现可以自动跟踪依赖关系。</li>\n<li><code>Signals</code>可以在任何地方使用，而不仅仅是在组件中，这与 Angular 的依赖注入系统配合得很好。</li>\n<li>计算<code>Signals</code>可以是<code>lazy</code>，并且仅根据需要重新计算中间值。</li>\n<li>开发人员需要学习的概念相对较少。</li>\n<li>它们很容易与其他反应性系统组合，包括 RxJS 和 Angular 当前基于区域的反应性。</li>\n</ul></blockquote>\n<h2 id=\"Computed\"><a href=\"#Computed\" class=\"headerlink\" title=\"Computed\"></a><code>Computed</code></h2><p><code>computed signal</code> 不能直接改变，而是根据其他<code>sinals</code>的变化而变更，（类比<code>vue</code>的计算属性）。</p>\n<h2 id=\"Effects\"><a href=\"#Effects\" class=\"headerlink\" title=\"Effects\"></a><code>Effects</code></h2><p>当 <code>Signals</code> 发生变更后会通知消费者，当<code>signals</code>发生变更后执行的操作称为<code>effect</code>。例如当组件模板中的使用的<code>signals</code>发生变更时，angular会通过<code>effect</code>更新视图ui。</p>\n<h2 id=\"Automatic-Dependency-Tracking\"><a href=\"#Automatic-Dependency-Tracking\" class=\"headerlink\" title=\"Automatic Dependency Tracking\"></a><code>Automatic Dependency Tracking</code></h2><p>当<code>computed signals </code>和<code>effect</code>运行时，它们会跟踪哪些<code>signals</code>被读取作为<code>computed</code>或<code>effect</code>函数的一部分。了解依赖关系允许<code>signal</code>系统在任何<code>Signals</code>依赖关系发生变化时自动重新运行<code>computation</code>或<code>effect</code>函数。</p>\n<h2 id=\"Signals-集成\"><a href=\"#Signals-集成\" class=\"headerlink\" title=\"Signals 集成\"></a><code>Signals</code> 集成</h2><div class=\"custom-quote danger\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M19.76 5.23C15.84 5.23 12 2 12 2C12 2 8.15996 5.23 4.23996 5.23C4.23996 5.23 1.86996 16.99 12 22C22.13 16.99 19.76 5.23 19.76 5.23Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 16H12\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p>由于zone.js和 <code>signals</code>基于不同的数据在应用程序中流经的不同的假设，而且使用<code>zone.js</code>编写的代码如果没有<code>zone.js</code>可能会无法运行。<br>所以暂时不会移除<code>zone.js</code>，而是共存。</p>\n</div>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><h3 id=\"Signals-将会影响-angular-多个地方\"><a href=\"#Signals-将会影响-angular-多个地方\" class=\"headerlink\" title=\"Signals 将会影响 angular 多个地方\"></a><code>Signals</code> 将会影响 <code>angular</code> 多个地方</h3><p>数据流和模型同步<br>变更检查过程<br>组件生命周期<br>框架产生的响应式数据（例如：<code>@Input</code>）</p></blockquote>\n<p>与 zone.js 不同，<code>Signals</code>提供有关模型的哪些部分已更改的细粒度信息，基于<code>Signals</code>的组件不参与全局更改检测。相反，Angular 知道组件模板的不同部分使用了哪些<code>Signals</code>，并且仅在<code>Signals</code>更改时将该组件与 DOM 同步。<br>当且仅当模板中读取的<code>Signals</code>通知 Angular 它已更改时，才会安排组件的更改检测。<br>事实上，在当前的设计中，这种更改检测将针对组件内的每个视图独立发生。</p>\n<h3 id=\"Signal-based-组件\"><a href=\"#Signal-based-组件\" class=\"headerlink\" title=\"Signal-based 组件\"></a><code>Signal-based 组件</code></h3><p>使用组件作为反应性系统之间的边界将允许应用程序开发人员逐渐选择在现有应用程序中发出反应性<code>signal</code>，并允许库作者将其库转换为以向后兼容的方式使用<code>signal</code>。</p>\n<h3 id=\"局部变更检查\"><a href=\"#局部变更检查\" class=\"headerlink\" title=\"局部变更检查\"></a>局部变更检查</h3><p>当且仅当模板中读取的<code>signal</code>通知 Angular 它已发生更改时，才会安排组件的更改检测。</p>\n<p>在当前的设计中，这种变更检测将针对组件内的每个视图独立发生。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>angular 视图概念<br><code>views</code>是angular模版中的静态片段 - 已知 UI 元素、指令和子组件的集合。视图组合在一起以创建可以表达 UI 的条件或重复部分的模板。<br>下面的组件模版是一个视图</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;div&gt;\n    &lt;label&gt;Who: &lt;input name&#x3D;&quot;who&quot;&gt;&lt;&#x2F;label&gt;\n    &lt;label&gt;What: &lt;input name&#x3D;&quot;what&quot;&gt;&lt;&#x2F;label&gt;\n&lt;&#x2F;div&gt;</code></pre>\n<p>而此模板有两个视图 - 带有“Who”和“What”的外部 DOM，以及一个有条件显示的嵌入视图，其中包含“Why”：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;div&gt;\n    &lt;label&gt;Who: &lt;input name&#x3D;&quot;who&quot;&gt;&lt;&#x2F;label&gt;\n    &lt;label&gt;What: &lt;input name&#x3D;&quot;what&quot;&gt;&lt;&#x2F;label&gt;\n    &lt;ng-container *ngIf&#x3D;&quot;showWhy&quot;&gt;\n        &lt;label&gt;Why: &lt;input name&#x3D;&quot;why&quot;&gt;&lt;&#x2F;label&gt;\n    &lt;&#x2F;ng-container&gt;\n&lt;&#x2F;div&gt;</code></pre>\n<p><code>NgIf</code> 或 <code>NgSwitchCase</code> 的每个分支以及 <code>NgFor</code> 的每一行都是 <code>Angular</code> 中独立视图的示例。</p></blockquote>\n<h3 id=\"局部变化检测的粒度\"><a href=\"#局部变化检测的粒度\" class=\"headerlink\" title=\"局部变化检测的粒度\"></a>局部变化检测的粒度</h3><ul>\n<li>整个应用程序：立即处理整个应用程序（zone.js 的作用，OnPush 优化除外）。</li>\n<li>组件树：遍历各个子树（单个组件及其子组件）</li>\n<li>单个组件：检查组件（包括其所有视图），但不检查其子组件</li>\n<li>视图：单独检查每个视图（angular当前颗粒度）</li>\n<li>DOM 元素：单独更新每个 DOM 元素的所有绑定（文本节点、元素等。SolidJS 在这个级别工作）</li>\n<li>绑定：单独更新每个 DOM 绑定</li>\n</ul>\n<h4 id=\"为什么选择视图级别？\"><a href=\"#为什么选择视图级别？\" class=\"headerlink\" title=\"为什么选择视图级别？\"></a>为什么选择视图级别？</h4><ol>\n<li><p>依赖追踪开销</p>\n<p> 设置依赖图解并不是免费的。<code>signal</code>速度很快，但跟踪越细粒度，图中需要分配和保存的节点就越多。这不仅需要时间，而且消耗内存。</p>\n</li>\n<li><p>检单独视图已经带来了大部分好处。</p>\n<p> 视图通常是具有可管理数量的绑定的 UI 小片段。评估和更改检测一小组绑定的成本已经非常低（Angular 现在对整个应用程序执行此操作）。</p>\n<p> 使用变更检测处理的最昂贵的组件通常是那些具有大型、重复、高度动态结构的组件，例如具有数百或数千行的数据表。这些组件自然已经分解为许多单独的视图（每一行至少是一个视图，也许更多）。通过基于视图的更改检测和正确结构化的模型，<code>signal</code>已可用于仅驱动表中一行的更新，而无需处理其他未更改的行。</p>\n</li>\n<li><p>基于视图的<code>signal</code>变更检测与基于<code>zone.js</code>的变更检测完美结合。</p>\n<p> 针对视图运行变更检测的操作已经是构建现有的基于区域的全应用程序变更检测系统的主要语法。对<code>signal</code>使用相同的粒度使互操作性变得更加简单，并允许两个反应性模型共享大部分底层实现代码。这将使我们能够引入<code>signal</code>反应性，而不会极大地影响捆绑包的大小。</p>\n</li>\n</ol>\n<h3 id=\"Input-是-signals\"><a href=\"#Input-是-signals\" class=\"headerlink\" title=\"@Input 是 signals\"></a><code>@Input</code> 是 <code>signals</code></h3><p>在基于<code>signal</code>的组件中，输入将是<code>signal</code>！这种选择的直接目的是为数据如何流经应用程序建立一个清晰、统一的模型。</p>\n<p>基于<code>signal</code>的输入对数据流有重大影响，因为它们作为<code>computed signal</code>工作，而不是检测到变化的表达式。</p>\n<h4 id=\"基于zone-js的inputs的工作方式\"><a href=\"#基于zone-js的inputs的工作方式\" class=\"headerlink\" title=\"基于zone.js的inputs的工作方式\"></a>基于<code>zone.js</code>的<code>inputs</code>的工作方式</h4><p>在基于<code>zone.js</code>的应用程序中，输入是在变化检测期间设置的。假设 HomePageCmp 有以下模板：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;user-profile [userData]&#x3D;&quot;authService.loggedInUser.data&quot; &#x2F;&gt;</code></pre>\n<p>如果<code>loggedInUser</code> 发生变化。 <code>zone.js</code> 会注意到发生了一些事情，但不知道具体发生了什么变化，并将触发整个应用程序的更改检测。更改检测将处理 <code>HomePageCmp</code> 并重新计算与 <code>[userData]</code> 的绑定：表达式 <code>authService.loggedInUser.data</code>。它会将 <code>UserProfileCmp.userData</code> 字段设置为新值，然后深入到 <code>UserProfileCmp</code> 并计算其模板（这可能会使用 <code>userData</code>）。</p>\n<h4 id=\"基于signal的inputs的工作方式\"><a href=\"#基于signal的inputs的工作方式\" class=\"headerlink\" title=\"基于signal的inputs的工作方式\"></a>基于<code>signal</code>的<code>inputs</code>的工作方式</h4><p>如果 <code>HomePageCmp</code> 和 <code>UserProfileCmp</code> 是基于<code>signal</code>的组件，则 <code>userData</code> 输入的功能将非常不同。当然，绑定必须使用 <code>LoggedInUser</code> signal：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;user-profile [userData]&#x3D;&quot;authService.loggedInUser().data&quot; &#x2F;&gt;</code></pre>\n\n<p>当首次创建 <code>HomePageCmp</code> 并创建其 <code>UserProfileCmp</code> 子级时，Angular 将为 <code>[userData]</code> 绑定表达式创建一个<code>computed signal</code>：<code>compute(() =&gt; authService.loggedInUser().data)</code>。然后将此派生<code>signal</code>作为 <code>UserProfileCmp</code> 的 <code>userData</code> 输入的值提供。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>input signal</code>在变化检测之前解析<br>对 <code>userData</code> 输入<code>signal</code>的更新发生在变更检测之前，而不是检测期间。</p></blockquote>\n<ul>\n<li><code>ExpressionChangedAfterItHasBeenChecked</code> 错误不再是风险，因为模型在检查之前已完全同步。 （非确定性模型仍然会导致此类错误，但这是另一个问题）</li>\n<li>数据可以独立于 UI 层次结构流动，而不是被迫仅从父级流向子级。不需要 setTimeout 或 Promise.resolve 或其他技巧。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>输入绑定不会触发绑定方中的局部变更检测。</p></blockquote>\n<p>因为 <code>userData</code> 的绑定是作为<code>computed signal</code>提供的，所以 <code>HomePageCmp</code> 中的任何视图都不依赖于它的值。根据基于<code>signal</code>的变更检测的黄金法则，其任何视图都不会被检测到变更。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>输入绑定不会自动触发接收者中的本地更改检测。</p></blockquote>\n<p>因为 <code>UserProfileCmp</code> 接收 <code>userData</code> 作为<code>computed signal</code>并不意味着当 <code>userData</code> 更改时将检测到其任何视图的更改。根据黄金法则，只有在 <code>UserProfileCmp</code> 读取其模板中某处的 <code>userData</code> 输入<code>signal</code>时，才会检测到更改。</p>\n<p>换句话说，模板中实际未使用的输入不会触发基于<code>signal</code>的组件中的任何更改检测。</p>\n<h3 id=\"查询-是-signals\"><a href=\"#查询-是-signals\" class=\"headerlink\" title=\"查询 是 signals\"></a>查询 是 <code>signals</code></h3><p>与输入类似，视图和子查询是框架“producing”代表组件模型某些方面的反应值的示例。在基于<code>signal</code>的组件中，查询也将作为<code>signal</code>公开。这允许组件自然地对通过计算属性或效果更改的查询做出反应，就像输入一样。</p>\n<h3 id=\"Signal-和-Zone-混合组件\"><a href=\"#Signal-和-Zone-混合组件\" class=\"headerlink\" title=\"Signal 和 Zone 混合组件\"></a><code>Signal</code> 和 <code>Zone</code> 混合组件</h3><p>可以在同一应用程序中自由混合<code>signal</code>和<code>non-signal</code>组件。只要遵守<code>signal</code>分量的黄金法则，即使跨越这些边界，变化检测也应该正确运行。</p>\n<p>当<code>signal</code>组件向<code>non-signal</code>组件提供输入绑定时，<code>signal</code>语义用于检测绑定何时发生更改，并设置<code>non-signal</code>组件的输入，在必要时将其标记为检查，并在需要时运行 <code>ngOnChanges</code>。</p>\n<p>当非<code>signal</code>组件绑定到<code>signal</code>组件的输入时，会发生类似的转换。在<code>non-signal</code>组件的更改检测期间，将评估绑定，如果值已更改，则更新传递给子组件的输入<code>signal</code>。</p>\n<div class=\"custom-quote danger\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M19.76 5.23C15.84 5.23 12 2 12 2C12 2 8.15996 5.23 4.23996 5.23C4.23996 5.23 1.86996 16.99 12 22C22.13 16.99 19.76 5.23 19.76 5.23Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 16H12\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">WARNING</p>\n<p><h4 id=\"non-signal-问题\"><a href=\"#non-signal-问题\" class=\"headerlink\" title=\"non-signal 问题\"></a><code>non-signal</code> 问题</h4><p>有时，指令通过本地引用或 DI 系统为其使用者公开 API。例如，NgModel 将其当前值公开为公共属性，可通过本地引用访问：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;input ngModel #in&#x3D;&quot;ngModel&quot;&gt;\n&lt;p&gt;You typed: &#123;&#123; in.value &#125;&#125;&lt;&#x2F;p&gt;</code></pre>\n<p>此类 API 在<code>signal</code>组件中可能会出现问题，因为 in.value 不是<code>signal</code>，不能用于触发<code>signal</code>组件的更改检测，即使它随着用户键入而更改。</p>\n<p>在基于<code>zone</code>的组件中，无论如何依赖来自子级的数据都是一个很大的问题。如果当前值的反射移动到 <input> 声明上方，则会导致 <code>ExpressionChangedAfterItHasBeenChecked</code> 错误。</p>\n</div>\n<h2 id=\"Zoneless-Angular\"><a href=\"#Zoneless-Angular\" class=\"headerlink\" title=\"Zoneless Angular\"></a>Zoneless Angular</h2><p>有了<code>signal</code>，就可以在没有 zone.js 的情况下构建 Angular 应用程序。仅<code>signal</code>应用程序将直接安排各个视图的更改检测（可能通过 <code>requestAnimationFrame</code> 或其他一些浏览器语法），而不是依赖区域来进行更改检测。</p>\n<p>在此类应用程序中，尝试使用基于<code>zone</code>的组件将是错误的。</p>\n<h2 id=\"zone-js\"><a href=\"#zone-js\" class=\"headerlink\" title=\"zone.js\"></a><code>zone.js</code></h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Angular 使用 zone.js 来跟踪浏览器中的各种事件（例如 DOM 事件、网络请求和计时器）。 Zone.js 通过对任何可能导致应用程序模型更改的 API 进行猴子修补（在运行时包装和修补回调函数）来跟踪这些事件。然而，当发生此类事件时，Angular 没有任何关于发生了哪些具体更改的信息，或者即使根本没有任何更改。<br>在收到来自 zone.js 的事件通知后，Angular 将读取（拉取）新的模型值，并根据之前看到的模型值的差异来更新 UI。</p></blockquote>\n","feature":true,"text":"2023年05月03日，angular v16 正式发布。此次更新添加了Signals作为angular新的响应单元(reactive primitive)。a...","link":"","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"FRONTEND","slug":"FRONTEND","count":7,"path":"api/categories/FRONTEND.json"}],"tags":[{"name":"angular","slug":"angular","count":4,"path":"api/tags/angular.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Signals-%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">Signals 定义</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Signals-%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">Signals 特性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Signals-%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">Signals 优点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Computed\"><span class=\"toc-text\">Computed</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Effects\"><span class=\"toc-text\">Effects</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Automatic-Dependency-Tracking\"><span class=\"toc-text\">Automatic Dependency Tracking</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Signals-%E9%9B%86%E6%88%90\"><span class=\"toc-text\">Signals 集成</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Signals-%E5%B0%86%E4%BC%9A%E5%BD%B1%E5%93%8D-angular-%E5%A4%9A%E4%B8%AA%E5%9C%B0%E6%96%B9\"><span class=\"toc-text\">Signals 将会影响 angular 多个地方</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Signal-based-%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">Signal-based 组件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%80%E9%83%A8%E5%8F%98%E6%9B%B4%E6%A3%80%E6%9F%A5\"><span class=\"toc-text\">局部变更检查</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%80%E9%83%A8%E5%8F%98%E5%8C%96%E6%A3%80%E6%B5%8B%E7%9A%84%E7%B2%92%E5%BA%A6\"><span class=\"toc-text\">局部变化检测的粒度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E8%A7%86%E5%9B%BE%E7%BA%A7%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">为什么选择视图级别？</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Input-%E6%98%AF-signals\"><span class=\"toc-text\">@Input 是 signals</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8Ezone-js%E7%9A%84inputs%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">基于zone.js的inputs的工作方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8Esignal%E7%9A%84inputs%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">基于signal的inputs的工作方式</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2-%E6%98%AF-signals\"><span class=\"toc-text\">查询 是 signals</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Signal-%E5%92%8C-Zone-%E6%B7%B7%E5%90%88%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">Signal 和 Zone 混合组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#non-signal-%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">non-signal 问题</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Zoneless-Angular\"><span class=\"toc-text\">Zoneless Angular</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#zone-js\"><span class=\"toc-text\">zone.js</span></a></li></ol>","author":{"name":"Kidwen","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/38277891?v=4","link":"/","description":"Frontend","socials":{"github":"https://github.com/kidwen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"angular v16 signal api 介绍","uid":"67a0811293cd2bc9df0f8e11e20e867f","slug":"frontend/angular-signal-api","date":"2023-07-21T08:00:00.000Z","updated":"2023-08-03T05:38:09.338Z","comments":true,"path":"api/articles/frontend/angular-signal-api.json","keywords":null,"cover":"/images/angular-signal-api.webp","text":"本文介绍 Angular signal库的 API 接口和一些实现细节。 signal在Angular中是一种具有明确变更语义的值。在 Angular 中，si...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"FRONTEND","slug":"FRONTEND","count":7,"path":"api/categories/FRONTEND.json"}],"tags":[{"name":"angular","slug":"angular","count":4,"path":"api/tags/angular.json"}],"author":{"name":"Kidwen","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/38277891?v=4","link":"/","description":"Frontend","socials":{"github":"https://github.com/kidwen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"响应式主题","uid":"26df78b12ea8461da2d0f20e21f4a6a9","slug":"frontend/theming","date":"2023-06-15T05:30:00.000Z","updated":"2023-07-31T08:33:52.918Z","comments":true,"path":"api/articles/frontend/theming.json","keywords":null,"cover":"/images/theming.jpeg","text":"将页面自适应匹配用户的喜好，例如黑色模式 可以调整网站的展示以匹配用户的喜好。首先，需要知道如何借力浏览器来增加网站曝光从而提高品牌知名度。 自定义浏览器界面一...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"FRONTEND","slug":"FRONTEND","count":7,"path":"api/categories/FRONTEND.json"}],"tags":[{"name":"theming","slug":"theming","count":1,"path":"api/tags/theming.json"}],"author":{"name":"Kidwen","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/38277891?v=4","link":"/","description":"Frontend","socials":{"github":"https://github.com/kidwen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}