{"title":"angular v16 signal api 介绍","uid":"67a0811293cd2bc9df0f8e11e20e867f","slug":"frontend/angular-signal-api","date":"2023-07-21T08:00:00.000Z","updated":"2023-07-21T09:24:45.700Z","comments":true,"path":"api/articles/frontend/angular-signal-api.json","keywords":null,"cover":"/images/angular-16.png","content":"<p>本文介绍 <code>Angular signal</code>库的 <code>API</code> 接口和一些实现细节。</p>\n<p><code>signal</code>在<code>Angular</code>中是一种具有明确变更语义的值。在 Angular 中，<code>signal</code>通过一个零参数的<code>getter</code>函数来表示，该函数返回当前<code>signal</code>的值。</p>\n<p>在这个<code>getter</code>函数中会使用 <code>SIGNAL</code> 符号进行标记，这样<code>Angular</code>框架就能够识别它是一个<code>signal</code>，并且可以应用一些内部的优化措施来提升性能。</p>\n<p><code>signal</code>是只读的，意味着我们可以获取当前<code>signal</code>的值，但不能直接修改它。我们可以观察<code>signal</code>的变化通知，以便在值发生变化时做出相应的处理。这种只读的特性使得<code>signal</code>在响应式编程中非常有用，因为它们可以用于实现数据的观察和响应。</p>\n<p>这个<code>getter</code>函数被用于获取当前<code>signal</code>的值，并在响应式编程的上下文中记录<code>signal</code>的读取操作。这个操作对于构建响应式依赖图来说非常关键。在 <code>Angular</code> 中，响应式依赖图用于追踪数据的依赖关系，当依赖的数据发生变化时，相关的部分会得到更新。这种机制使得 <code>Angular</code> 能够高效地处理数据的变化和重新渲染视图。</p>\n<p>在响应式上下文之外，我们仍然可以对<code>signal</code>进行读取操作。这使得非响应式的代码（比如现有的、来自第三方的库）可以随时读取<code>signal</code>的值，而无需了解<code>signal</code>的响应式特性。这种设计使得<code>signal</code>可以在现有的代码中轻松地使用，而不需要对现有代码做任何修改。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Signal<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span><span class=\"token constant\">SIGNAL</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"可写signal\"><a href=\"#可写signal\" class=\"headerlink\" title=\"可写signal\"></a>可写<code>signal</code></h2><p>Angular signals库将提供可写<code>signal</code>的默认实现，可以通过内置的修改方法（<code>set</code>、<code>update</code>、<code>mutate</code>）进行更改：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">WritableSignal<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Signal<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">/**\n     * 我们可以直接使用设置方法（set）将`signal`的值设置为一个新的值。\n     * 一旦`signal`的值发生变化，它会自动通知所有依赖于这个`signal`的部分，从而触发相应的更新。\n     * 这种自动通知机制是响应式编程的核心，它确保了数据的一致性和同步，使得我们能够有效地处理数据的变化，并及时反映到界面上。\n     *\n     * 使用可写`signal`的 set 方法在以下情况下非常有用：\n     * 1. 当我们需要更改原始值（例如数字、字符串等）时，直接使用 set 方法可以非常方便地更新`signal`的值。\n     * 2. 当新值与旧值之间没有依赖关系时，也就是说，新值不依赖于旧值的任何信息，我们可以直接使用 set 方法替换整个数据结构。\n     */</span>\n    <span class=\"token function\">set</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/**\n     * 使用可写`signal`的 update 方法可以基于当前`signal`的值进行更新。\n     * 你可以提供一个更新函数，该函数将根据当前`signal`的值计算新的值，并将新值应用到`signal`上。\n     * 一旦`signal`的值发生变化，它会自动通知所有依赖于这个`signal`的部分，从而触发相应的更新。\n     * 使用 update 方法可以非常方便地对`signal`的值进行递增、递减或应用其他自定义的计算逻辑。\n     * 这使得数据的更新更加灵活和自由，同时保持了响应式编程的特性，确保数据的一致性和同步。\n     * \n     * 1. 当我们需要设置一个新值，而这个新值依赖于旧值时，可以使用 update 方法。\n     * 例如，我们要对一个不可变的数据结构进行更新，可以通过提供一个更新函数来计算新的数据结构，并将其应用到`signal`上。\n     * 2. 在不可变的数据结构中，我们不能直接修改已有的数据，而是需要创建一个新的数据结构来表示修改后的结果。\n     * 使用 update 方法可以方便地进行这样的操作，而不需要手动处理数据的复制和更新。\n     */</span>\n    <span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">updateFn</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/**\n     * 使用可写`signal`的 mutate 方法可以直接在当前值上进行修改。\n     * 你可以提供一个修改函数，该函数将在当前值上进行原地修改，并将修改后的值应用到`signal`上。\n     * 一旦`signal`的值发生变化，它会自动通知所有依赖于这个`signal`的部分，从而触发相应的更新。\n     * 使用 mutate 方法可以方便地进行直接修改数据的操作，而不需要创建新的数据结构。\n     * 这对于某些特定的场景和数据结构的处理非常有帮助。\n     * 需要注意的是，这种方法是在原地修改数据，因此在使用时需要谨慎，确保不会导致数据的不一致或错误。\n     * \n     * 使用可写`signal`的 mutate 方法在以下情况下非常有用：\n     * 1. 当我们需要对`signal`的值进行内部修改，而不改变`signal`本身的引用（即身份）时，可以使用 mutate 方法。\n     * 例如，我们可以通过提供一个修改函数，在`signal`中存储的数组上添加新元素，而不需要创建一个新的数组，从而保持`signal`的引用不变。\n     * 1. mutate 方法可以用于原地修改`signal`的值，而不需要重新分配内存或创建新的数据结构，\n     * 这在一些性能敏感的情况下很有用。\n     */</span>\n    <span class=\"token function\">mutate</span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">mutatorFn</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/**\n     * 我们可以通过某种方式从一个可写`signal`派生出一个新的`signal`，这个新`signal`是只读的，即不能修改它的值。\n     * 这个只读`signal`仍然可以访问原始可写`signal`的值，但不允许对原始`signal`的值进行修改。\n     * \n     * 这种操作在某些场景下很有用，比如我们希望将一个可写`signal`暴露给其他部分，但不希望其他部分对该`signal`进行修改，以保持数据的一致性和可控性。\n     * 通过返回一个非可写`signal`，我们可以确保原始`signal`的值只能在特定的上下文中被修改，而其他地方只能读取它的值。\n     */</span>\n    <span class=\"token function\">asReadonly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Signal<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们可以通过调用<code>signal</code>的创建函数来创建一个可设置的<code>signal</code>实例。<br>在 Angular 中，这个<code>signal</code>创建函数通常是指从 @angular&#x2F;core 模块中导入的 createSignal 函数。<br>通过调用这个函数，我们可以创建一个新的<code>signal</code>实例，这个<code>signal</code>实例可以用于存储和管理数据，并允许在需要时进行设置或更新。<br>这样的<code>signal</code>实例通常是可写的，我们可以使用 <code>set</code>、<code>update</code> 或 <code>mutate</code>方法来改变它的值。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">signal</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  initialValue<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span>\n  options<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>equal<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> WritableSignal<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>示例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\"><span class=\"token comment\">// 创建一个可写 signal</span>\n<span class=\"token keyword\">const</span> counter <span class=\"token operator\">=</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 为 signal 设置新的值, 完全替换当前值</span>\ncounter<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 基于当前值更新 signal 的值</span>\ncounter<span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span>currentValue <span class=\"token operator\">=></span> currentValue <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","text":"本文介绍 Angular signal库的 API 接口和一些实现细节。 signal在Angular中是一种具有明确变更语义的值。在 Angular 中，signal通过一个零参数的getter函数来表示，该函数返回当前signal的值。 在这个getter函数中会使用 SIG...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"FRONTEND","slug":"FRONTEND","count":7,"path":"api/categories/FRONTEND.json"}],"tags":[{"name":"angular","slug":"angular","count":4,"path":"api/tags/angular.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%86%99signal\"><span class=\"toc-text\">可写signal</span></a></li></ol>","author":{"name":"Kidwen","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/38277891?v=4","link":"/","description":"Frontend","socials":{"github":"https://github.com/kidwen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"angular v16 signal 介绍","uid":"a7b5aeb1d279a19d567b0b432761bc79","slug":"frontend/angular-v16","date":"2023-07-13T03:00:00.000Z","updated":"2023-07-21T08:13:54.539Z","comments":true,"path":"api/articles/frontend/angular-v16.json","keywords":null,"cover":"/images/angular-16.png","text":"2023年05月03日，angular v16 正式发布。此次更新添加了Signals作为angular新的响应单元(reactive primitive)。angular的响应式系统依赖于zone.js。但是zone.js对于模型的变更没有提供更细粒度的信息通知。zone.js...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"FRONTEND","slug":"FRONTEND","count":7,"path":"api/categories/FRONTEND.json"}],"tags":[{"name":"angular","slug":"angular","count":4,"path":"api/tags/angular.json"}],"author":{"name":"Kidwen","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/38277891?v=4","link":"/","description":"Frontend","socials":{"github":"https://github.com/kidwen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}