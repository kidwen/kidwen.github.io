{"title":"angular v16 signal api 介绍","uid":"67a0811293cd2bc9df0f8e11e20e867f","slug":"frontend/angular-signal-api","date":"2023-07-21T08:00:00.000Z","updated":"2023-07-24T02:28:59.904Z","comments":true,"path":"api/articles/frontend/angular-signal-api.json","keywords":null,"cover":"/images/angular-16.png","content":"<p>本文介绍 <code>Angular signal</code>库的 <code>API</code> 接口和一些实现细节。</p>\n<p><code>signal</code>在<code>Angular</code>中是一种具有明确变更语义的值。在 Angular 中，<code>signal</code>通过一个零参数的<code>getter</code>函数来表示，该函数返回当前<code>signal</code>的值。</p>\n<p>在这个<code>getter</code>函数中会使用 <code>SIGNAL</code> 符号进行标记，这样<code>Angular</code>框架就能够识别它是一个<code>signal</code>，并且可以应用一些内部的优化措施来提升性能。</p>\n<p><code>signal</code>是只读的，意味着我们可以获取当前<code>signal</code>的值，但不能直接修改它。我们可以观察<code>signal</code>的变化通知，以便在值发生变化时做出相应的处理。这种只读的特性使得<code>signal</code>在响应式编程中非常有用，因为它们可以用于实现数据的观察和响应。</p>\n<p>这个<code>getter</code>函数被用于获取当前<code>signal</code>的值，并在响应式编程的上下文中记录<code>signal</code>的读取操作。这个操作对于构建响应式依赖图来说非常关键。在 <code>Angular</code> 中，响应式依赖图用于追踪数据的依赖关系，当依赖的数据发生变化时，相关的部分会得到更新。这种机制使得 <code>Angular</code> 能够高效地处理数据的变化和重新渲染视图。</p>\n<p>在响应式上下文之外，我们仍然可以对<code>signal</code>进行读取操作。这使得非响应式的代码（比如现有的、来自第三方的库）可以随时读取<code>signal</code>的值，而无需了解<code>signal</code>的响应式特性。这种设计使得<code>signal</code>可以在现有的代码中轻松地使用，而不需要对现有代码做任何修改。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Signal<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">[</span><span class=\"token constant\">SIGNAL</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"可写signal\"><a href=\"#可写signal\" class=\"headerlink\" title=\"可写signal\"></a>可写<code>signal</code></h2><p>Angular signals库将提供可写<code>signal</code>的默认实现，可以通过内置的修改方法（<code>set</code>、<code>update</code>、<code>mutate</code>）进行更改：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">WritableSignal<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Signal<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">/**\n     * 我们可以直接使用设置方法（set）将`signal`的值设置为一个新的值。\n     * 一旦`signal`的值发生变化，它会自动通知所有依赖于这个`signal`的部分，从而触发相应的更新。\n     * 这种自动通知机制是响应式编程的核心，它确保了数据的一致性和同步，使得我们能够有效地处理数据的变化，并及时反映到界面上。\n     *\n     * 使用可写`signal`的 set 方法在以下情况下非常有用：\n     * 1. 当我们需要更改原始值（例如数字、字符串等）时，直接使用 set 方法可以非常方便地更新`signal`的值。\n     * 2. 当新值与旧值之间没有依赖关系时，也就是说，新值不依赖于旧值的任何信息，我们可以直接使用 set 方法替换整个数据结构。\n     */</span>\n    <span class=\"token function\">set</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/**\n     * 使用可写`signal`的 update 方法可以基于当前`signal`的值进行更新。\n     * 你可以提供一个更新函数，该函数将根据当前`signal`的值计算新的值，并将新值应用到`signal`上。\n     * 一旦`signal`的值发生变化，它会自动通知所有依赖于这个`signal`的部分，从而触发相应的更新。\n     * 使用 update 方法可以非常方便地对`signal`的值进行递增、递减或应用其他自定义的计算逻辑。\n     * 这使得数据的更新更加灵活和自由，同时保持了响应式编程的特性，确保数据的一致性和同步。\n     * \n     * 1. 当我们需要设置一个新值，而这个新值依赖于旧值时，可以使用 update 方法。\n     * 例如，我们要对一个不可变的数据结构进行更新，可以通过提供一个更新函数来计算新的数据结构，并将其应用到`signal`上。\n     * 2. 在不可变的数据结构中，我们不能直接修改已有的数据，而是需要创建一个新的数据结构来表示修改后的结果。\n     * 使用 update 方法可以方便地进行这样的操作，而不需要手动处理数据的复制和更新。\n     */</span>\n    <span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">updateFn</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/**\n     * 使用可写`signal`的 mutate 方法可以直接在当前值上进行修改。\n     * 你可以提供一个修改函数，该函数将在当前值上进行原地修改，并将修改后的值应用到`signal`上。\n     * 一旦`signal`的值发生变化，它会自动通知所有依赖于这个`signal`的部分，从而触发相应的更新。\n     * 使用 mutate 方法可以方便地进行直接修改数据的操作，而不需要创建新的数据结构。\n     * 这对于某些特定的场景和数据结构的处理非常有帮助。\n     * 需要注意的是，这种方法是在原地修改数据，因此在使用时需要谨慎，确保不会导致数据的不一致或错误。\n     * \n     * 使用可写`signal`的 mutate 方法在以下情况下非常有用：\n     * 1. 当我们需要对`signal`的值进行内部修改，而不改变`signal`本身的引用（即身份）时，可以使用 mutate 方法。\n     * 例如，我们可以通过提供一个修改函数，在`signal`中存储的数组上添加新元素，而不需要创建一个新的数组，从而保持`signal`的引用不变。\n     * 1. mutate 方法可以用于原地修改`signal`的值，而不需要重新分配内存或创建新的数据结构，\n     * 这在一些性能敏感的情况下很有用。\n     */</span>\n    <span class=\"token function\">mutate</span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">mutatorFn</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/**\n     * 我们可以通过某种方式从一个可写`signal`派生出一个新的`signal`，这个新`signal`是只读的，即不能修改它的值。\n     * 这个只读`signal`仍然可以访问原始可写`signal`的值，但不允许对原始`signal`的值进行修改。\n     * \n     * 这种操作在某些场景下很有用，比如我们希望将一个可写`signal`暴露给其他部分，但不希望其他部分对该`signal`进行修改，以保持数据的一致性和可控性。\n     * 通过返回一个非可写`signal`，我们可以确保原始`signal`的值只能在特定的上下文中被修改，而其他地方只能读取它的值。\n     */</span>\n    <span class=\"token function\">asReadonly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Signal<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们可以通过调用<code>signal</code>的创建函数来创建一个可设置的<code>signal</code>实例。<br>在 Angular 中，这个<code>signal</code>创建函数通常是指从 @angular&#x2F;core 模块中导入的 createSignal 函数。<br>通过调用这个函数，我们可以创建一个新的<code>signal</code>实例，这个<code>signal</code>实例可以用于存储和管理数据，并允许在需要时进行设置或更新。<br>这样的<code>signal</code>实例通常是可写的，我们可以使用 <code>set</code>、<code>update</code> 或 <code>mutate</code>方法来改变它的值。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">signal</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  initialValue<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span>\n  options<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>equal<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> WritableSignal<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>示例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\"><span class=\"token comment\">// 创建一个可写 signal</span>\n<span class=\"token keyword\">const</span> counter <span class=\"token operator\">=</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 为 signal 设置新的值, 完全替换当前值</span>\ncounter<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 基于当前值更新 signal 的值</span>\ncounter<span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span>currentValue <span class=\"token operator\">=></span> currentValue <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在 Angular 中，<code>Signal</code>和<code>WritableSignal</code>的接口命名通常遵循以下命名约定：</p>\n<p>当前提案中使用 Signal 作为主要接口的命名，并且这个接口表示一个只读的值随时间变化。为 Signal 这个主要接口选择这个名称是因为其简短、易于发现，并且预计它会成为最常见的被导入和使用的接口。</p>\n<p>另一方面，<code>WritableSignal</code> 是一个相对特殊化的接口，它在名称中添加了 <code>writable</code> 表示在这些类型的<code>signal</code>上允许进行额外的操作，即允许对其值进行修改。</p>\n<p>这样的命名方案旨在提供清晰简洁的名称，使得开发者在使用该库时能够轻松区分只读<code>signal</code>和可写<code>signal</code>，并根据实际需求选择正确的接口。</p>\n<h3 id=\"Equality\"><a href=\"#Equality\" class=\"headerlink\" title=\"Equality\"></a>Equality</h3><p>It is possible to, optionally, specify an equality comparator function. If the equality function determines that 2 values are equal, and if not equal, writable signal implementation will:</p>\n<ul>\n<li>block update of signal’s value</li>\n<li>skip change propagation.</li>\n</ul>\n<p>默认情况下，当<code>signal</code>中的值为原始值（例如数字、字符串等）时，使用 <code>===</code> 来比较它们的相等性。如果新旧值相等，变更通知将被跳过，不会触发变更事件。但是，当<code>signal</code>中的值为对象或数组时，相等比较器函数将始终视它们为不相等，即使它们的内容相同也不会被认为是相等的。</p>\n<p>这样的默认行为允许<code>signal</code>存储和传播非原始值（例如对象、数组），即使对象或数组的内容没有实际改变，只要其引用发生了变化，<code>signal</code>仍然可以触发变更通知。这样可以确保<code>signal</code>对非原始值的处理更加灵活和准确，而不仅仅依赖于值的内容是否发生变化。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> todos <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">signal</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Todo<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">&#123;</span>todo<span class=\"token operator\">:</span> <span class=\"token string\">'Open RFC'</span><span class=\"token punctuation\">,</span> done<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 我们可以更新列表，即使没有使用不可变数据，仍然触发变更通知。</span>\ntodos<span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span>todosList <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n    todosList<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span>todo<span class=\"token operator\">:</span> <span class=\"token string\">'Respond to RFC comments'</span><span class=\"token punctuation\">,</span> done<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> todoList<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><code>signal</code>概念的实现并不限于特定的方式。无论是Angular还是第三方库，都可以创建定制的<code>signal</code>实现，只要它们保持了与<code>signal</code>相关的底层契约（也就是接口和功能）不变即可。</p>\n<p>这种灵活性允许开发者根据自己的需求和场景来创建符合特定要求的<code>signal</code>实现。无论使用哪种实现方式，只要它们遵循<code>signal</code>的基本规则和契约，就能在Angular应用中实现类似的<code>signal</code>功能，并在需要时触发变更通知和响应式处理。这样的设计有助于推动模块化和可扩展性，让开发者能够更好地适应不同的业务需求。</p>\n<h3 id=\"set-是signal的基本操作，-update-是一个方便的方法。\"><a href=\"#set-是signal的基本操作，-update-是一个方便的方法。\" class=\"headerlink\" title=\".set 是signal的基本操作，.update 是一个方便的方法。\"></a><code>.set</code> 是<code>signal</code>的基本操作，<code>.update</code> 是一个方便的方法。</h3><p>虽然<code>signal</code>的 API 表面上提供了三种不同的方法来改变<code>signal</code>的值，但实际上，<code>.set(newValue)</code> 是库中唯一需要的基本操作。这是设置<code>signal</code>值的主要方法，其他两种方法<code>.update</code> 和 <code>.mutate</code> 只是提供了更方便的方式来进行<code>signal</code>值的更新，其功能可以通过调用 <code>.set</code> 来实现。</p>\n<p>使用 <code>.update</code> 方法可以根据当前<code>signal</code>的值计算新的值并进行更新，而使用 <code>.mutate</code> 方法可以在当前值上进行原地修改。但这两种方法在功能上可以等效为使用 <code>.set</code> 方法，因为它们都是对<code>signal</code>的值进行更新。因此，<code>.set</code> 是<code>signal</code>库中唯一需要的基本操作，而其他两种方法只是在使用上更加便利和语法上更加简洁的方式。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\"><span class=\"token comment\">// 创建一个可写 `signal`</span>\n<span class=\"token keyword\">const</span> counter <span class=\"token operator\">=</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 基于当前值更新 `signal` 的值</span>\ncounter<span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span>c <span class=\"token operator\">=></span> c <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 相同功能可以不使用 .update, 而是 .set</span>\ncounter<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>尽管所有的操作都可以仅通过使用 <code>.set</code> 来完成，但在某些特定的使用情况下，使用 <code>.update</code> 会更加方便和简洁，因此它被添加到了公共 API 中。</p>\n<p>虽然 <code>.set</code> 是信号的基本操作，允许直接设置信号的值，但在某些场景中，使用 <code>.update</code> 更加方便，因为它允许我们提供一个更新函数，根据当前信号的值计算新的值并进行更新，从而使代码更加简洁和灵活。因此，尽管 <code>.set</code> 是必需的基本操作，<code>.update</code> 作为一种方便的操作也被引入到了公共 API 表面，以满足不同的使用需求。</p>\n<h3 id=\"mutate-用于就地更改值\"><a href=\"#mutate-用于就地更改值\" class=\"headerlink\" title=\".mutate 用于就地更改值\"></a>.mutate 用于就地更改值</h3><p><code>.mutate</code> 方法的用途。<code>.mutate</code> 方法允许我们通过直接在信号值上进行原地修改来改变信号的值。这种操作主要适用于信号持有的值是非原始 JavaScript 值，例如数组或对象。</p>\n<p>例如，我们可以使用 <code>.mutate</code> 方法来对一个数组信号进行原地修改，比如向数组中添加元素、删除元素或对元素进行修改，而不是通过创建新的数组来实现。这样的原地修改在某些情况下可以提供更高的性能和效率，尤其是当信号值较大或需要频繁修改时。</p>\n<p>总的来说，<code>.mutate</code> 方法是一种用于在信号中原地修改值的方便方法，适用于非原始值的信号，如数组或对象。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> todos <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">signal</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Todo<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">&#123;</span>todo<span class=\"token operator\">:</span> <span class=\"token string\">'Open RFC'</span><span class=\"token punctuation\">,</span> done<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 我们可以更新列表，即使没有使用不可变数据，仍然触发变更通知。</span>\ntodos<span class=\"token punctuation\">.</span><span class=\"token function\">mutate</span><span class=\"token punctuation\">(</span>todosList <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n    todosList<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span>todo<span class=\"token operator\">:</span> <span class=\"token string\">'Respond to RFC comments'</span><span class=\"token punctuation\">,</span> done<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><code>.mutate</code> 方法的特点。无论信号使用何种自定义的相等性检查，<code>.mutate</code> 方法始终会触发变更通知。这意味着，即使修改了信号的值但未触发自定义相等性检查，仍会发送变更通知，确保其他依赖于信号的部分能够得到更新。</p>\n<p>通过使用 <code>.mutate</code> 方法和默认的相等比较器函数，信号库可以同时处理可变和不可变的数据。这使得信号在处理数据时更加灵活，无需局限于特定的数据处理方式。这样的设计决策有助于保持灵活性，让开发者可以根据具体场景选择最合适的数据处理方式，无论是可变数据还是不可变数据。</p>\n<h3 id=\"读-写分离\"><a href=\"#读-写分离\" class=\"headerlink\" title=\"读&#x2F;写分离\"></a>读&#x2F;写分离</h3>","text":"本文介绍 Angular signal库的 API 接口和一些实现细节。 signal在Angular中是一种具有明确变更语义的值。在 Angular 中，signal通过一个零参数的getter函数来表示，该函数返回当前signal的值。 在这个getter函数中会使用 SIG...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"FRONTEND","slug":"FRONTEND","count":7,"path":"api/categories/FRONTEND.json"}],"tags":[{"name":"angular","slug":"angular","count":4,"path":"api/tags/angular.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%86%99signal\"><span class=\"toc-text\">可写signal</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Equality\"><span class=\"toc-text\">Equality</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#set-%E6%98%AFsignal%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%8C-update-%E6%98%AF%E4%B8%80%E4%B8%AA%E6%96%B9%E4%BE%BF%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82\"><span class=\"toc-text\">.set 是signal的基本操作，.update 是一个方便的方法。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#mutate-%E7%94%A8%E4%BA%8E%E5%B0%B1%E5%9C%B0%E6%9B%B4%E6%94%B9%E5%80%BC\"><span class=\"toc-text\">.mutate 用于就地更改值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%BB-%E5%86%99%E5%88%86%E7%A6%BB\"><span class=\"toc-text\">读&#x2F;写分离</span></a></li></ol></li></ol>","author":{"name":"Kidwen","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/38277891?v=4","link":"/","description":"Frontend","socials":{"github":"https://github.com/kidwen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"angular v16 signal 介绍","uid":"a7b5aeb1d279a19d567b0b432761bc79","slug":"frontend/angular-v16","date":"2023-07-13T03:00:00.000Z","updated":"2023-07-21T08:13:54.539Z","comments":true,"path":"api/articles/frontend/angular-v16.json","keywords":null,"cover":"/images/angular-16.png","text":"2023年05月03日，angular v16 正式发布。此次更新添加了Signals作为angular新的响应单元(reactive primitive)。angular的响应式系统依赖于zone.js。但是zone.js对于模型的变更没有提供更细粒度的信息通知。zone.js...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"FRONTEND","slug":"FRONTEND","count":7,"path":"api/categories/FRONTEND.json"}],"tags":[{"name":"angular","slug":"angular","count":4,"path":"api/tags/angular.json"}],"author":{"name":"Kidwen","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/38277891?v=4","link":"/","description":"Frontend","socials":{"github":"https://github.com/kidwen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}