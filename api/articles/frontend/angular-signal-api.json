{"title":"angular v16 signal api 介绍","uid":"67a0811293cd2bc9df0f8e11e20e867f","slug":"frontend/angular-signal-api","date":"2023-07-21T08:00:00.000Z","updated":"2023-08-03T05:38:09.338Z","comments":true,"path":"api/articles/frontend/angular-signal-api.json","keywords":null,"cover":"/images/angular-signal-api.webp","content":"<p>本文介绍 <code>Angular signal</code>库的 <code>API</code> 接口和一些实现细节。</p>\n<span id=\"more\"></span>\n<p><code>signal</code>在<code>Angular</code>中是一种具有明确变更语义的值。在 Angular 中，<code>signal</code>通过一个零参数的<code>getter</code>函数来表示，该函数返回当前<code>signal</code>的值。</p>\n<p>在这个<code>getter</code>函数中会使用 <code>SIGNAL</code> 符号进行标记，这样<code>Angular</code>框架就能够识别它是一个<code>signal</code>，并且可以应用一些内部的优化措施来提升性能。</p>\n<p><code>signal</code>是只读的，意味着我们可以获取当前<code>signal</code>的值，但不能直接修改它。我们可以观察<code>signal</code>的变化通知，以便在值发生变化时做出相应的处理。这种只读的特性使得<code>signal</code>在响应式编程中非常有用，因为它们可以用于实现数据的观察和响应。</p>\n<p>这个<code>getter</code>函数被用于获取当前<code>signal</code>的值，并在响应式编程的上下文中记录<code>signal</code>的读取操作。这个操作对于构建响应式依赖图来说非常关键。在 <code>Angular</code> 中，响应式依赖图用于追踪数据的依赖关系，当依赖的数据发生变化时，相关的部分会得到更新。这种机制使得 <code>Angular</code> 能够高效地处理数据的变化和重新渲染视图。</p>\n<p>在响应式上下文之外，我们仍然可以对<code>signal</code>进行读取操作。这使得非响应式的代码（比如现有的、来自第三方的库）可以随时读取<code>signal</code>的值，而无需了解<code>signal</code>的响应式特性。这种设计使得<code>signal</code>可以在现有的代码中轻松地使用，而不需要对现有代码做任何修改。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Signal&lt;T&gt; &#123;\n    (): T;\n    [SIGNAL]: unknown;\n&#125;</code></pre>\n\n<h2 id=\"Writable-signals\"><a href=\"#Writable-signals\" class=\"headerlink\" title=\"Writable signals\"></a>Writable signals</h2><p>Angular signals库将提供可写<code>signal</code>的默认实现，可以通过内置的修改方法（<code>set</code>、<code>update</code>、<code>mutate</code>）进行更改：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface WritableSignal&lt;T&gt; extends Signal&lt;T&gt; &#123;\n    &#x2F;**\n     * 我们可以直接使用设置方法（set）将&#96;signal&#96;的值设置为一个新的值。\n     * 当&#96;signal&#96;的值发生变化，它会自动通知所有依赖于这个&#96;signal&#96;的部分，从而触发相应的更新。\n     * 这种自动通知机制是响应式编程的核心，它确保了数据的一致性和同步，使得我们能够有效地处理数据的变化，并及时反映到界面上。\n     *\n     * 使用可写&#96;signal&#96;的 set 方法在以下情况下非常有用：\n     * 1. 当我们需要更改原始值（例如数字、字符串等）时，直接使用 set 方法可以非常方便地更新&#96;signal&#96;的值。\n     * 2. 当新值与旧值之间没有依赖关系时，也就是说，新值不依赖于旧值的任何信息，我们可以直接使用 set 方法替换整个数据结构。\n     *&#x2F;\n    set(value: T): void;\n\n    &#x2F;**\n     * 使用可写&#96;signal&#96;的 update 方法可以基于当前&#96;signal&#96;的值进行更新。\n     * 你可以提供一个更新函数，该函数将根据当前&#96;signal&#96;的值计算新的值，并将新值应用到&#96;signal&#96;上。\n     * 当&#96;signal&#96;的值发生变化，它会自动通知所有依赖于这个&#96;signal&#96;的部分，从而触发相应的更新。\n     * 使用 update 方法可以非常方便地对&#96;signal&#96;的值进行递增、递减或应用其他自定义的计算逻辑。\n     * 这使得数据的更新更加灵活和自由，同时保持了响应式编程的特性，确保数据的一致性和同步。\n     * \n     * 1. 当我们需要设置一个新值，而这个新值依赖于旧值时，可以使用 update 方法。\n     * 例如，我们要对一个不可变的数据结构进行更新，可以通过提供一个更新函数来计算新的数据结构，并将其应用到&#96;signal&#96;上。\n     * 2. 在不可变的数据结构中，我们不能直接修改已有的数据，而是需要创建一个新的数据结构来表示修改后的结果。\n     * 使用 update 方法可以方便地进行这样的操作，而不需要手动处理数据的复制和更新。\n     *&#x2F;\n    update(updateFn: (value: T) &#x3D;&gt; T): void;\n\n    &#x2F;**\n     * 使用可写&#96;signal&#96;的 mutate 方法可以直接在当前值上进行修改。\n     * 你可以提供一个修改函数，该函数将在当前值上进行原地修改，并将修改后的值应用到&#96;signal&#96;上。\n     * 当&#96;signal&#96;的值发生变化，它会自动通知所有依赖于这个&#96;signal&#96;的部分，从而触发相应的更新。\n     * 使用 mutate 方法可以方便地进行直接修改数据的操作，而不需要创建新的数据结构。\n     * 这对于某些特定的场景和数据结构的处理非常有帮助。\n     * 需要注意的是，这种方法是在原地修改数据，因此在使用时需要谨慎，确保不会导致数据的不一致或错误。\n     * \n     * 使用可写&#96;signal&#96;的 mutate 方法在以下情况下非常有用：\n     * 1. 当我们需要对&#96;signal&#96;的值进行内部修改，而不改变&#96;signal&#96;本身的引用（即身份）时，可以使用 mutate 方法。\n     * 例如，我们可以通过提供一个修改函数，在&#96;signal&#96;中存储的数组上添加新元素，而不需要创建一个新的数组，从而保持&#96;signal&#96;的引用不变。\n     * 1. mutate 方法可以用于原地修改&#96;signal&#96;的值，而不需要重新分配内存或创建新的数据结构，\n     * 这在一些性能敏感的情况下很有用。\n     *&#x2F;\n    mutate(mutatorFn: (value: T) &#x3D;&gt; void): void;\n\n    &#x2F;**\n     * 我们可以通过某种方式从一个可写&#96;signal&#96;派生出一个新的&#96;signal&#96;，这个新&#96;signal&#96;是只读的，即不能修改它的值。\n     * 这个只读&#96;signal&#96;仍然可以访问原始可写&#96;signal&#96;的值，但不允许对原始&#96;signal&#96;的值进行修改。\n     * \n     * 这种操作在某些场景下很有用，比如我们希望将一个可写&#96;signal&#96;暴露给其他部分，但不希望其他部分对该&#96;signal&#96;进行修改，以保持数据的一致性和可控性。\n     * 通过返回一个非可写&#96;signal&#96;，我们可以确保原始&#96;signal&#96;的值只能在特定的上下文中被修改，而其他地方只能读取它的值。\n     *&#x2F;\n    asReadonly(): Signal&lt;T&gt;;\n&#125;</code></pre>\n\n<p>我们可以通过调用<code>signal</code>的创建函数来创建一个可写<code>signal</code>实例。<br>在<code> Angular</code> 中，这个<code>signal</code>创建函数通常是指从 <code>@angular/core</code> 模块中导入的 <code>createSignal</code> 函数。<br>通过调用这个函数，我们可以创建一个新的<code>signal</code>实例，这个<code>signal</code>实例可以用于存储和管理数据，并允许在需要时进行设置或更新。<br>这样的<code>signal</code>实例通常是可写的，我们可以使用 <code>set</code>、<code>update</code> 或 <code>mutate</code>方法来改变它的值。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function signal&lt;T&gt;(\n  initialValue: T,\n  options?: &#123;equal?: (a: T, b: T) &#x3D;&gt; boolean&#125;\n): WritableSignal&lt;T&gt;;</code></pre>\n<p>示例：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 创建一个可写 signal\nconst counter &#x3D; signal(0);\n\n&#x2F;&#x2F; 为 signal 设置新的值, 完全替换当前值\ncounter.set(5);\n\n&#x2F;&#x2F; 基于当前值更新 signal 的值\ncounter.update(currentValue &#x3D;&gt; currentValue + 1);</code></pre>\n<p>在 Angular 中，<code>Signal</code>和<code>WritableSignal</code>的接口命名通常遵循以下命名约定：</p>\n<p><code>Signal</code> 作为主要接口的命名，并且这个接口表示一个只读的值随时间变化。为 <code>Signal</code> 这个主要接口选择这个名称是因为其简短、易于发现，并且预计它会成为最常见的被导入和使用的接口。</p>\n<p>另一方面，<code>WritableSignal</code> 是一个相对特殊化的接口，它在名称中添加了 <code>writable</code> 表示在这些类型的<code>signal</code>上允许进行额外的操作，即允许对其值进行修改。</p>\n<p>这样的命名方案旨在提供清晰简洁的名称，使得开发者在使用该库时能够轻松区分只读<code>signal</code>和可写<code>signal</code>，并根据实际需求选择正确的接口。</p>\n<h3 id=\"Equality\"><a href=\"#Equality\" class=\"headerlink\" title=\"Equality\"></a>Equality</h3><p>It is possible to, optionally, specify an equality comparator function. If the equality function determines that 2 values are equal, and if not equal, writable signal implementation will:</p>\n<ul>\n<li>block update of signal’s value</li>\n<li>skip change propagation.</li>\n</ul>\n<p>默认情况下，当<code>signal</code>中的值为原始值（例如数字、字符串等）时，使用 <code>===</code> 来比较它们的相等性。如果新旧值相等，变更通知将被跳过，不会触发变更事件。但是，当<code>signal</code>中的值为对象或数组时，相等比较器函数将始终视它们为不相等，即使它们的内容相同也不会被认为是相等的。</p>\n<p>这样的默认行为允许<code>signal</code>存储和传播非原始值（例如对象、数组），即使对象或数组的内容没有实际改变，只要其引用发生了变化，<code>signal</code>仍然可以触发变更通知。这样可以确保<code>signal</code>对非原始值的处理更加灵活和准确，而不仅仅依赖于值的内容是否发生变化。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const todos &#x3D; signal&lt;Array&lt;Todo&gt;&gt;([&#123;todo: &#39;Open RFC&#39;, done: true&#125;]);\n\n&#x2F;&#x2F; 我们可以更新列表，即使没有使用不可变数据，仍然触发变更通知。\ntodos.update(todosList &#x3D;&gt; &#123;\n    todosList.push(&#123;todo: &#39;Respond to RFC comments&#39;, done: false&#125;);\n    return todoList;\n&#125;);</code></pre>\n<p><code>signal</code>概念的实现并不限于特定的方式。无论是Angular还是第三方库，都可以创建定制的<code>signal</code>实现，只要它们保持了与<code>signal</code>相关的底层契约（也就是接口和功能）不变即可。</p>\n<p>这种灵活性允许开发者根据自己的需求和场景来创建符合特定要求的<code>signal</code>实现。无论使用哪种实现方式，只要它们遵循<code>signal</code>的基本规则和契约，就能在Angular应用中实现类似的<code>signal</code>功能，并在需要时触发变更通知和响应式处理。这样的设计有助于推动模块化和可扩展性，让开发者能够更好地适应不同的业务需求。</p>\n<h3 id=\"set-是signal的基本操作，-update-是一个方便的方法。\"><a href=\"#set-是signal的基本操作，-update-是一个方便的方法。\" class=\"headerlink\" title=\".set 是signal的基本操作，.update 是一个方便的方法。\"></a><code>.set</code> 是<code>signal</code>的基本操作，<code>.update</code> 是一个方便的方法。</h3><p>虽然<code>signal</code>的 API 表面上提供了三种不同的方法来改变<code>signal</code>的值，但实际上，<code>.set(newValue)</code> 是库中唯一需要的基本操作。这是设置<code>signal</code>值的主要方法，其他两种方法<code>.update</code> 和 <code>.mutate</code> 只是提供了更方便的方式来进行<code>signal</code>值的更新，其功能可以通过调用 <code>.set</code> 来实现。</p>\n<p>使用 <code>.update</code> 方法可以根据当前<code>signal</code>的值计算新的值并进行更新，而使用 <code>.mutate</code> 方法可以在当前值上进行原地修改。但这两种方法在功能上可以等效为使用 <code>.set</code> 方法，因为它们都是对<code>signal</code>的值进行更新。因此，<code>.set</code> 是<code>signal</code>库中唯一需要的基本操作，而其他两种方法只是在使用上更加便利和语法上更加简洁的方式。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 创建一个可写 &#96;signal&#96;\nconst counter &#x3D; signal(0);\n\n&#x2F;&#x2F; 基于当前值更新 &#96;signal&#96; 的值\ncounter.update(c &#x3D;&gt; c + 1);\n\n&#x2F;&#x2F; 相同功能可以不使用 .update, 而是 .set\ncounter.set(counter.get() + 1);</code></pre>\n<p>尽管所有的操作都可以仅通过使用 <code>.set</code> 来完成，但在某些特定的使用情况下，使用 <code>.update</code> 会更加方便和简洁，因此它被添加到了公共 API 中。</p>\n<p>虽然 <code>.set</code> 是<code>signal</code>的基本操作，允许直接设置<code>signal</code>的值，但在某些场景中，使用 <code>.update</code> 更加方便，因为它允许我们提供一个更新函数，根据当前<code>signal</code>的值计算新的值并进行更新，从而使代码更加简洁和灵活。因此，尽管 <code>.set</code> 是必需的基本操作，<code>.update</code> 作为一种方便的操作也被引入到了公共 API 表面，以满足不同的使用需求。</p>\n<h3 id=\"mutate-用于就地更改值\"><a href=\"#mutate-用于就地更改值\" class=\"headerlink\" title=\".mutate 用于就地更改值\"></a>.mutate 用于就地更改值</h3><p><code>.mutate</code> 方法的用途。<code>.mutate</code> 方法允许我们通过直接在<code>signal</code>值上进行原地修改来改变<code>signal</code>的值。这种操作主要适用于<code>signal</code>持有的值是非原始 JavaScript 值，例如数组或对象。</p>\n<p>例如，我们可以使用 <code>.mutate</code> 方法来对一个数组<code>signal</code>进行原地修改，比如向数组中添加元素、删除元素或对元素进行修改，而不是通过创建新的数组来实现。这样的原地修改在某些情况下可以提供更高的性能和效率，尤其是当<code>signal</code>值较大或需要频繁修改时。</p>\n<p>总的来说，<code>.mutate</code> 方法是一种用于在<code>signal</code>中原地修改值的方便方法，适用于非原始值的<code>signal</code>，如数组或对象。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const todos &#x3D; signal&lt;Todo[]&gt;([&#123;todo: &#39;Open RFC&#39;, done: true&#125;]);\n\n&#x2F;&#x2F; 我们可以更新列表，即使没有使用不可变数据，仍然触发变更通知。\ntodos.mutate(todosList &#x3D;&gt; &#123;\n    todosList.push(&#123;todo: &#39;Respond to RFC comments&#39;, done: false&#125;);\n&#125;);</code></pre>\n<p><code>.mutate</code> 方法的特点。无论<code>signal</code>使用何种自定义的相等性检查，<code>.mutate</code> 方法始终会触发变更通知。这意味着，即使修改了<code>signal</code>的值但未触发自定义相等性检查，仍会发送变更通知，确保其他依赖于<code>signal</code>的部分能够得到更新。</p>\n<p>通过使用 <code>.mutate</code> 方法和默认的相等比较器函数，<code>signal</code>库可以同时处理可变和不可变的数据。这使得<code>signal</code>在处理数据时更加灵活，无需局限于特定的数据处理方式。这样的设计决策有助于保持灵活性，让开发者可以根据具体场景选择最合适的数据处理方式，无论是可变数据还是不可变数据。</p>\n<h3 id=\"读-写分离\"><a href=\"#读-写分离\" class=\"headerlink\" title=\"读&#x2F;写分离\"></a>读&#x2F;写分离</h3><p><code>signal</code>库的设计选择。在该库中，主要的响应式基元是 Signal<T> 类型，而且它是只读的。这意味着可以使用<code>signal</code>传播响应式的值给其他组件或订阅者，但是这些消费者不能直接修改<code>signal</code>的值。</p>\n<p>这样的设计可以带来一些好处。首先，它确保了响应式数据的单向流动，防止不必要的数据修改。其次，它增强了代码的可维护性和可预测性，因为只有特定的组件或服务可以修改<code>signal</code>的值，其他消费者只能读取数据。这种封装性使得代码更加健壮，并减少了潜在的副作用和数据冲突。</p>\n<p>通过将<code>signal</code>的读写能力分开，<code>signal</code>库鼓励在应用程序中采用良好的数据流架构模式。具体来说，<code>signal</code>库通过将<code>signal</code>设计为只读的 <code>Signal&lt;T&gt;</code> 类型和可写的 <code>WritableSignal&lt;T&gt;</code> 类型，使得对状态的修改必须通过持有 <code>WritableSignal</code> 的所有者来进行，而不能在应用程序的任意地方进行修改。</p>\n<h3 id=\"Getter-方法\"><a href=\"#Getter-方法\" class=\"headerlink\" title=\"Getter 方法\"></a>Getter 方法</h3><p>在 <code>Angular</code> 中选择的实现中，<code>signal</code>是通过 <code>getter</code> 函数来表示的。以下是使用这种 API 的一些优点：</p>\n<ul>\n<li>它是内置的 <code>JavaScript</code> 结构，这使得<code>signal</code>的读取在 <code>TypeScript</code> 代码和模板表达式之间保持一致。</li>\n<li>它明确指示了<code>signal</code>的主要操作是读取（<code>read</code>）。</li>\n<li>它清楚地表明了不仅仅是简单的属性访问在发生。</li>\n<li>它的语法非常轻量级，因为读取<code>signal</code>是一个非常常见的操作。</li>\n</ul>\n<h4 id=\"getter-函数的缺点\"><a href=\"#getter-函数的缺点\" class=\"headerlink\" title=\"getter 函数的缺点\"></a>getter 函数的缺点</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>模板中的函数调用</p></blockquote>\n<p>在 <code>Angular</code> 中，模板中的函数调用会触发组件的变更检测机制，而这个机制在频繁调用时可能会导致性能问题。因此，开发者通常会避免在模板中调用复杂或计算密集型的函数。</p>\n<p>但是，<code>signal</code>的 <code>getter</code> 函数是高效的访问器，它们执行的计算工作非常少。<code>signal</code>的 <code>getter</code> 函数通常只是返回<code>signal</code>的当前值，并不包含复杂的逻辑。因此，频繁调用<code>signal</code>的 <code>getter</code> 函数并不会引起性能问题，开发者无需担心在模板中使用<code>signal</code>的 <code>getter</code> 函数。</p>\n<p>这样的设计使得<code>signal</code>在 <code>Angular</code> 中成为一种高效和方便的方式来处理数据和状态，并可以在模板中直接使用，而不会导致性能上的问题。</p>\n<h4 id=\"与类型缩窄的交互\"><a href=\"#与类型缩窄的交互\" class=\"headerlink\" title=\"与类型缩窄的交互\"></a>与类型缩窄的交互</h4><p>在代码中</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">if (user.name()) &#123;\n  console.log(user.name().first); &#x2F;&#x2F; 由于ts不能知道每次方法调用是否会返回相同的值所以此处会报错\n&#125;</code></pre>\n<p>可以如下解决</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const name &#x3D; user.name();\nif (name) &#123;\n  console.log(name.first);\n&#125;</code></pre>\n<p>但是在模版中没有办法声明中间变量（可以自动创建此类变量来解决此类问题）。</p>\n<h2 id=\"Computed-signals\"><a href=\"#Computed-signals\" class=\"headerlink\" title=\"Computed signals\"></a>Computed signals</h2><p>类似于 vue 计算属性</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const counter &#x3D; signal(0);\n\nconst isEven &#x3D; computed(() &#x3D;&gt; counter() % 2 &#x3D;&#x3D;&#x3D; 0);\n\nconst color &#x3D; computed(() &#x3D;&gt; isEven() ? &#39;red&#39; : &#39;blue&#39;);</code></pre>\n<p>签名类型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function computed&lt;T&gt;(\n  computation: () &#x3D;&gt; T,\n  options?: &#123;equal?: (a: T, b: T) &#x3D;&gt; boolean&#125;\n): Signal&lt;T&gt;;</code></pre>\n\n<p>与可写<code>signal</code>类似，计算<code>signal</code>可以（可选）指定等式函数。当提供时，如果确定两个值相等，则相等函数可以停止更深层次依赖链的重新计算。示例（默认相等）：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const counter &#x3D; signal(0);\n\nconst isEven &#x3D; computed(() &#x3D;&gt; counter() % 2 &#x3D;&#x3D;&#x3D; 0);\n\nconst color &#x3D; computed(() &#x3D;&gt; isEven() ? &#39;red&#39; : &#39;blue&#39;);\n\n&#x2F;&#x2F; 提供一个不同的复数值给 counter 意味着：\n&#x2F;&#x2F; - isEven 重新计算（因为依赖值发生变化）\n&#x2F;&#x2F; - color 不需要重新计算（因为isEvent()值没有发生变化）\ncounter.set(2);</code></pre>\n\n<p><code>signal</code>在计算功能上所做的算法选择，并提供了这种实现的一些强大保证：</p>\n<ul>\n<li>延迟执行：计算函数只有在有人读取其值时才会被执行。这样可以避免不必要的计算开销，只有在需要计算值时才进行实际的计算操作。</li>\n<li>自动清理：一旦计算<code>signal</code>的引用超出作用域，它会自动成为垃圾回收的对象。这意味着不需要开发者显式地进行计算的清理操作，<code>signal</code>库会自动处理资源的释放。</li>\n<li>无故障执行：计算保证在依赖项发生变化时，只会执行最少次数的计算。这样可以避免计算过程中使用过时或中间状态的依赖值，从而确保计算的准确性和一致性。这种无故障执行机制也免除了需要显式执行“事务”或“批处理”操作的需求。</li>\n</ul>\n<p>在条件计算中，计算型<code>signal</code>可能根据读取的其他<code>signal</code>的不同值进行不同的计算。当计算型<code>signal</code>的计算过程中读取了其他<code>signal</code>时，它会将这些<code>signal</code>添加到自己的依赖集合中。如果后续这些依赖<code>signal</code>的值发生了变化，计算型<code>signal</code>会相应地知道自己需要重新计算，以确保计算的正确性。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 如果 &#96;showName&#96; &#96;signal&#96;发生变化，问候语将始终被重新计算，但如果 &#96;showName&#96; 为 &#96;false&#96;，则名称&#96;signal&#96;不是问候语的依赖项，也不会导致其重新计算。\nconst greeting &#x3D; computed(() &#x3D;&gt; showName() ? &#96;Hello, $&#123;name()&#125;!&#96; : &#39;Hello!&#39;);</code></pre>\n\n<h2 id=\"Effects\"><a href=\"#Effects\" class=\"headerlink\" title=\"Effects\"></a>Effects</h2><p><code>Effect</code> 是一种带有副作用的操作，它会读取一个或多个<code>signal</code>的值，并在任何这些<code>signal</code>发生变化时自动调度重新运行该操作。</p>\n<p>当一个 <code>effect</code> 被创建时，它会读取指定的<code>signal</code>的值，并在这些<code>signal</code>的值发生变化时自动触发重新运行。这样的设计使得 <code>effect</code> 能够对<code>signal</code>的变化作出相应的反应，并执行相应的副作用操作。</p>\n<p>例如，在一个 <code>effect</code> 中可以监听用户输入的变化<code>signal</code>和网络请求结果<code>signal</code>，一旦这些<code>signal</code>的值发生变化，<code>effect</code> 就会自动调度重新运行，执行与之相关的副作用操作，如更新界面或发起新的网络请求。</p>\n<p>一个 <code>effect</code> 的基本 API 具有以下签名：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function effect(\n  effectFn: (onCleanup: (fn: () &#x3D;&gt; void) &#x3D;&gt; void) &#x3D;&gt; void,\n  options?: CreateEffectOptions\n): EffectRef;</code></pre>\n<p>使用：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const firstName &#x3D; signal(&#39;John&#39;);\nconst lastName  &#x3D; signal(&#39;Doe&#39;);\n\n&#x2F;&#x2F; 这个 effect 会打印两个名字，也会在两个 signal 发生变化时自动打印\neffect(() &#x3D;&gt; console.log(firstName(), lastName()));</code></pre>\n<p>Effects 在应用程序中有多种用途，包括但不限于：</p>\n<ul>\n<li>同步多个独立模型之间的数据：当应用程序中存在多个独立的数据模型时，可能需要在它们之间保持数据同步。通过创建适当的<code>effect</code>，可以监听这些模型的变化并在数据发生变化时进行同步操作，从而确保各个模型之间的数据始终保持一致。</li>\n<li>触发网络请求：在应用程序中，常常需要根据用户的交互或其他条件触发网络请求，从而获取或更新数据。通过创建一个监听<code>signal</code>变化的 <code>effect</code>，可以在<code>signal</code>满足特定条件时自动发起网络请求，实现数据的获取和更新。</li>\n<li>执行渲染操作：在应用程序中，当数据发生变化时，需要将这些变化反映在界面上，以更新用户所见的内容。通过创建监听<code>signal</code>变化的 <code>effect</code>，可以在数据发生变化时自动执行渲染操作，更新界面，从而实现反应式的用户界面。</li>\n<li>除了上述的用例，<code>Effect</code> 还可以用于处理其他类型的副作用操作，如日志记录、权限控制、动画触发等。通过将这些副作用操作封装在 <code>effect</code> 中，可以实现代码的模块化和可维护性，并确保副作用操作的执行时机和正确性。</li>\n</ul>\n<p><code>Effect</code> 函数可以选择性地注册一个清理函数。如果注册了清理函数，在下次 <code>effect</code> 运行之前，清理函数将被执行。清理函数可以用于“取消”之前的 <code>effect</code> 运行可能已经开始的任何工作。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">effect((onCleanup) &#x3D;&gt; &#123;\n    const countValue &#x3D; this.count();\n\n    let secsFromChange &#x3D; 0;\n    const id &#x3D; setInterval(() &#x3D;&gt; &#123;\n      console.log(\n        &#96;$&#123;countValue&#125; had its value unchanged for $&#123;++secsFromChange&#125; seconds&#96;\n      );\n    &#125;, 1000);\n\n    onCleanup(() &#x3D;&gt; &#123;\n      console.log(&#39;Clearing and re-scheduling effect&#39;);\n      clearInterval(id);\n    &#125;);\n&#125;);</code></pre>\n\n<h3 id=\"effects-调度时机\"><a href=\"#effects-调度时机\" class=\"headerlink\" title=\"effects 调度时机\"></a>effects 调度时机</h3><p>在 Angular Signals <code>中，effect</code> 必须在更改<code>signal</code>的操作完成后执行。</p>\n<p>考虑到 <code>effect</code> 的多种用例，存在各种可能的执行时间。因此，实际的 <code>effect</code> 执行时间不能保证，<code>Angular</code> 可能选择不同的策略。应用程序开发者不应依赖于任何观察到的执行时间。唯一可以保证的是：</p>\n<ol>\n<li><code>effect</code> 将至少执行一次；</li>\n<li><code>effect</code> 将在未来某个时刻响应其依赖项的变化而执行；</li>\n<li><code>effect</code> 将最小化执行次数：如果一个 <code>effect</code> 依赖于多个<code>signal</code>，并且其中几个<code>signal</code>同时发生变化，只会调度一次 <code>effect</code> 执行。</li>\n</ol>\n<p><code>effect</code> 执行的不确定性和最小化执行次数的保证。由于 <code>effect</code> 可能用于各种不同的场景，其执行时间可能会有很大的变化。<code>Angular</code> 并不保证 <code>effect</code> 的执行时间，可能会根据不同的情况选择不同的执行策略。</p>\n<p>虽然 <code>effect</code> 的执行时间不确定，但是 <code>Angular</code> 保证了上述的三个行为：<code>effect</code> 将至少执行一次，将在未来某个时刻响应其依赖项的变化而执行，并且在多个依赖项同时变化时最小化执行次数，只调度一次 <code>effect</code> 执行。这些保证使得 <code>effect</code> 的行为在合理范围内可预测，并且有助于提高应用程序的性能和可维护性。</p>\n<h3 id=\"停止-effects\"><a href=\"#停止-effects\" class=\"headerlink\" title=\"停止 effects\"></a>停止 effects</h3><p>Effect 在被创建后，会根据其依赖项的变化被自动调度运行，以响应数据的变化。这使得 <code>effect</code> 始终保持活动状态，并随时准备处理数据的变化。然而，这种“无限”生命周期并不是我们所期望的，因为 <code>effect</code> 应该在合适的时候进行关闭，以避免不必要的计算和资源浪费。</p>\n<p>为了解决这个问题，<code>Angular</code> 提供了一种机制来管理 <code>effect</code> 的生命周期，并在适当的时候关闭它们。通常情况下，<code>effect</code> 会在 Angular 组件或服务的生命周期结束时自动关闭。例如，当一个组件被销毁时，与该组件相关的 <code>effect</code> 也会被关闭。这样，我们可以确保在不再需要 <code>effect</code> 时，它们会被及时关闭，避免了不必要的计算和资源占用。</p>\n<p><code>Angular</code> 的 <code>effect</code> 生命周期与组件或服务的销毁相关联。当一个组件或服务被销毁时，与之相关的 <code>effect</code> 也会被关闭，以确保它们不再执行任何副作用操作。</p>\n<p>在 <code>Angular</code> 中，组件和服务通常都会实现 <code>OnDestroy</code> 接口，该接口包含一个 <code>ngOnDestroy()</code> 方法，用于在组件或服务被销毁时进行一些清理操作。<code>effect</code> 会尝试注入当前组件或服务的 DestroyRef 实例，并在 <code>ngOnDestroy()</code> 方法中注册其停止函数。</p>\n<p>通过在 <code>ngOnDestroy()</code> 方法中注册 <code>effect</code> 的停止函数，我们可以确保 <code>effect</code> 在组件或服务被销毁时正确地进行关闭和清理。这样的设计使得 <code>effect</code> 能够与组件或服务的生命周期保持一致，并在合适的时候自动关闭，避免了可能出现的内存泄漏和资源浪费。</p>\n<p>对于需要更多对生命周期范围控制的情况，可以选择性地在创建 <code>effect</code> 时传递 <code>manualCleanup</code> 选项：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 如果设置了此选项，即使创建它的组件&#x2F;指令被销毁，效果也不会自动销毁。\neffect(() &#x3D;&gt; &#123;...&#125;, &#123;manualCleanup?: boolean&#125;);</code></pre>\n<p>可以使用效果创建函数返回的 <code>EffectRef</code> 实例显式停止&#x2F;销毁效果：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 创建 effect 并记录 effectRef\nconst effectRef &#x3D; effect(() &#x3D;&gt; &#123;...&#125;);\n\n&#x2F;&#x2F; 显式停止&#x2F;销毁此 effect\neffectRef.destroy();</code></pre>\n\n<h3 id=\"Effects-写入-signals\"><a href=\"#Effects-写入-signals\" class=\"headerlink\" title=\"Effects 写入 signals\"></a>Effects 写入 signals</h3><p>不允许从 effect 中直接写入<code>signal</code>。<code>Effect</code> 函数用于处理副作用操作和响应式数据流的处理，其主要目的是读取<code>signal</code>并触发副作用操作，而不是用于写入<code>signal</code>的值。</p>\n<p>直接从 <code>effect</code> 中写入<code>signal</code>可能导致数据流的不稳定和难以跟踪的问题。例如，如果一个 <code>effect</code> 写入了一个<code>signal</code>的值，而该<code>signal</code>又被其他 <code>effect</code> 读取，可能会导致循环依赖和无限循环的问题。这样的数据流是难以理解和调试的，可能导致应用程序的不稳定性和性能问题。</p>\n<p>为了保持数据流的可靠性和可维护性，<code>Angular</code> 的设计决策是阻止在 <code>effect</code> 中直接写入<code>signal</code>。如果开发者尝试在 <code>effect</code> 中写入<code>signal</code>，<code>Angular</code> 将报告错误并阻止这样的操作。</p>\n<p>这种默认表现可以被配置项的<code>allowSignalWrites</code>覆盖。更建议使用计算<code>signal</code>。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const counter &#x3D; signal(0);\nconst isBig &#x3D; signal(false);\n\neffect(() &#x3D;&gt; &#123;\n    if (counter() &gt; 5) &#123;\n        isBig.set(true);\n    &#125; else &#123;\n        isBig.set(false);\n    &#125;      \n&#125;, &#123;allowSignalWrites: true&#125;);</code></pre>\n","feature":true,"text":"本文介绍 Angular signal库的 API 接口和一些实现细节。 signal在Angular中是一种具有明确变更语义的值。在 Angular 中，si...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"FRONTEND","slug":"FRONTEND","count":6,"path":"api/categories/FRONTEND.json"}],"tags":[{"name":"angular","slug":"angular","count":4,"path":"api/tags/angular.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Writable-signals\"><span class=\"toc-text\">Writable signals</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Equality\"><span class=\"toc-text\">Equality</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#set-%E6%98%AFsignal%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%8C-update-%E6%98%AF%E4%B8%80%E4%B8%AA%E6%96%B9%E4%BE%BF%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82\"><span class=\"toc-text\">.set 是signal的基本操作，.update 是一个方便的方法。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#mutate-%E7%94%A8%E4%BA%8E%E5%B0%B1%E5%9C%B0%E6%9B%B4%E6%94%B9%E5%80%BC\"><span class=\"toc-text\">.mutate 用于就地更改值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%BB-%E5%86%99%E5%88%86%E7%A6%BB\"><span class=\"toc-text\">读&#x2F;写分离</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Getter-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Getter 方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#getter-%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">getter 函数的缺点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%8E%E7%B1%BB%E5%9E%8B%E7%BC%A9%E7%AA%84%E7%9A%84%E4%BA%A4%E4%BA%92\"><span class=\"toc-text\">与类型缩窄的交互</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Computed-signals\"><span class=\"toc-text\">Computed signals</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Effects\"><span class=\"toc-text\">Effects</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#effects-%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">effects 调度时机</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%81%9C%E6%AD%A2-effects\"><span class=\"toc-text\">停止 effects</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Effects-%E5%86%99%E5%85%A5-signals\"><span class=\"toc-text\">Effects 写入 signals</span></a></li></ol></li></ol>","author":{"name":"Kidwen","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/38277891?v=4","link":"/","description":"Frontend","socials":{"github":"https://github.com/kidwen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"angular v16 signal 介绍","uid":"a7b5aeb1d279a19d567b0b432761bc79","slug":"frontend/angular-v16","date":"2023-07-13T03:00:00.000Z","updated":"2023-09-04T01:40:38.177Z","comments":true,"path":"api/articles/frontend/angular-v16.json","keywords":null,"cover":"/images/angular-16.png","text":"2023年05月03日，angular v16 正式发布。此次更新添加了Signals作为angular新的响应单元(reactive primitive)。a...","link":"","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"FRONTEND","slug":"FRONTEND","count":6,"path":"api/categories/FRONTEND.json"}],"tags":[{"name":"angular","slug":"angular","count":4,"path":"api/tags/angular.json"}],"author":{"name":"Kidwen","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/38277891?v=4","link":"/","description":"Frontend","socials":{"github":"https://github.com/kidwen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}