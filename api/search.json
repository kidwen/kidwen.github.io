[{"id":"26b117999aa847f72cadcbaea980685a","title":"adb","content":"这是一篇关于 ADB（Android Debug Bridge）连接的博客，可以按照从工具准备到实际连接，再到进阶无线连接的逻辑进行组织。\nADB 的安装与环境配置\nADB 是 Android SDK Platform-Tools 的一部分，支持 Windows、macOS 和 Linux 系统 。你可以从 Google 官方网站下载对应的 ZIP 包，解压后即可使用 。\n\nWindows: 将解压后的路径（如 C:\\platform-tools）添加到系统环境变量的 Path 中，这样可以在任意命令行窗口直接调用 adb 命令 。\nmacOS/Linux: 通常将路径添加到 ~/.bashrc 或 ~/.zshrc 文件的 export PATH 中，然后运行 source 命令使配置生效 。\n验证安装: 在终端输入 adb version，如果显示版本号则表示安装成功 。\n\nUSB 物理连接与授权\n在尝试无线连接之前，通常需要先通过 USB 线完成初次授权和调试开启。\n\n开启开发者选项: 在手机“设置” -&gt; “关于手机”中连续点击“版本号” 7 次，直到提示已开启开发者模式 。\n启用 USB 调试: 进入“开发者选项”菜单，打开“USB 调试”开关 。\n建立连接: 使用数据线连接电脑与手机，手机端弹出“允许 USB 调试吗？”的弹窗时，选择“始终允许”并确认 。\n检查状态: 在终端输入 adb devices，如果列出了设备序列号及其状态（device），则连接成功 。\n\n无线内网 IP 连接\n对于 Android 11 及更高版本的系统，官方支持更便捷的无线调试，不再强制要求初次连接必须使用数据线 。\n方案一：Android 11+（无需初次数据线）\n这种方式利用了“配对码”机制，安全性更高。\n\n开启无线调试: 在“开发者选项”中找到“无线调试”，开启后点击进入详情页 。\n配对设备: 点击“使用配对码配对设备”，记录显示的 IP 地址、端口号及 6 位配对码 。\n执行配对命令: 在电脑终端输入 adb pair [IP地址]:[配对端口]，然后按提示输入配对码 。\n正式连接: 配对成功后，查看无线调试主页面的“IP 地址和端口”，输入 adb connect [IP地址]:[连接端口] 即可 。\n\n方案二：Android 10 及以下版本（需初次数据线）\n旧版本系统通常需要先通过 USB 将 ADB 服务切换到网络监听模式 。\n\n\n\n步骤\n命令\n说明\n\n\n\n\n1. 初始化\nadb tcpip 5555\n开启手机 5555 端口的监听（需先连线）\n\n\n2. 拔掉线缆\n-\n拔掉 USB 线，确保手机与电脑在同一 Wi-Fi 下\n\n\n3. 无线连接\nadb connect [手机IP]:5555\n使用手机的内网 IP 地址进行连接\n\n\n\n温馨提示: 手机 IP 地址通常可以在“设置” -&gt; “关于手机” -&gt; “状态信息”中找到，或者在连接 USB 时使用 adb shell ip addr show wlan0 命令查看\n安装 scrcpy\n\n在终端输入 brew install scrcpy 即可完成安装 。\n补充依赖: scrcpy 运行依赖 adb 工具，若此前未安装过 adb，可以通过 brew install android-platform-tools 进行安装 。\n\n启动与使用\n完成安装后，你可以通过以下方式启动投屏。\n\nUSB 启动: 将手机连接至电脑并开启 USB 调试，直接在终端输入 scrcpy 即可 。\n无线启动: 确保手机已通过前文提到的 adb connect 命令成功连接，然后运行 scrcpy；或者直接使用集成命令 scrcpy --tcpip=[手机IP] 自动尝试连接并启动 。\n\n常用操作快捷键\nscrcpy 的操作主要通过键盘快捷键（macOS 默认修饰键 MOD 为 Option ⌥ 或 Command ⌘）完成 。\n\n\n\n功能\n快捷键\n鼠标操作\n\n\n\n\n返回 (Back)\nMOD + b\n鼠标右键\n\n\n主屏幕 (Home)\nMOD + h\n鼠标中键\n\n\n最近任务 (Recent)\nMOD + m\n-\n\n\n关闭屏幕 (熄屏)\nMOD + o\n- (电脑端保持镜像)\n\n\n全屏模式\nMOD + f\n-\n\n\n调整窗口大小\nMOD + g\n将窗口调整为 1:1 比例\n\n\n\n","slug":"adb","date":"2026-02-05T10:07:57.958Z","categories_index":"TOOL","tags_index":"adb","author_index":"Kidwen"},{"id":"0e3cff53af89b6890eddd1f859498aa3","title":"检查提交文件的单元测试覆盖率","content":"单元测试作为项目中不可或缺的一部分，无论是Angular、React还是Vue都有其默认的单元测试框架，这里就不讨论该使用哪个框架以及框架的优缺点。本文聚焦于如何通过Node脚本在代码提交时检测开发者是否将项目中的单元测试覆盖率达到要求的标准。本文涉及到的框架/技术点 Angular(演示示例) + husky(必须)+git(必须)+karma(演示示例) + node(必须)。\n初始化karma配置\n在karma.conf.js文件中配置生成的单元测试报告目录地址。此时如果执行ng test --code-coverage --watch=false则会生成测试报告。\nmodule.exports = function (config) &#123;\n  config.set(&#123;\n    coverageReporter: &#123;\n      dir: require(\"path\").join(__dirname, \"./coverage/projectName\"),\n      include: [\"src/app/pages/**\", \"src/app/services/**\", \"src/app/shared/**\"],\n      subdir: \".\",\n      // 生成json格式的单元测试覆盖率报告\n      reporters: [&#123; type: \"html\" &#125;, &#123; type: 'lcovonly' &#125;, &#123; type: \"text-summary\" &#125;, &#123; type: \"json-summary\" &#125;],\n    &#125;,\n    // 已忽略其他配置项\n  &#125;);\n&#125;;\n\nnode脚本检测覆盖率\n实现思路为：\n\n读取单元测试覆盖率文件内容；\n根据git提交的文件查找对应单测文件覆盖率；\n当覆盖率不足时提示报错并阻止提交；\n\nvar fs = require('fs');\nvar execSync = require('child_process').execSync;\n\nvar report = fs.readFileSync('coverage/projectName/coverage-summary.json', 'utf8');\n\n// 获取 staged 文件列表\nfunction getGitStagedFiles () &#123;\n  try &#123;\n    var result = execSync('git diff --name-only --cached', &#123; encoding: 'utf8' &#125;);\n    return result.trim().split('\\n').filter(Boolean);\n  &#125; catch (error) &#123;\n    process.exit(1);\n  &#125;\n&#125;\n\nvar stagedFiles = getGitStagedFiles();\nvar lowCoverageFiles = [];\nfor (var i = 0; i &#x3C; stagedFiles.length; i++) &#123;\n  var filePath = stagedFiles[i];\n  // 这里只检测ts文件，可根据实际需求增加判断\n  if (!filePath.endsWith('.ts')) &#123;\n    continue;\n  &#125;\n  var fileAbsolutePath = require(\"path\").join(process.cwd(), filePath);\n  // 这里替换.ts为.spec.ts并判断单测文件是否存在，如果不存在单元测试文件可以跳过也可以加入lowCoverageFiles中，按照项目要求调整！！！\n  var specFileAbsolutePath = require(\"path\").join(process.cwd(), filePath.replace('.ts', '.spec.ts'));\n  var isExist = fs.existsSync(specFileAbsolutePath);\n  if (!isExist) &#123;\n    continue;\n    // lowCoverageFiles.push(&#123;\n    //   filePath: filePath,\n    //   fileCoverage: 0\n    // &#125;);\n  &#125;\n  var fileCoverage = JSON.parse(report)[fileAbsolutePath].lines.pct;\n  if (fileCoverage &#x3C; 70) &#123;\n    lowCoverageFiles.push(&#123;\n      filePath: filePath,\n      fileCoverage: fileCoverage\n    &#125;);\n  &#125;\n&#125;\n// 如果存在不符合要求的文件输出报错并异常退出，否则正常退出\nif (lowCoverageFiles.length) &#123;\n  for (var i = 0; i &#x3C; lowCoverageFiles.length; i++) &#123;\n    console.error('❌ ' + colors(['yellow'], lowCoverageFiles[i].filePath) + ' unit test coverage ' + colors(['red'], lowCoverageFiles[i].fileCoverage + '%') + ' is less than ' + colors(['green'], '70%') + ', please add more unit test cases!');\n  &#125;\n  process.exit(1);\n&#125;\nprocess.exit(0);\n\nfunction colors (keys, source) &#123;\n  var styles = &#123;\n    'reset': '\\x1B[0m',\n    'bright': '\\x1B[1m',\n    'grey': '\\x1B[2m',\n    'italic': '\\x1B[3m',\n    'underline': '\\x1B[4m',\n    'reverse': '\\x1B[7m',\n    'hidden': '\\x1B[8m',\n    'black': '\\x1B[30m',\n    'red': '\\x1B[31m',\n    'green': '\\x1B[32m',\n    'yellow': '\\x1B[33m',\n    'blue': '\\x1B[34m',\n    'magenta': '\\x1B[35m',\n    'cyan': '\\x1B[36m',\n    'white': '\\x1B[37m',\n    'blackBG': '\\x1B[40m',\n    'redBG': '\\x1B[41m',\n    'greenBG': '\\x1B[42m',\n    'yellowBG': '\\x1B[43m',\n    'blueBG': '\\x1B[44m',\n    'magentaBG': '\\x1B[45m',\n    'cyanBG': '\\x1B[46m',\n    'whiteBG': '\\x1B[47m'\n  &#125;;\n  var values = '';\n  if (typeof keys === 'string') &#123;\n    values = styles[keys];\n  &#125;\n  else &#123;\n    keys.forEach(function (key) &#123;\n      values += styles[key];\n    &#125;);\n  &#125;\n  return values + source + styles['reset']\n&#125;\n\n在package.json中添加script\n&#123;\n    \"scripts\": &#123;\n        \"check-coverage\": \"node ./scripts/check-coverage.js\"\n    &#125;\n&#125;\nhusky 拦截 git 提交\n下面命令会安装和初始化husky并在项目中创建/.husky/pre-commit文件。\nnpm install --save-dev husky\nnpx husky init\npre-commit 中可以添加在git提交时执行的命令。\n# 删除之前生成的单元测试报告\nrm -rf coverage/projectName/*\n\n# 生成单元测试报告\nng test --code-coverage --watch=false\n\n# 执行node脚本检测提交的文件的单元测试覆盖率是否达标\nnpm run check-coverage\n总结\n将上面的代码配置在项目中后每次执行git commit 命令后生成报告并检测单测覆盖率。不达标时会输出报错并阻止提交。后续可以考虑在项目的CI/CD中来检测以防止husky未安装跳过检测等问题。\n","slug":"check-ut-coverage","date":"2025-11-17T06:53:39.229Z","categories_index":"NODE","tags_index":"node","author_index":"Kidwen"},{"id":"374a67da1401504fdc674bb6037a7b30","title":"Angular linkedSignal()","content":"随着Angular 19发布，Angular添加了一些新的功能。本文主要介绍Angular linked signal的基础用法和 computed 的区别，以及什么时候为什么要使用 Angular linked signal。\nAngular Linked Signal 是什么？\n简单来说就是可写入并关联一个或多个其他signal的signal。是不是感觉和computed很像🤣。\nlinkedSignal 关键词\n\n可写入：可以使用set和update直接更新值。\n响应式：和computed一样，依赖一个或者多个signal来变化\n\n如何创建linkedSignal？\n先看一个简略代码如下：\nconst quantity = linkedSignal(&#123;\n    source: () => (&#123; courseCode: this.selectedCourse() &#125;),\n    computation: (&#123; courseCode &#125;, previous) => &#123;\n        const course = this.courses.find(c => c.code === courseCode);\n        return course ? course.defaultQuantity : previous ?? 1;\n    &#125;\n&#125;);\n\nquantity.set(1);\nquantity.update(current => current + 1);\n关键词：\n\nsource：指定linkedSignal关联的signal。\ncomputed：当关联的signal发生变化时执行的逻辑。\n\n上述代码逻辑：\n\n指定linkedSignal关联的signal。\n每次source中的关联的signal发生变化时触发computed。\ncomputed接收关联的signal值和之前linkedSignal值。\n返回新的值给linkedSignal。\n通过set和update更新linkedSignal的值。\n\n什么时候使用linkedSignal？\n让我们从一个实际的例子出发🚀\n\n首先定义一个购物车，用户可以选择商品和改变数量。\n每个商品都有一个默认的数量。\n每次用户改变选中的商品都要改变对应的默认数量。\n\n&#x3C;div class=\"demo-container\">\n\n  &#x3C;h1>Shopping Cart&#x3C;/h1>\n\n  &#x3C;div class=\"form-control\">\n\n    &#x3C;label>Select Course&#x3C;/label>\n\n    &#x3C;select [value]=\"selectedCourse()\" \n    (change)=\"onCourseSelected(course.value)\" #course>\n      @for (course of courses; track course.code) &#123;\n        &#x3C;option [value]=\"course.code\">\n            &#123;&#123;course.title&#125;&#125;\n        &#x3C;/option>\n      &#125;\n    &#x3C;/select>\n\n  &#x3C;/div>\n\n  &#x3C;div class=\"form-control\">\n\n    &#x3C;label>Quantity&#x3C;/label>\n\n    &#x3C;input type=\"number\" \n       [value]=\"quantity()\" \n       (change)=\"onQuantityChanged(input.value)\"\n       #input/>\n\n  &#x3C;/div>\n\n  &#x3C;div class=\"form-actions\">\n\n    &#x3C;button class=\"btn\" \n            (click)=\"onArticleAdded()\">\n      Add To Cart\n    &#x3C;/button>\n\n  &#x3C;/div>\n\n&#x3C;/div>\n上面代码的大概含义为\n\n代码中的变量均为signal。\n有一个下拉课程数组，用户可以选择并添加到购物车。\n有一个输入框对应选中课程的数量。\n当用户改变选择的课程，输入框的值变为选中课程的默认数量\n\n关键部分为数量字段，当改变选中的商品对应的数量要改变，同时输入框也可以改变数量。所以这个数量即是响应式的又是可写的。\n如果没有linkedSignal我们应该怎么实现上面的逻辑🤔\n因为数量要跟着选中的商品变化，可以考虑computed。\n但是输入框又可以改变数量，所以只能使用effect来更新数量。\neffect(() => &#123;\n    const selectedCourse = this.selectedCourse();\n    quantity.set(courses.find(c => c.code === selectedCourse)?. defaultQuantity ?? 1);\n&#125;);\n为什么不使用effect\n\n首先是不明确，因为在effect中写入了其他信号值\neffect写入其他信号值可能会造成无限循环。\n而且关联关系并不明显\neffect应该是纯粹的\n一般来说应该尽量避免使用effect\n\n用linkedSignal来重写上面逻辑吧\n@Component(&#123;\n  selector: 'linked-signal-demo',\n  templateUrl: './linked-signal-demo.component.html',\n&#125;)\nexport class LinkedSignalDemoComponent &#123;\n\n  // these are the products of the shopping cart \n  courses = [\n    &#123;\n      code: \"BEGINNERS\",\n      title: \"Angular for Beginners\",\n      defaultQuantity: 10\n    &#125;,\n    &#123;\n      code: \"SIGNALS\",\n      title: \"Angular Signals In Depth\",\n      defaultQuantity: 20\n    &#125;,\n    &#123;\n      code: \"SSR\",\n      title: \"Angular SSR In Depth\",\n      defaultQuantity: 30\n    &#125;\n  ];\n\n  // 下拉选择的产品\n  selectedCourse = \n  signal&#x3C;string | null>(\"BEGINNERS\");\n\n  // 数量\n  quantity = linkedSignal(&#123;\n    source: () => (&#123;courseCode: this.selectedCourse&#125;),\n    computation: (source, previous) => &#123;\n      return \n      this.courses.find(c => c.code \n      === source.courseCode())?.defaultQuantity ?? 1\n    &#125;\n  &#125;);\n\n  onQuantityChanged(quantity: string) &#123;\n    this.quantity.set(parseInt(quantity));\n  &#125;\n\n  onCourseSelected(courseCode: string) &#123;\n    this.selectedCourse.set(courseCode);\n  &#125;\n&#125;\n\n现在使用linkedSignal更加优雅的解决了上面的问题。\nselectedCourse和quantity信号之间的关系更加明确，可以在定义的地方发现。\nquantity仍然是可写的，这样输入框可以直接改变值。\n\n为什么不使用linkedSignal替换所有的computed？\n\nlinkedSignal是一个新基础signal不是为了取代computed信号。\n只有很少见的场景需要用到linkedSignal。\n如果可以用computed解决问题，那么就没有必要使用 linkedSignal。\n\n什么场景可以使用linkedSignal？\n\n表单字段依赖于其他字段\n状态管理场景中，数值可能会被重置也可以被修改\n如果computed的限制性太强，但effect又过于必不可少，那么使用linkedSignal可能会更好。\n\n总结\n\nlinkedSignal 基元填补了 Angular 基于信号的反应模型中的一个重要空白。\n它允许开发人员在信号之间定义可写的反应关系，非常适合字段重置等情况。\n虽然它完全不能取代 computed 或 signal ，但在需要可写计算值时，它提供了一个强大的替代方案。\n如果您已经在使用 Angular 的信号 API，请试试 linkedSignal - 它将有助于使您的代码更简洁、更易维护。\n但大多数问题还是尽量用 computed 和 signal 基元来解决，因为它们足以应付大多数情况。\n\n","slug":"angular-linked-signal","date":"2025-07-03T07:16:16.218Z","categories_index":"ANGULAR","tags_index":"angular signal","author_index":"Kidwen"},{"id":"22e810e3b4957093defc777cc7b799b3","title":"ts 中 any、unknown、{}、object 的区别","content":"在 typescript 中，any、unknown、{} 和 object 是四种不同的类型，它们在类型系统中的用途和含义各不相同。下面是它们之间的区别：\nany\n\nany 是 TypeScript 中最宽松的类型，它可以表示任何类型的值。\n使用 any 时，TypeScript 不会对该值进行任何类型检查，这意味着你可以对它执行任何操作，而不会引发编译错误。\n这使得 any 非常灵活，但也可能导致类型安全性降低。\n\nlet value: any;\nvalue = 42; // number\nvalue = \"hello\"; // string\nvalue = true; // boolean\nunknown\n\nunknown 它表示一个未知的值。\n与 any 不同，使用 unknown 时，TypeScript 会对该值进行类型检查，因此在使用之前必须先进行类型检查或类型断言。\n这使得 unknown 更加安全，因为它强制你在使用值之前了解它的类型。\n\nlet value: unknown;\nvalue = 42; // number\nvalue = \"hello\"; // string\n\nif (typeof value === \"string\") &#123;\n  console.log(value.toUpperCase()); // 可以安全地调用字符串方法\n&#125;\n{}\n\n{} 是一个空对象类型，表示一个非原始类型的值。\n它可以接受可以接受除了 null 和 undefined 之外的任何值，包括原始类型（如 number、string、boolean 等）。\n不能对 {}类型的变量随意添加或访问属性（除非这些属性在 Object.prototype 上）。\n\nlet value: &#123;&#125;;\nvalue = 42; // 允许\nvalue = \"string\"; // 允许\nvalue = true; // 允许\nvalue.toString(); // 允许\n\nvalue.foo = 123; // 错误：类型上不存在属性 foo\nvalue.bar; // // 错误：类型上不存在属性 bar\nobject\n\nobject 是一个更广泛的类型，表示任何非原始类型的值。\n它可以接受对象、数组、函数等，但不能接受原始类型（如 number、string、boolean 等）。\nobject 更加灵活，因为它可以表示任何非原始类型的值。\n\nlet value: object;\nvalue = &#123;&#125;; // 对象\nvalue = []; // 数组\nvalue = () => &#123;&#125;; // 函数\nvalue = 42; // 错误：number 不是对象类型\n总结\n\nany：最宽松的类型，可以表示任何类型的值，类型检查被禁用。\nunknown：表示未知的值，必须在使用之前进行类型检查或类型断言。\n{}：空对象类型，接受除了 null 和 undefined 之外的任何值, 保持基本的类型检查，不允许随意访问不存在的属性。\nobject：表示任何非原始类型的值，包括对象、数组和函数。\n\n","slug":"any-unknomn","date":"2025-04-24T09:27:56.038Z","categories_index":"TYPESCRIPT","tags_index":"typescript","author_index":"Kidwen"},{"id":"57ebfbfb1ef0759746dce75d6b8c9c2e","title":"vscode 有趣的功能","content":"本文主要记录一些 vscode 的有趣功能，可能会不定期更新。每次 vscode 更新都会有一个更新文档，文档中会详细介绍新功能和修复的 bug，感兴趣的可以去看看，在顶部 Help =&gt; Shou Release Notes 下。或者打开vscode 官方更新文档查看历史更新日志。\n1.99\ncopilot 现在支持自定义Key了 (Anthropic, Azure, Gmini, OpenAI, Ollama, OpenRouter)\n\n\n在chat中选择模型\n\n\n\n选择 Manage Models... 进入模型管理界面选择 OpenRouter 后输入从openrouter网站创建的key\n\n\n\n选择想要添加的模型\n\n\n\ncopilot 新增支持 MCP 服务\n\n首先在设置中打开⚙️chat.agent.enabled\n在chat中选择 Agent 模式\n\n点击工具按钮并选择 Add MCP Server...\n\n选择想要的安装方式，这里以NPM Package安装为例\n\n输入要安装的MCP工具名称，例如 @modelcontextprotocol/server-filesystem 并回车\n\n选择允许\n\n按照提示输入运行工具访问的本地路径并回车(需要输入两个路径，后面可以在配置文件中修改)\n\n调整服务的唯一ID并回车\n\n然后会跳转到配置文件中, 这时可以调整服务的配置\n\n\n\n\n\n\n\n\n\n\n\n\nmcp server modelcontextprotocol 列表\nmcp server smithery 列表\n\nv1.98\n\n\n⚙️@id:workbench.settings.useWeightedKeySearch\n\n\n\n\n\n\n\n\n\n需要手动开启\n优化了设置中的搜索算法\n\n\n⚙️@id:terminal.integrated.suggest.enabled\n\n\n\n\n\n\n\n\n\n需要手动开启\n终端中输入命令时会自动提示命令\n\n\n⚙️@id:window.title\n\n\n\n\n\n\n\n\n\n新增activeEditorState，可以在标题中显示当前编辑器的状态\n\n\n","slug":"vscode-new","date":"2025-04-02T02:14:09.384Z","categories_index":"TOOL","tags_index":"vscode","author_index":"Kidwen"},{"id":"3080653b62f0f82df186319682e9fc25","title":"使用 cline 生成代码并自动改错","content":"mcp全称为Model Context Protocol主要是帮助 AI 与外部的各种工具和数据连接到一起。可以把 MCP 想象成人工智能应用的 “USB-C 端口” —— 一个标准化的即插即用接口，用于连接各种工具和数据。就像 USB-C 允许许多设备互操作而不受制造商限制一样，MCP 定义了通用规则，允许任何基于 LLM 的客户端与任何兼容 MCP 的服务器进行对话。这种标准化相当于语言服务器协议（LSP）对编程环境的作用：LSP 允许任何代码编辑器通过通用协议支持任何编程语言，将 M×N 集成问题转变为 M+N。\n安装\n\nvscode 插件市场搜索cline并安装\n\n\n配置\n\n\n在 vscode 左侧边栏找到cline图标，点击进入\n\n\n\nAPI Provider中选择OpenRouter\n\n\nOpenRouter API Key中输入你的 API Key\n\n\n\n\n\n\n\n\n\n获取 API Key\n\n\nModel中选择deepseek/deepseek-chat:freee，这样就可以使用免费的AI模型了\n\n\n[可选] 点击右上角设置，勾选Use different models for Plan and Act modes, Act 可以直接完成任务相对来说我用的更多一点😂\n\n\n\n点击右上角插件图标，搜索filesystem，点击Install, 安装过程中会自动创建 cline 的配置文件, 如果安装失败可以选择直接在 cline 的配置文件中修改配置来安装\n\n配置文件示例\n\n\n\n点击顶部+创建新的对话任务，可以勾选底部Auto-approve,这样会自动执行任务并写入文件\n\n\n\n使用\n\n点击底部的 Plan或者Act按钮, 输入你想执行的任务\n\n扩展\n\n\n如果想安装新的cline插件可以在插件市场点击插件会跳转对应的github页面，找到对应的json配置复制到cline的配置文件中\n\n\n然后修改command为cmd, args添加/c, npx，检查是否插件安装成功, 最后面为绿色圆点为安装成功\n\n\n\n参考\n\nDetails\n&#123;\n    \"mcpServers\": &#123;\n        \"browser-tools-mcp\": &#123;\n            \"command\": \"cmd\",\n            \"args\": [\n                \"/c\",\n                \"npx\",\n                \"-y\",\n                \"@agentdeskai/browser-tools-mcp@1.2.0\"\n            ],\n            \"autoApprove\": [\n                \"getNetworkErrors\",\n                \"getSelectedElement\",\n                \"takeScreenshot\"\n            ]\n        &#125;,\n        \"filesystem\": &#123;\n            \"command\": \"cmd\",\n            \"args\": [\n                \"/c\",\n                \"npx\",\n                \"-y\",\n                \"@modelcontextprotocol/server-filesystem\",\n                \"C:\\\\Users\\\\[username]\\\\Desktop\",\n                \"D:\\\\workspace\"\n            ]\n        &#125;\n    &#125;\n&#125;\n\n\n\n","slug":"mcp","date":"2025-03-19T07:14:09.384Z","categories_index":"AI","tags_index":"mcp","author_index":"Kidwen"},{"id":"c6a94a4407c4957c896b7d4b5cf0704e","title":"angular 动态组件应用场景","content":"在 Angular 中，动态组件允许你在运行时动态地创建和插入组件，而不是在模板中静态定义。这种灵活性使得你可以根据应用的状态或用户交互来决定加载哪些组件。\n关键词：\n\nViewContainerRef：表示视图容器，用于管理动态组件的插入和移除。\nComponentFactoryResolver：用于解析组件的工厂，通过它可以动态创建组件实例。\nComponentRef：代表动态创建的组件实例。\nTemplateRef：代表可用于创建视图的嵌入式模板。\nInjector：为动态创建的组件提供依赖关系。\n\n示例\n动态表单\n\n\n\n\n\n\n\n\n\n在一个form表单中根据某个下拉项选中的值显示不同的字段场景时\n\n\n定义动态需要显示的组件\n   // Text Input Component\n   @Component(&#123;\n     selector: 'app-text-input',\n     template: '&#x3C;input type=\"text\" placeholder=\"Enter text\">',\n   &#125;)\n   export class TextInputComponent &#123;&#125;\n\n   // Date Input Component\n   @Component(&#123;\n     selector: 'app-date-input',\n     template: '&#x3C;input type=\"date\">',\n   &#125;)\n   export class DateInputComponent &#123;&#125;\n\n\n容器组件\n   import &#123;\n     Component,\n     ViewChild,\n     ViewContainerRef,\n     ComponentFactoryResolver,\n   &#125; from '@angular/core';\n   import &#123; TextInputComponent &#125; from './text-input.component';\n   import &#123; DateInputComponent &#125; from './date-input.component';\n\n   @Component(&#123;\n     selector: 'app-dynamic-form',\n     template: `\n       &#x3C;select #fieldType (change)=\"onFieldTypeChange(fieldType.value)\">\n         &#x3C;option value=\"text\">Text Input&#x3C;/option>\n         &#x3C;option value=\"date\">Date Input&#x3C;/option>\n       &#x3C;/select>\n       &#x3C;div #container>&#x3C;/div>\n     `,\n   &#125;)\n   export class DynamicFormComponent &#123;\n     @ViewChild('container', &#123; read: ViewContainerRef, static: true &#125;)\n     container: ViewContainerRef;\n\n     constructor(private componentFactoryResolver: ComponentFactoryResolver) &#123;&#125;\n\n     onFieldTypeChange(fieldType: string) &#123;\n       this.container.clear();\n       let componentFactory;\n\n       if (fieldType === 'text') &#123;\n         componentFactory =\n           this.componentFactoryResolver.resolveComponentFactory(TextInputComponent);\n       &#125; else if (fieldType === 'date') &#123;\n         componentFactory =\n           this.componentFactoryResolver.resolveComponentFactory(DateInputComponent);\n       &#125;\n\n       if (componentFactory) &#123;\n         this.container.createComponent(componentFactory);\n       &#125;\n     &#125;\n   &#125;\n\n\n动态弹窗\n\n\n\n\n\n\n\n\n\n创建一个弹窗服务，根据用户的不同操作显示不同弹窗组件\n\n\n弹窗组件interface\n   import &#123; ComponentRef &#125; from '@angular/core';\n\n   export interface ModalComponent &#123;\n     close(): void;\n     componentRef?: ComponentRef&#x3C;any>;\n   &#125;\n\n\n弹窗服务\n   import &#123;\n     Injectable,\n     ComponentFactoryResolver,\n     ViewContainerRef,\n     ComponentRef,\n   &#125; from '@angular/core';\n   import &#123; ModalComponent &#125; from './modal.component';\n\n   @Injectable(&#123;\n     providedIn: 'root',\n   &#125;)\n   export class ModalService &#123;\n     private container: ViewContainerRef;\n\n     constructor(private componentFactoryResolver: ComponentFactoryResolver) &#123;&#125;\n\n     setContainer(container: ViewContainerRef) &#123;\n       this.container = container;\n     &#125;\n\n     open(component: any): ComponentRef&#x3C;any> &#123;\n       this.container.clear();\n       const factory =\n         this.componentFactoryResolver.resolveComponentFactory(component);\n       const componentRef = this.container.createComponent(factory);\n       (componentRef.instance as ModalComponent).componentRef = componentRef;\n       return componentRef;\n     &#125;\n\n     close(componentRef: ComponentRef&#x3C;any>) &#123;\n       if (componentRef) &#123;\n         componentRef.destroy();\n       &#125;\n     &#125;\n   &#125;\n\n\n使用方法\n   import &#123; Component, ViewChild, ViewContainerRef &#125; from '@angular/core';\n   import &#123; ModalService &#125; from './modal.service';\n   import &#123; ConfirmationModalComponent &#125; from './confirmation-modal.component';\n\n   @Component(&#123;\n     selector: 'app-main',\n     template: `&#x3C;button (click)=\"openModal()\">Open Modal&#x3C;/button>&#x3C;div #modalContainer>&#x3C;/div>`,\n   &#125;)\n   export class MainComponent &#123;\n     @ViewChild('modalContainer', &#123; read: ViewContainerRef, static: true &#125;)\n     modalContainer: ViewContainerRef;\n\n     constructor(private modalService: ModalService) &#123;&#125;\n\n     ngOnInit() &#123;\n       this.modalService.setContainer(this.modalContainer);\n     &#125;\n\n     openModal() &#123;\n       this.modalService.open(ConfirmationModalComponent);\n     &#125;\n   &#125;\n\n\nCMS系统动态内容渲染\n\n\n\n\n\n\n\n\n\nCMS系统中动态的显示视频文章或者图片\n\n\n内容组件\n   @Component(&#123; selector: 'app-article', template: '...' &#125;) export class ArticleComponent &#123;&#125;\n   @Component(&#123; selector: 'app-video', template: '...' &#125;) export class VideoComponent &#123;&#125;\n   @Component(&#123; selector: 'app-image', template: '...' &#125;) export class ImageComponent &#123;&#125;\n\n\n内容容器组件\n   import &#123; Component, ViewChild, ViewContainerRef, ComponentFactoryResolver, Input &#125; from '@angular/core';\n   import &#123; ArticleComponent &#125; from './article.component';\n   import &#123; VideoComponent &#125; from './video.component';\n   import &#123; ImageComponent &#125; from './image.component';\n\n   @Component(&#123;\n     selector: 'app-content-loader',\n     template: '&#x3C;div #contentContainer>&#x3C;/div>'\n   &#125;)\n   export class ContentLoaderComponent &#123;\n     @ViewChild('contentContainer', &#123; read: ViewContainerRef, static: true &#125;) contentContainer: ViewContainerRef;\n     @Input() contentType: string;\n\n     constructor(private componentFactoryResolver: ComponentFactoryResolver) &#123;&#125;\n\n     ngOnChanges() &#123;\n         this.contentContainer.clear();\n         let componentType;\n\n         switch (this.contentType) &#123;\n           case 'article':\n             componentType = ArticleComponent;\n             break;\n           case 'video':\n             componentType = VideoComponent;\n             break;\n           case 'image':\n             componentType = ImageComponent;\n             break;\n         &#125;\n\n         if (componentType) &#123;\n           const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);\n           this.contentContainer.createComponent(factory);\n         &#125;\n     &#125;\n   &#125;\n\n\n最佳实践\n\n懒加载：对动态组件使用懒加载，以提高性能。\nInput/Output：使用 @Input() 和 @Output() 在动态组件及其父组件之间传递数据。\n组件通讯：使用服务或状态管理实现动态组件之间的通信。\n声明周期：了解并利用组件生命周期钩子进行状态初始化和监听清理。\n错误处理：为动态组件创建和管理提供错误处理功能。\n\n","slug":"angular-dynamic-component","date":"2025-03-16T12:38:09.384Z","categories_index":"ANGULAR","tags_index":"dynamic component","author_index":"Kidwen"},{"id":"8a8cf02982a981a3981c312011f99772","title":"ssh keygen","content":"一般来说，一个github账号和一个gitlab账号，需要生成两个公钥和私钥，分别用于github和gitlab。下面介绍如何生成公钥和私钥。并且配置config文件，方便使用。\n使用git bash进入.ssh目录\ncd ~/.ssh\n生成公钥和私钥\nssh-keygen -t ed25519 -C \"&#x3C;comment>\"\n# 例如\nssh-keygen -t ed25519 -C \"github@kidwen.top\"\n# 第一步输入文件名 例如 github_id_ed25519\n# 第二步输入密码 可以不用管\n# 第三步输入确认密码 可以不用管\n将公钥添加到github\n\n复制 github_id_ed25519.pub 文件内容\n打开github 点击头像 -&gt; settings -&gt; SSH and GPG keys -&gt; New SSH key\n将复制的内容粘贴到 key 中\n点击 Add SSH key\n\n同样步骤可以再次生成一个其他名字的公钥和私钥\nssh-keygen -t ed25519 -C \"gitlab@kidwen.top\"\n# 第一步输入文件名 例如 gitlab_id_ed25519\n# 第二步输入密码 可以不用管\n# 第三步输入确认密码 可以不用管\n将公钥添加到gitlab\n\n复制 gitlab_id_ed25519.pub 文件内容\n打开gitlab 点击头像 -&gt; settings -&gt; SSH keys -&gt; Add SSH key\n将复制的内容粘贴到 key 中\n点击 Add key\n\n配置 config 文件\n# 在.ssh目录下创建config文件\ntouch config\n# 编辑config文件\nvi config\n# 在文件中添加以下内容\nHost github.com\nHostName github.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/github_id_ed25519\n\nHost gitlab.com\nHostName gitlab.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/gitlab_id_ed25519\n测试是否成功\nssh -T github.com\nssh -T gitlab.com\n配置全局用户名和邮箱\ngit config --global user.name \"kidwen\"\ngit config --global user.email \"kidwen@qq.com\"\n配置当前仓库提交的用户名\n# 进入仓库目录  \ncd /path/to/your/repo\n# 配置用户名\ngit config --local user.name \"kidwen\"\n# 配置邮箱\ngit config --local user.email \"kidwen@qq.com\"\n检查配置\n# 检查本地配置\ngit config --local --list\n# 检查全局配置\ngit config --global --list\n","slug":"ssh-keygen","date":"2025-01-07T09:06:00.000Z","categories_index":"GIT","tags_index":"ssh-keygen","author_index":"Kidwen"},{"id":"02dceeb1c9680db6bfa35b02b26a819e","title":"[译]angular变更检查历史","content":"Angular 是一个组件驱动框架。和其他框架一样，他向用户展示数据并在数据变化后刷新视图。\n\n在模版中显示用户数据\n随着项目的增长，我们会创建越来越多的组件，并将他们组合在一起，最后我们会得到下面的组件树。\n\n但是Angular是如何知道什么时候刷新视图？如何知道数据何时发生变化？如何知道何时运行变更检查？\n同步代码的变更检查\n从一个小的例子开始。我们有一个属性 name和一个方法 changeName的组件。当点击按钮时调用 changeName方法并改变 name值。\n@Component(&#123;\ntemplate: `\n    &#x3C;button (click)=\"changeName();\">Change Name&#x3C;/button>\n    &#x3C;p>&#123;&#123; name &#125;&#125;&#x3C;/p>\n`\n&#125;)\nexport class AppComponent &#123;\n    public name: string = '';\n\n    public changeName() &#123;\n        this.name = 'Jane';\n    &#125;\n&#125;\n当点击按钮时，changeName方法被调用。因为所有的事情都被Angular封装了，所以我们可以安全的假设 name变更后，angular会运行一些代码来更新视图（而且所有的事情都会被同步）。\n\n\n\n\n\n\n\n\n\n想象中的Angular内部代码\ncomponent.changename();\n// Angular会对整个组件树运行变更检查，因为我们可能更新一些在其他组件中用到的service中的数据\nangular.runChangeDetection();\n他正常工作了！但是，在多数情况下我们更改数据并不是同步的。比如说一些HTTP请求，或者一些定时器，或者在更新数据前等待一些其他的事件。这就是问题的开始。\n异步代码的变更检查\n现在，我们在一秒钟后改变数据。我们可以使用 setTimeout方法。\n@Component(&#123;\ntemplate: `\n    &#x3C;button (click)=\"changeName();\">Change Name&#x3C;/button>\n    &#x3C;p>&#123;&#123; name &#125;&#125;&#x3C;/p>\n`\n&#125;)\nexport class AppComponent &#123;\n    public name: string = '';\n\n    public changeName() &#123;\n        setTimeout(() => &#123;\n            this.name = 'Jane';\n        &#125;, 1000);\n    &#125;\n&#125;\n当我们点击按钮时，会调用 changeName方法并调用 setTimeout方法。setTimeout会等待一秒改变 name值。\n现在我们添加和之前一样的想象中Angular底层代码。\n\n\n\n\n\n\n\n\n\n想象中的Angular内部代码\ncomponent.changeName(); // 内部包含 setTimeout\n// 当changeName被调用后直接调用下面的方法\nangular.runChangeDetection();\n由于 setTimeout是一个宏任务，所以会在 angular.runChangeDetection方法后面执行。所以即使Angular执行了变更检查，但是页面上的name也没有发生更改。这就是视图不会更新的原因，这就是程序崩溃的地方⚠️（事实上并非如此，因为我们有👇）。\nZone.js\nzone.js最早在Angular v2就开始使用了，他是一个浏览器API的猴子补丁库。他可以挂钩浏览器生命周期事件。这意味着什么？这意味着我们可以在浏览器事件之前或者之后运行我们的代码。\nsetTimeout(() => &#123;\n    console.log('Hello world');\n&#125;, 1000);\n上面代码会在一秒钟后打印 Hello world。但是如果我们想在 setTimeout之前或者之后执行一些代码该怎么做呢？要知道这是出于业务原因😄。Angular会希望在执行 setTimeout之前后者之后执行一些代码。\nZone.js可以让我们做到这些。我们可以创建一个zone（Angular同样创建了一个zone），并挂钩 setTimeout回调方法。\nconst zone = Zone.current.fork(&#123;\n    onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => &#123;\n        console.log('Before setTimeout');\n        delegate.invokeTask(target, task, applyThis, applyArgs);\n        console.log('After setTimeout');\n    &#125;\n&#125;);\n我们需要执行 zone.run()方法来运行 zone中的 setTimeout方法。\nzone.run(&#123;\n    setTimeout(() => &#123;\n        console.log('Hello world');\n    &#125;);\n&#125;);\n现在我们运行上面的代码会看到如下输出\nBefore setTimeout\nHello world\nAfter setTimeout\n这就是 zone.js的工作原理。它是对浏览器API的猴子补丁，这使我们可以挂钩浏览器事件的生命周期。\nZone.js + Angular\nAngular 会为每一个应用加载 zone.js并创建一个名为 NgZone的zone实例。NgZone包含一个叫做 onMicrotaskEmpty的 可观察（Observable）对象。这个可观察对象在队列中没有微任务时侯会发出一个值。这就是Angular用来知道所有异步代码执行完成并可以安全的执行变更检查的方案。\n\n我们一起来看一下底层代码:\n// ng_zone_scheduling.ts 文件 NgZoneChangeDetectionScheduler 类\nthis._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe(&#123;\n    next: () => &#123;\n        this.zone.run(() => &#123;\n            this.applicationRef.tick();\n        &#125;);\n    &#125;\n&#125;);\n我们可以看到上面代码中Angular会在 onMicrotaskEmpty对象发出值后调用 applicationRef.tick()方法。那这个 tick方法是做什么的呢？你还记得我们之前想象Angular底层代码中的 runChangeDetection方法吗？很好，tick方法就是 runChangeDetection方法。他会同步运行整个组件树的变更检查。\n现在Angular知道所有的异步任务完成了，它可以安全的执行变更检查了。\ntick(): void &#123;\n    // 精简后的代码\n    for(let view of this._views) &#123;\n        view.detectChanges();\n    &#125;\n&#125;\ntick 方法将遍历所有根视图（大多数情况下，我们只有一个根视图/组件，即 AppComponent），并同步运行 detectChanges。\n组件标记为脏状态\nAngular还会做一件事情就是当组件内部变化时标记为脏状态。\n这些都是标记为脏状态的操作：\n\n事件（点击，鼠标悬停等）\n\n每次我们点击模版中的一个带有监听事件的按钮时，angular会用一个名为wrapListenerIn_markDirtyAndPreventDefault的函数封装回调函数。正如我们从函数名上看到的，他会标记组件为脏状态。\nfunction wrapListener(): EventListener &#123;\n    return function wrapListenerIn_markDirtyAndPreventDefault(e: any) &#123;\n    // 精简后的代码\n        markViewDirty(startView); // 标记组件为脏状态\n    &#125;\n&#125;\n\n更改输入\n\n另外，在运行变更检查时，Angular会检查输入框的值是否发生变更(===check)。如何放生了变化，他会把组件标记为脏状态。源码\nsetInput(name: string, value: unknown): void &#123;\n    // 如果值没有发生变化则不做操作\n    if (Object.is(this.previousInputValues.get(name), value)) &#123;\n        return;\n    &#125;\n\n    // 精简后的代码\n    setInputsForProperty(lView[TVIEW], lView, dataValue, name, value);\n    markViewDirty(childComponentLView); // 将组件标记为脏\n&#125;\n\n抛出事件\n\n要在 Angular 中监听输出排放，我们需要在模板中注册一个事件。正如我们之前看到的，回调 fn 将被封装，当事件发生时，组件将被标记为 dirty。\n让我们看看这个 markViewDirty 函数的作用。\n/**\n* 标记当前视图和所有祖先为脏状态\n*/\nexport function markViewDirty(lView: LView): LView | null &#123;\n    while (lView) &#123;\n        lView[FLAGS] = LViewFlags.Dirty;\n        const parent = getLViewParent(lView);\n        // 一旦找到未附加到任何容器的根视图，就停止向上遍历\n        if (isRootView(lView) &#x26;&#x26; !parent) &#123;\n            return lView;\n        &#125;\n        lView = parent!;\n    &#125;\n    return null;\n&#125;\n从注释中可以看出，markViewDirty方法将当前和所有祖先视图标记为脏状态。下面的图片方便我们更好的理解。\n\n因此，我们点击按钮时，Angular会调用我们的回调方法（changeName），由于这个方法被wrapListenerIn_markDirtyAndPreventDefault方法包裹，所以会将组件标记为脏状态。\n正如之前讲的，Angular使用zone.js并用它来封装我们的应用。\n\n一直到顶部进行脏标记后，wrapListenerIn_markDirtyAndPreventDefault会触发并触发zone.js。\n\n由于Angular已经监听了onMicrotaskEmpty对象，而且点击事件注册了一个被zone.js包裹的事件监听器,zone知道什么时候事件完成运行，因此它可以想onMicrotaskEmpty对象发送一个值。\n\nonMicrotaskEmpty通知Angular执行变更检查。\n组件绑定刷新\n每次Angular运行变成检查会从顶层到最子节点检查每个组件。它会检查所有组件（脏状态和非脏状态）的绑定。如果绑定的值发生变化就会更新视图。\n\n但是为什么Angular要检查所有的组件而不是只检查脏状态组件呢🤔？\n这是因为Angular的变更检查策略。\nOnPush 变更检查策略\nAngular有一种变更检查策略命名为OnPush。当我们使用这种策略时，Angular会只对标记为脏状态的组件执行变更检查。\n首先我们更改变更检查策略为OnPush。\n@Component(&#123;\n    //...\n    changeDetection: ChangeDetectionStrategy.OnPush,\n&#125;)\nexport class UserCardComponent &#123; &#125;\n让我们看下面的图片来理解变更检查是如何与OnPush策略配合使用的。\n\n某些组件使用OnPush策略（其子组件隐含为OnPush组件）\n让我们再做一遍之前做的事情，点击组件中的按钮并更改名称。\n首先是脏标记阶段。\n\n然后事件监听器会通知zone.js\n\n当所有异步任务运行完毕后，onMicrotaskEmpty方法触发。\n\n现在Angular将会运行tick方法，他会从上之下遍历组件并检查每个组件。\n如果组件是：\n\nOnPush + 非脏状态 =&gt; 跳过\nOnPush + 脏状态 =&gt; 检查绑定 =&gt; 刷新绑定 =&gt; 检查子组件\n\n\n如图所示，通过使用OnPush策略，Angular会自动跳过组件树中的没有任何更改的部分。\nOnPush + Observables + async pipe\n当我们使用Angular时，Observable对象一直是我们在状态管理和数据管理时常用的对象。Angular为了支持observables提供了异步管道（async）。异步管道监听observable对象并返回最新的值。为了让Angular知道那些值发生了变化，它会调用来自changeDetectorRef类（组件中的changeDetectorRef）中的markForCheck。\n@Pipe()\nexport class AsyncPip implements OnDestroy, PipTransform &#123;\n    public constructor(\n        private ref: ChangeDetectorRef,\n    ) &#123; &#125;\n  \n    public transform&#x3C;T>(obj: Observable&#x3C;T>): T | null &#123;\n        // ...\n    &#125;\n\n    private _updateLatestValue(async: any, value: Object) &#123;\n        // 精简后的代码\n        this.ref!.markForCheck(); // 标记组件需要检查\n    &#125;\n&#125;\n从零开始创建异步管道并了解它的工作原理。\nmarkForCheck方法的作用就是调用之前提到的markViewDirty方法。\n// view_ref.ts\nmarkForCheck(): void &#123;\n    markViewDirty(this._cdRefInjectingView || this._lView);\n&#125;\n```\n因此，和之前一样，我们在组件中使用管道和使用点击事件一样，它会标记组件为脏状态，Angular后面会对这个组件执行变更检查。\n\ndata$ | async管道将组件标记为脏状态。\nOnPush + Observables + 谁触发了zone.js\n如果数据在没有发生交互时发生变化很有可能是触发了setTimeout或者setInterval或者HTTP请求，从而触发了zone.js\n下面是如何破坏监听💣\n@Component(&#123;\n    selector: 'app-todos',\n    standalone: true,\n    imports: [AsyncPipe, JsonPipe],\n    template: `&#123;&#123; todo$ | async | json &#125;&#125;`,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n&#125;)\nexport class TodosComponent implements OnInit &#123;\n    private http = inject(HttpClient);\n    private ngZone = inject(NgZone);\n\n    public todos$ = of([] as Array&#x3C;any>);\n\n    public ngOnInit() &#123;\n        this.ngZone.runOutsideAngular(() => &#123;\n            setTimeout(() => &#123;\n                // todos$会被更新但是不会触发zone.js\n                this.todos$ = this.getTodos();\n            &#125;);\n        &#125;);\n    &#125;\n\n    private getTodos() &#123;\n        return this.http.get&#x3C;any>('https://jsonplaceholder.typicode.com/todos/1').pipe(shareReplay(1));\n    &#125;\n&#125;\n这里我们做了下面几件事情：\n\n在ngOnInit中，我们调用 ngZone.runOutsideAngular() 方法使代码可以在Angular zone外面运行。\n我们使用setTimeout方法（跳过第一个正在运行的任务，因为Angular会默认至少执行一次变更检查），并在里面给 todos$ 赋值（现在数据发生了变更）。\n由于代码在runOutsideAngular中执行，因此 setTimeout不会在zone中运行，http请求也会被放在zone之外执行。所以没有任何通知给到zonejs\n上面的运行结果就是页面只显示 “[]”\n状态被破坏了🧨!\n\n为什么要把所有祖先都标记为脏状态？\n很简单，如果不把所有的祖先组件都标记为脏状态，我们很快就能得到一个被破坏的状态，下面介绍如何做。\n在上面的例子上，如果我们只把组件和子组件标记为脏状态。\n\n如图所示，我们只对当前组件和子组件标记检查，tick触发时，它会执行到使用OnPush策略的父组件然后检查父组件是否是脏状态，然后跳过父组件。\n\n使用markForCheck时，如果不把祖先组件标记为脏，就会出现问题\n为什么不能只对标记的组件运行变更检查？\n我们可以使用ChangeDetectorRef类中的detectChanges来做到这点。但是这有缺点，由于同步执行变更检查，这可能造成性能问题。由于所有操作都在浏览器的任务器中做的，他会阻塞主线程。试想一下，变更检查没过一两秒钟就检查100项组件的变化。这对浏览器的工作压力山大。\nmarkForCheck vs detectChanges （合并运行 vs 同步运行）\n当我们执行markForCheck只是标记这个组件为脏状态，并不会做其他的事情。所以即使调用markForCheck1000次也不会造成任何问题。但是当我们调用detectChanges，Angular会执行实际工作，检查绑定和更新需要更新的视图。所以我们应该使用markForCheck而不是detectChanges。\n不可以在下一个浏览器任务中安排 detectChanges 吗？\n我们可以，这就是 rx-angulard 的 push pipe 或 rxLet 指令的作用。它将变化检测安排在下一个浏览器任务中。但是，对每个组件都这么做并不是个好主意。因为，如果我们有一个包含 100 个项目的列表，而我们为每个项目都安排了变化检测，那么我们就会有 100 个浏览器任务。这对性能也没有好处。\nSignals\n前端世界正在向着信号的方向发展。Solid.js、Svelte、Vue、Angular都在创建他们的信号实现方案。因为信号机制是状态管理和状态变化的更好的方法。\nAngular中的信号为DX带来了很多的好处，我们可以轻松的创建和派生状态，还可以在状态发生变化时执行副作用方法。不需要订阅它们也不需要取消订阅更不用担心内存泄漏问题。\n我们只需要调用它们，它们就会返回当前的值。\nconst name = signal('Jone'); // 创建一个信号并初始化一个默认值\nconst upperCaseName = computer(() => name().toUpperCase()); // 创建一个计算信号\n\npublic effect(() => &#123;\n    console.log(name() + ' ' + upperCaseName()); // 执行副作用方法当name或者uppeerCaseName发生变化\n&#125;);\n\nname.set('Jane');\n\n// Output:\n// Jone JONE\n// Jane JANE\n我们可以在模版中使用信号，就像调用普通函数一样。\n@Component(&#123;\n    template: `\n        &#x3C;button (click)=\"name.set('Jane')\">Change Name&#x3C;/button>\n        &#x3C;p>&#123;&#123; name() &#125;&#125;&#x3C;/p>\n    `\n&#125;)\nexpor class AppComponent &#123;\n    public name = signal('Jone');\n&#125;\n在模版中调用函数是否是一个好主意呢？我觉得如果函数调用代价低那就使用函数调用，它只是一个返回值函数调用（不需要调用任何东西）。\n参考文章\n信号和变更检查\n在Angular V17版本中，Angular变更检查得到了升级🚀！\nAngular模版现在知道信号而不是简单的方法调用。实现这一目标的PRs之一。\n之前我们使用async管道，他会调用markForCheck方法，而使用信号，我们只需要正常的调用它们。Angular会注册一个副作用（consumer），这会监听信号改变并标记模版以进行检查。\n\n这样做的好处是我们不再需要异步管道了\n第二个改进变更检查的PR：这解决了一个与信号无关的问题，但与变更检查本身有关。\n通过使用它引入的机制，下面第三个PR增加了Global + Local变更检查。\n让我们更好的理解Global + Local变更检查👇：\nLocal 变更检查\n我在上面几个PR中为Angular引入两个新标记。\n\n它们是如何工作的？\n当模版副作用执行时候，Angular会调用markViewForRefresh方法，这会设置当前组件状态为RefreshView并且会调用markAncestorsForTraversal这会标记所有的祖先为HAS_CHILD_VIEW_REFRESH状态。\n/**\n * 当前组件添加`RefreshView`标识，并对祖先组件添加`HAS_CHILD_VIEW_REFRESH`\n */\nexport function markViewForRefresh(lView: LView) &#123;\n    if (lView[FLAGS] &#x26; LViewFlags.RefreshView) &#123;\n        return;\n    &#125;\n    lView[FLAGS] = LViewFlags.RefreshView;\n    if (viewAttachedToChangeDetector(lView)) &#123;\n        markAncestorsForTraversal(lView);\n    &#125;\n&#125;\n下面图示（更新了树结构以展示更多的边缘情况）\n\n因此，有信号变化的组件会被标上橙色边框，而父代现在有⏬ 图标，表示它们有子代视图需要刷新。\n\n\n\n\n\n\n\n\n\nNOTE: 我们仍然需要zone.js来触发变更检查\n一旦 zone.js 启动（原因与之前相同），它就会调用 appRef.tick() ，然后我们就可以自上而下地检测变化，并制定一些不同的新规则！\nTargeted Mode Rules(目标模式规则)\nNgZone 在GlobalMode下触发变化检测（它将自上而下地检查和刷新所有组件）\n在 GlobalMode 中，我们检查 CheckAlways（未设置任何更改检测策略的正常组件）和 Dirty OnPush 组件\n什么触发了TargetedMode?\n\n在GlobalMode模式下，当遇到一个非脏状态的OnPush策略的组件时会切换到TargetedMode!\n\n在 TargetedMode 模式下：\n\n只有设置了RefreshView标识的组件才会刷新视图\n不刷新CheckAlways或者常规的脏状态组件视图\n\n\n如果我们到达一个带有 RefreshView 标记的视图，就会以全局模式遍历子视图\n\n下面逐一介绍各个部分组成\n\n\n跟组件是一个普通组件（CheckAlways），因此我们可以在需要时检查和刷新绑定，然后继续处理子组件\n\n\n\n所有的CheckAlways组件将继续和之前一样工作。\n\n\n\nOnPush将继续以同样的方式工作，因此如果没有标记为脏状态就不会被检查。\n\n\n如果我们检查另外一个OnPush + HAS_CHILD_VIEWS_TO_REFRESH但不是脏状态的组件，我们就会得到TargetedMode的触发器。\n\n\n组件本身不会刷新，让我们来看一下子组件吧。\n\n\n\n然后，我们到达一个 RefreshView 组件，并进入 TargetedMode 模式，这意味着我们会刷新绑定。我们还转换为 GlobalMode，以确保 CheckAlways 子组件也能正确刷新。\n\n\n\n现在我们处于全局模式（GlobalMode），并且有一个CheckAlways组件，所以我们只需要正常刷新即可。\n\n\n\n这就是新的&quot;目标检查（Targeted Change Detection）&quot;的全部内容。\n如果我们看一下最终的树，就会发现当我们到达一个不脏的 OnPush 组件时，我们跳过的组件比以前更多了。\n\n\n\n\n\n\n\n\n\n\nTargeted Change Detection = OnPush without footguns 🔫\n您可以在这款由 Mathieu Riegler 🔨 制作的应用程序中玩转所有这些变化检测规则。\nZoneless Angular - 让我们从 Angular 中移除 zone.js\n从 Angular 中移除 zone.js 后，我们将只剩下运行但不会更新视图中任何内容的代码（zone.js 的引导时间及其对浏览器造成的所有压力也会被移除）！我们还将 15kb 从 bundle 大小中移除 😎）。因为没有任何东西会触发 appRef.tick()。\n但是，Angular 有一些 API 可以告诉它发生了什么变化。是哪些呢？\n\nmarkForCheck（由异步管道使用）\n信号变化\n标记视图脏状态的事件处理程序\n在使用 setInput() 动态创建的组件上设置输入\n\n此外，OnPush 组件的工作原理已经表明，它需要告诉 Angular 有变化。\n因此，我们可以让 Angular 在知道有变化时计划 tick() ，而不是让 zone.js 计划 tick() 。\n参考\n在此 PR（实验性）中，我们可以看到 markViewDirty 现在会通知 changeDetectionScheduler 有变化。\nexport function markViewDirty(lView: LView): LView|null &#123;\n    lView[ENVIRONMENT].changeDetectionScheduler?.notify();\n    // ...\n&#125;\n调度器应该调度 tick()，正如我们在无分区调度器的其他实验实现中看到的那样。\n参考\n@Injectable(&#123;providedIn: 'root'&#125;)\nclass ChangeDetectionSchedulerImpl implements ChangeDetectionScheduler &#123;\n    private appRef = inject(ApplicationRef);\n    private taskService = inject(PendingTasks);\n    private pendingRenderTaskId: number|null = null;\n\n    notify(): void &#123;\n        if (this.pendingRenderTaskId !== null) return;\n\n        this.pendingRenderTaskId = this.taskService.add();\n        setTimeout(() => &#123;\n            try &#123;\n                if (!this.appRef.destroyed) &#123;\n                    this.appRef.tick();\n                &#125;\n            &#125; finally &#123;\n                const taskId = this.pendingRenderTaskId!;\n                this.pendingRenderTaskId = null;\n                this.taskService.remove(taskId);\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n这只是试验性的，但我们可以看到，基本上，它将合并所有 notify() 调用，并只运行一次（在此代码中，每个宏任务只运行一次 - setTimeout，但也许每个微任务只运行一次 - Promise.resolve())。\n我们应该从中理解什么？\n目前使用 OnPush 变更检测策略的应用程序在无区域的 Angular 世界中也能正常运行。\noneless Angular !== Glo-cal (local) change detection\nZoneless Angular 与本地变更检测不同。Zoneless Angular 只是从 Angular 中移除 zone.js，并使用 Angular 已有的 API 来安排 tick()。\n真实本地变更检测是一项新功能，它允许我们只对目前使用 OnPush 变更检测策略的组件子树（而不是整个组件树）进行变更检测。\n信号变化检测（无 OnPush、无 Zone.js，仅信号）\n信号变化检测将带来的一个功能是本机单向数据流（双向数据绑定，无需头痛）。\n虽然使用 OnPush 和无分区进行全局变化检测非常好，但如果只使用信号组件，我们或许可以做得更好。\n如果我们不必使用 OnPush 呢？或者用 HAS_CHILD_VIEWS_TO_REFRESH 标记父代，然后对整个组件树运行更改检测？如果我们可以只对组件内发生变化的视图运行变化检测呢？\n请阅读 RFC 中的更多内容：参考\n","slug":"angular-change-detection","date":"2024-08-13T11:34:54.108Z","categories_index":"ANGULAR","tags_index":"angular,zone.js,zoneless,local change detection,signals","author_index":"Kidwen"},{"id":"3eee3a1354f501cd9acf748f62965411","title":"css 容器查询","content":"@container CSS at-rule 是一种条件组规则，可将样式应用于包含上下文。样式声明由条件筛选，如果条件为真，则应用于容器。当容器大小或 &lt;style-feature&gt; 值发生变化时，将对条件进行评估。\n\n\n\n\n\n\n\nWARNING\n2023 年新属性，使用前请注意浏览器兼容性\n容器样式查询(Style queries for custom properties)为实验性技术\n@container style(&#x3C;style-feature>),\n    not style(&#x3C;style-feature>),\n    style(&#x3C;style-feature>) and style(&#x3C;style-feature>),\n    style(&#x3C;style-feature>) or style(&#x3C;style-feature>) &#123;\n  /* &#x3C;stylesheet> */\n&#125;\n\n\n\n示例\n@container (width > 400px) &#123;\n    h2 &#123;\n        font-size: 1.5em;\n    &#125;\n&#125;\n/* with an optional &#x3C;container-name> */\n@container tall (height > 30rem) &#123;\n    h2 &#123;\n        line-height: 1.6;\n    &#125;\n&#125;\n","slug":"css-container","date":"2024-08-05T12:01:16.644Z","categories_index":"CSS","tags_index":"css,@container","author_index":"Kidwen"},{"id":"67a3cc3fe9fb96b7c48b97ca3610f216","title":"如何让textare 根据内容高度变高","content":"Html中 input和textarea元素不会根据文本内容自动高度。下面介绍一些方法让输入框根据内容自适应高度。你可以选择使用JS来设置也可以选择CSS来设置。甚至你都可以不使用textarea元素，使用contenteditable属性来设置（这有一些隐患，不是很推荐使用）。\n使用JS\n&#x3C;textarea class=\"textarea resize-ta\">&#x3C;/textarea>\nfunction calcHeight(value) &#123;\n  let numberOfLineBreaks = (value.match(/\\n/g) || []).length;\n  // min-height + lines x line-height + padding + border\n  let newHeight = 20 + numberOfLineBreaks * 20 + 12 + 2;\n  return newHeight;\n&#125;\n\nlet textarea = document.querySelector(\".resize-ta\");\ntextarea.addEventListener(\"keyup\", () => &#123;\n  textarea.style.height = calcHeight(textarea.value) + \"px\";\n&#125;);\n根据文本换行的次数获取高度并重新复制到textarea上。\n使用CSS\n&#x3C;form action=\"#\">\n  &#x3C;label class=\"input-sizer\">\n    &#x3C;span>Name: &#x3C;/span>\n    &#x3C;input type=\"text\" onInput=\"this.parentNode.dataset.value = this.value\" size=\"4\" placeholder=\"John\">\n  &#x3C;/label>\n\n  &#x3C;label class=\"input-sizer stacked\">\n    &#x3C;span>Text: &#x3C;/span>\n    &#x3C;textarea onInput=\"this.parentNode.dataset.value = this.value\" rows=\"1\" placeholder=\"hi\">&#x3C;/textarea>\n  &#x3C;/label>\n&#x3C;/form>\n.input-sizer &#123;\n    display: inline-grid;\n    align-items: center;\n    position: relative;\n    border: solid 1px;\n    padding: .25em .5em;\n    margin: 5px;\n\n    &#x26;.stacked &#123;\n        padding: .5em;\n        align-items: stretch;\n\n        &#x26;::after,\n        input,\n        textarea &#123;\n            grid-area: 2 / 1;\n        &#125;\n    &#125;\n\n    &#x26;::after,\n    input,\n    textarea &#123;\n        min-width: 1em;\n        grid-area: 1 / 2;\n        font: inherit;\n        padding: 0.25em;\n        margin: 0;\n        resize: none;\n        background: none;\n        appearance: none;\n        border: none;\n        overflow: hidden;\n    &#125;\n\n    span &#123;\n        padding: 0.25em;\n    &#125;\n\n    &#x26;::after &#123;\n        content: attr(data-value) ' ';\n        visibility: hidden;\n        white-space: pre-wrap;\n    &#125;\n\n    &#x26;:focus-within &#123;\n\n        textarea:focus,\n        input:focus &#123;\n            outline: none;\n        &#125;\n    &#125;\n&#125;\n\n.input-sizer &#123;\n\n    >span &#123;\n        text-transform: uppercase;\n        font-size: 0.8em;\n        font-weight: bold;\n    &#125;\n&#125;\nJavaScript 在元素上设置了一个 data-* 属性，等于输入值。输入被设置在 CSS 网格中，该网格是一个使用 data-* 属性作为内容的伪元素。该内容会根据输入值将网格拉伸到合适的大小。\n使用contenteditable\n&#x3C;span class=\"input\" role=\"textbox\" contenteditable=\"true\" aria-multiline=\"true\">\n    contenteditable\n&#x3C;/span>\n\nrole=&quot;textbox&quot;用于标识这是一个允许输入自由格式文本的元素\naria-multiline=&quot;true&quot;用于设置Enter或者Return将创建换行而不是提交表单\n\n\n\n\n\n\n\n\n可能的问题\n用户可能会复制内容到输入框，如果是从网页上复制文本会带入样式\n\n\n","slug":"textarea-auto-height","date":"2024-07-18T03:18:10.434Z","categories_index":"CSS,JAVASCRIPT","tags_index":"css,javascript","author_index":"Kidwen"},{"id":"472154ff4d678918f357bc4ca8cdd7e6","title":"google map directions","content":"本文介绍通过 google map directions api 获取导航路径并绘制到google地图上，支持多条路径绘制。精准时间也有一些限制需要注意。\n通过 Directions API 获取路线\nhttps: //maps.googleapis.com/maps/api/directions/json?origin=Disneyland&amp;destination=Universal+Studios+Hollywood&amp;key=****************\n参数\n必选\n\n\norigin (起点)\n支持 地点字符串, 地点ID place_id, 经纬度\n\norigin=24+Sussex+Drive+Ottawa+ON\norigin=place_id:ChIJ3S-JXmauEmsRUcIaWtf4MzE\norigin=41.43206,-81.38992\n\n\n\ndestination (终点)\n和 origin 相同\n\n\nkey\n\n\n可选\n\n\navoid (可多选)\n\ntolls 避开收费公路/桥梁\nhighways 避开高速公路\nferries 避开渡轮\nindoor 避免步行和公交方向的室内台阶。\n\n\n\nTravelMode\n\nDRIVING (默认值) 使用道路网络进行计算\nBICYCLING 自行车\nTRANSIT 公共交通\nWALKING 走路\n\n\n\ndeparture_time 出发时间 (默认当前时间)\n\n对于出行模式为驾驶的请求：您可以指定出发时间来接收考虑交通状况的路线和行程持续时间（响应字段：duration_in_traffic）。 departure_time 必须设置为当前时间或将来的某个时间。它不可能是过去的。\n不指定则无法将交通状况计算在内\n\n\n\nwaypoints 航点\n\n可以传入多个地点以|分割，可以传入 place_id(必须为其添加 place_id: 前缀) 或者经纬度(可能不够精确，推荐 place_id)或者 编码多段线算法格式\n``\n\n\n\n返回结果\n\nroutes =&gt; distance.value 单位米\n\n&#123;\n    \"geocoded_waypoints\": [\n        &#123;\n            \"geocoder_status\": \"OK\",\n            \"partial_match\": true,\n            \"place_id\": \"ChIJa147K9HX3IAR-lwiGIQv9i4\",\n            \"types\": [\n                \"amusement_park\",\n                \"establishment\",\n                \"point_of_interest\",\n                \"tourist_attraction\"\n            ]\n        &#125;,\n        &#123;\n            \"geocoder_status\": \"OK\",\n            \"partial_match\": true,\n            \"place_id\": \"ChIJzzgyJU--woARcZqceSdQ3dM\",\n            \"types\": [\n                \"amusement_park\",\n                \"establishment\",\n                \"point_of_interest\",\n                \"tourist_attraction\"\n            ]\n        &#125;\n    ],\n    \"routes\": [\n        &#123;\n            \"bounds\": &#123;\n                \"northeast\": &#123;\n                    \"lat\": 34.134496,\n                    \"lng\": -117.9221199\n                &#125;,\n                \"southwest\": &#123;\n                    \"lat\": 33.815744,\n                    \"lng\": -118.3517026\n                &#125;\n            &#125;,\n            \"copyrights\": \"Map data ©2024 Google\",\n            \"legs\": [\n                &#123;\n                    \"distance\": &#123;\n                        \"text\": \"34.8 英里\",\n                        \"value\": 55984\n                    &#125;,\n                    \"duration\": &#123;\n                        \"text\": \"44分钟\",\n                        \"value\": 2657\n                    &#125;,\n                    \"end_address\": \"100 Universal City Plaza, Universal City, CA 91608美国\",\n                    \"end_location\": &#123;\n                        \"lat\": 34.134496,\n                        \"lng\": -118.3514803\n                    &#125;,\n                    \"start_address\": \"美国加利福尼亚安纳海姆邮政编码: 92802\",\n                    \"start_location\": &#123;\n                        \"lat\": 33.815744,\n                        \"lng\": -117.9225876\n                    &#125;,\n                    \"steps\": [\n                        &#123;\n                            \"distance\": &#123;\n                                \"text\": \"0.3 英里\",\n                                \"value\": 503\n                            &#125;,\n                            \"duration\": &#123;\n                                \"text\": \"1分钟\",\n                                \"value\": 37\n                            &#125;,\n                            \"end_location\": &#123;\n                                \"lat\": 33.8201231,\n                                \"lng\": -117.9228153\n                            &#125;,\n                            \"html_instructions\": \"向\\u003cb\\u003e东北\\u003c/b\\u003e方向，前往\\u003cb\\u003eDisneyland Dr\\u003c/b\\u003e\",\n                            \"polyline\": &#123;\n                                \"points\": \"kskmEdwvnUIEOKQIOGCAUGOEWGYGe@Ia@GQAQAQAQAQ?G?[??@c@?M@U@_@@C?_@D]HyBh@WF_@HC@]Ha@JC@KB]HKDID[DG?EA\"\n                            &#125;,\n                            \"start_location\": &#123;\n                                \"lat\": 33.815744,\n                                \"lng\": -117.9225876\n                            &#125;,\n                            \"travel_mode\": \"DRIVING\"\n                        &#125;,\n                        &#123;\n                            \"distance\": &#123;\n                                \"text\": \"256 英尺\",\n                                \"value\": 78\n                            &#125;,\n                            \"duration\": &#123;\n                                \"text\": \"1分钟\",\n                                \"value\": 6\n                            &#125;,\n                            \"end_location\": &#123;\n                                \"lat\": 33.8207878,\n                                \"lng\": -117.9230963\n                            &#125;,\n                            \"html_instructions\": \"继续直行进入\\u003cb\\u003eDisneyland Dr\\u003c/b\\u003e\",\n                            \"maneuver\": \"straight\",\n                            \"polyline\": &#123;\n                                \"points\": \"wnlmErxvnUUJc@LEBeAX\"\n                            &#125;,\n                            \"start_location\": &#123;\n                                \"lat\": 33.8201231,\n                                \"lng\": -117.9228153\n                            &#125;,\n                            \"travel_mode\": \"DRIVING\"\n                        &#125;,\n                        &#123;\n                            \"distance\": &#123;\n                                \"text\": \"22.3 英里\",\n                                \"value\": 35909\n                            &#125;,\n                            \"duration\": &#123;\n                                \"text\": \"24分钟\",\n                                \"value\": 1459\n                            &#125;,\n                            \"end_location\": &#123;\n                                \"lat\": 34.0256748,\n                                \"lng\": -118.2061502\n                            &#125;,\n                            \"html_instructions\": \"稍向\\u003cb\\u003e右\\u003c/b\\u003e转走\\u003cb\\u003eI-5 N\\u003c/b\\u003e，前往\\u003cb\\u003eLos Angeles\\u003c/b\\u003e\",\n                            \"maneuver\": \"ramp-right\",\n                            \"polyline\": &#123;\n                                \"points\": \"&#125;rlmEjzvnUi@MICEASIcA[AAi@OEAKEGEKC_@KKCCAEASCIAA?EAM?K?CAE@W?A@I?I@MBA?E@I@GBI@A@KBKDEBA@C@GDGDKFc@`@y@p@s@l@A@w@p@_@ZYVo@h@OJWTs@l@oAhA_@ZSRA@?@I`@c@\\\\URc@\\\\e@b@URg@f@KHe@f@YXMN_@^QRSRKJk@n@YXYZSRGHm@n@o@r@a@b@GF_@`@GFaAdA]\\\\WZc@d@SPMPk@l@sAvA[ZQRWXWXOL[\\\\SVMLUTgAnA[`@e@r@GJMROTc@t@Q\\\\OZOZ?@MTQd@IN?BQ`@Qf@ADKXCFIT?@IVGNEPENENCHKf@A@CLCHAHIZCTERCJIb@CPG\\\\EZIh@Kv@ADE\\\\EX?@Ir@Ij@Kr@UrAGd@Kp@AFIf@E^UlAId@CRKf@ERCHIZKb@GVIZIXIVADQh@EJKZABy@pBGNMXOZKT_@x@Yp@CFYn@Sb@GLMXMXMXMXIPSb@Qb@GNc@~@MZ]v@m@rAYl@e@fAa@|@Yn@Q^ABc@bACDe@fAUf@Sb@a@~@Q`@MXKVMXQ\\\\KVGLGNMXOXMZMZMXOXCHIPMXMVO\\\\KVOZO\\\\IRQ^MXMZKREHIRMXIPSb@KVOZGNEJMV?@OZGLIRKTMXMZOZOZKVMXOZMXCH_@t@a@x@OXS`@OXOTQZOTQZMTQZQVS^QXGJw@pAMVCDKNQ\\\\QXILAFOVQ\\\\EHINMZMVGLEHO\\\\?@KVMVCJQ`@Qb@M\\\\KZGNSf@KXMZKZIRm@zAMZKXMV[x@i@nAGPEHITCBM^EJGJMZMZGLYr@M\\\\IPGPO^MZu@lBCFIRYt@Sf@MZEJKVMZADKTM\\\\EJELM\\\\MXEJUj@MXM\\\\MZEJELOZADIPMZEJIPKXQ^IROZMZOZKXMVOZGLELIPO\\\\KTEHIPABYn@GPABA@CFGLEJEHGNGPEFGNGNsA~Cq@~AO\\\\O^IRs@~AMXINQ`@Wh@S^ABa@t@QX]l@QXMTUZKRGHOT[`@INkA|AMPQVKNOR_@f@KNg@r@c@j@_BvBiA|A_@h@SX_@f@c@v@_@n@IPKPABQb@O^M\\\\CFIVW|@A@IZMh@Qv@?@Op@Kd@Op@Ib@Ol@e@dC_@fBQt@ETKd@ABWpAERCRABERK\\\\I^&#123;@fDc@dBIXK\\\\Sn@Wt@KXCHUn@IPKX]z@Yr@[r@[r@Yj@_@x@CDYh@KRIN[j@EJGHMVQXABMTQXm@dAk@|@INA@&#123;@xAu@pAKRMRq@lAo@pAMTIPKVINKTGNINO^EFGPSb@Sb@KTKTGNIRO\\\\GLGN_@v@ADKTKTSd@OZIPk@jAGLQ`@e@~@?@y@jBQ`@ITYn@[z@&#125;@nBOZKVGJWj@mArCSb@Qb@Sd@i@jAw@dBCFc@dA]x@KPO^Yl@Qb@Yl@OZg@bAEFGPCDGLEL]r@Yr@e@bAmAlCyAhD?@KTYl@a@|@Yl@a@~@i@`ACDa@r@OTW`@KNeA~A&#125;BtCy@z@cAlAs@z@CB[`@q@v@gB`C&#125;BlDi@x@[f@a@p@k@hAiAzB&#125;@jBw@tBIRWt@Yr@[|@Sn@e@xAW~@Up@Mb@M`@Qd@[`AY|@Up@Sh@Od@CFO`@ADM\\\\Yx@GP_B~DKTGPsF`MO^u@bBMTi@jAo@xAWl@]p@_@|@GL[r@kCnFGRgArBmDbH_AfBGRS`@OXGLmBzDiBnDGL_AjB]v@IJGJoApCsA|Cu@fBeBhEqAdDoAzCe@lAMXoA|CqAbDIN[x@CFUh@MZuAdD]z@o@dBMX[v@MVA@q@bBk@~Ag@hAITg@hA]t@Sf@Q\\\\&#123;AdDCFqAlCgAxBEJIN_AjBQXc@~@MRyAnCOZqAfCEHMXm@jAo@lAMXS^MV]p@]x@A@IPEJIP_@t@CHOZOXADcAxB?@[n@O\\\\?@a@x@Uh@EHe@bAGJKT_@x@MXEH]r@_@v@Uh@Q^sAvCm@tAYn@GLWd@y@jBUf@ELKVMZMVi@lAc@`AKRaAnBEHs@vAEJq@jAEHQZEFo@bAc@p@[d@GJSZUZMP_@h@QTa@h@qA~A[\\\\MNKLOPc@h@y@~@o@n@gBdBo@l@&#125;A|AEBgAfA[VSTu@p@_@`@SPg@f@SRUTwAvAWTSRURg@h@SPe@f@OLUT_@b@SRSRORUXSRILGHSTUZMRa@j@SXOVQVOVQXINGHS^S^MTCDWf@O\\\\S`@S`@Q`@[p@Ud@e@bAWh@MVMVOXSf@INQ\\\\OZQ^CFEH_@r@_@r@_@p@_@n@QXKNU\\\\SZOVa@j@OTUZu@`ASVA@ORSTSTIJIJQRQRg@f@STUTg@f@i@d@c@`@GD[VOLuAdAuAhAc@ZKHQJKFSLy@f@u@d@]VQJ&#125;@j@i@\\\\QLc@VUNMHu@d@yA|@WLOJm@^cAn@o@`@OJo@`@WNo@^WPm@^UNWNWPA?QLUNWNUNWNWNQJ[TWNEBQJUNUNUNKFIFUNWNWNUNWNWPUNWNUPWLWPWPA?MH_@VCB_@TIDSNULUNWNUNMFIFWLUNULULUNWNE@OJWNWLSLGDQHSLo@^WNGFMFULYP[Rg@\\\\A?UNUNULYP_@VIDo@`@sCfBcC|Ae@XKFGDa@X_B`A]T]RcBlAc@X_@T_@Ty@h@i@^[PSLQLgAv@s@b@&#123;@h@&#123;A~@qBjAeBdA&#123;A~@qBnA_Aj@u@b@_Aj@UNi@\\\\y@`@k@\\\\]Re@Xa@TGDULIFEBCBIDSLC@]R&#123;@h@A@QJ[PSLULm@^k@ZOHQLMHYPWLy@f@C@i@\\\\q@`@ULMHOJSJKFKFULSLULWNKHOHQJ[PUNEBs@^a@VWN[PSLEBg@XKDGDWNULWNWLaAj@[Pc@VIDOJYN[R&#125;@f@KFSL_@TaAj@]Pc@Vk@\\\\IDSLy@d@UNSLC?WNc@V_CtAQJWPWNm@b@KHSL[Vk@d@e@b@]ZQPUTIJUTAB]^OROPGHi@r@EFKNUZYd@g@t@GHQXQXA@ABUZcA~AW`@A@OT[f@KN[f@e@p@OTMROVSZQVOTEHq@bAgA`Bw@lAYd@QVkBtCg@v@QVOTA@INeA~ACDa@n@&#125;@rAu@hAm@`AW`@IJW^KPGH]h@KNc@r@MPEFOTQV]h@GJq@bAEFMR]h@U\\\\[f@MRQVQXQXY`@EFQXCBOVOR?@GHILOTOVGHKPCBGHCFGHIJMR]h@Yb@GHEFKNCBOTQTQT_@d@g@h@WVUTURYVk@d@a@X_@ZOHA@cAl@g@XQHC@SJ_@PGBMFYJSHWHE@QHC?UHC@c@LI@WHE@SDMBKBUFYDA@SDYFWFYFG@OBYFYFu@N&#123;@R]Fa@Ho@NaB\\\\C@]Ha@HOD[FQDq@N[FWF_@FODA?WFKBKBA?UFOBIBYFQBG@YFWFWFOBKBUFYHWHi@Nc@PUHSHOF]NE@a@RMFSJs@`@CBMFYRi@^ULOJGDQLUNe@Zg@\\\\q@d@o@`@q@d@_Al@[Tk@^UNUPA?i@`@i@^c@Z[XUPGFa@^A@OLSRSPSTGFMLSRGDi@h@_A~@YXYZg@f@YXc@`@g@h@g@f@e@d@QRWTe@f@g@d@KJ[\\\\e@d@QPc@`@_@^c@d@g@d@e@f@o@l@YZYXGFuAtA]\\\\y@x@QNYZMNONWVSTQTQTSTQVOTOTa@p@OVILQZ_@n@IJo@dAk@bA]j@ABMPILW^]d@_@d@a@b@]^q@n@[Z[Z_@\\\\k@h@GF_A|@a@b@IF]\\\\_@^&#123;@v@&#123;@x@&#123;@x@a@^w@r@ONc@`@IF]\\\\c@`@ONu@r@_@^q@l@g@f@c@`@w@v@g@d@oAjAm@j@e@d@e@b@e@d@[Xu@r@q@n@ONm@j@YV[Z[ZGDa@`@YXURo@l@a@^UPa@Z_@Xk@^UNWLKFe@TOHEBaAf@YNKD_@Rc@TWN_@Ti@\\\\A@OJ]VA@a@ZYVq@l@aA~@yAtAONWTUT]ZGFm@h@YXSRa@^]\\\\a@\\\\a@`@QNWV[XSRs@n@IHSPm@j@QPYX_@`@_@^e@f@[\\\\UXe@h@e@j@eAnAa@f@IHe@j@UVORc@h@g@j@w@~@SVc@f@OPY\\\\a@h@SZQXQVOXMTMTSb@EHO\\\\Q\\\\Sd@_@p@U^ILOTQVCDMPORORCD]`@IJg@h@e@d@URg@d@e@^ABi@b@OL]\\\\y@r@UP]ZUTWTc@d@SVQVEFIJ[d@a@n@GLCDKRO\\\\GJGLCHSb@O\\\\EPc@fAYz@GNEJKZCDCHWt@Yv@Qf@i@xAYz@k@bBe@rAUn@k@~AYz@KVM^GNIX[~@Sj@IVM^O`@K^[pAQx@ERI\\\\Mj@ETAFI`@ALEPCLAHERETWnAGTMb@K^GNM`@O`@KVQ`@q@pAINCDIRKPWh@GJABUf@ABSb@KVi@zAWp@M\\\\Sl@eAxCo@jBWv@c@rAAD]~@Wt@KZCDQh@KVWt@a@jAA@EN]`ASl@ELIRMd@KXABM`@EPIXMh@Kb@GRADKf@W~AKn@OtAGd@Gz@C`@AHEr@Cj@A`@A^AX?B?^A\\\\?\\\\?@@|@?`@?T?`B?x@?b@?rA?N?~@?~@@~@?|@?\\\\?z@?b@?`@?f@@hA?^?V@p@?^?\\\\?`@?xA?X?D?`@?\\\\?^?\\\\?X?F?`@?\\\\?TAdAA\\\\A\\\\?FAVCb@CVC\\\\Cd@?@?@CVE\\\\C^CPCLCXA@?@EX?BG\\\\CRCLEVABGZGZENAHU|@I\\\\K^GVM\\\\K\\\\ABK\\\\GPOd@ADITIRADKZKZKZMZGVCFKVKZK\\\\KVK\\\\M^CHENKXGNADCFIXADITGNENADGNABGPCFAFGPM^Wv@M\\\\K\\\\Wr@KZIXKZGPQd@IZKXM\\\\ADUp@KZKZKZKZKZCFIRIZKZKXM`@KZCDENKZCFGPM\\\\KZCJGPKXIVABM^CHENKXK\\\\A@K\\\\KXI\\\\IZCHGTIXIZI\\\\ABEPSv@\"\n                            &#125;,\n                            \"start_location\": &#123;\n                                \"lat\": 33.8207878,\n                                \"lng\": -117.9230963\n                            &#125;,\n                            \"travel_mode\": \"DRIVING\"\n                        &#125;,\n                        &#123;\n                            \"distance\": &#123;\n                                \"text\": \"3.6 英里\",\n                                \"value\": 5872\n                            &#125;,\n                            \"duration\": &#123;\n                                \"text\": \"7分钟\",\n                                \"value\": 438\n                            &#125;,\n                            \"end_location\": &#123;\n                                \"lat\": 34.0585201,\n                                \"lng\": -118.2446063\n                            &#125;,\n                            \"html_instructions\": \"稍微向\\u003cb\\u003e左\\u003c/b\\u003e转，进入\\u003cb\\u003eUS-101 N\\u003c/b\\u003e （\\u003cb\\u003eLos Angeles N\\u003c/b\\u003e/\\u003cwbr/\\u003e\\u003cb\\u003eCivic Ctr\\u003c/b\\u003e的路标）\",\n                            \"maneuver\": \"turn-slight-left\",\n                            \"polyline\": &#123;\n                                \"points\": \"mstnElcnpUBV?@ABCNIZI\\\\IZERCHGXADCFENIXAFGTM`@KXENOb@M\\\\Yv@KXM`@&#123;@bCQd@Od@Od@Qh@EJUl@Of@Ul@M^Ob@KXQh@KZITWr@Ob@Qf@GPYx@Of@M\\\\Sj@M\\\\Ur@A?M`@i@zAm@hBKZSh@IXKVKZKZKXMZABm@|AM\\\\GLq@vAMTIPKRILYh@IPS\\\\QVSZMRYb@QTQVQTA@IJEFSTQTIJ_@`@STGDi@j@SRC@GDMHURa@\\\\MLg@^m@`@]TKDGDIDQHa@RWJSFq@Tg@LWHC?g@He@H]Bo@Be@@]?G?W?SAQAO?QASE]E&#123;@KeBIi@Am@?q@@wBJo@DG?[@]?G?E?S?WAa@AQAMACA[C[Eu@KyAUQCw@IcAO&#125;CU]Ak@Ae@?wA@iB@qA@E?_BBe@@A?mABe@FwAHcAHm@Fm@JyAXy@RQFSFYHq@T_@LEBG@GBIBk@VGBIDk@VMDCBKBABE@IB]PUHm@TCByAj@w@ZkAd@KDULWNSJOJMLOLMNKJMRQVILKLGNINQ^GLM\\\\Sn@Eb@Ef@IRAf@Cb@C\\\\ATEz@?HADEh@CTALALE`@QzAMdAOpAEf@OxB?@KpAMzAKpAOtBGp@Gp@?FATAJK|ACRAT?TARA`@CRAXARAJAFCVGfBOvBEj@Af@Ab@@L?\\\\@V@X?D@PDbA?j@?RA`@?JAVAPAJGp@Ml@I^Oj@M^K^CHO`@EHWf@MV[n@GNU\\\\[n@SZSZGLs@vAU`@[j@Yh@&#123;@zAu@vAU`@k@dAS`@ILe@|@]n@QZ]p@MRy@|As@fASZs@fA\"\n                            &#125;,\n                            \"start_location\": &#123;\n                                \"lat\": 34.0256748,\n                                \"lng\": -118.2061502\n                            &#125;,\n                            \"travel_mode\": \"DRIVING\"\n                        &#125;,\n                        &#123;\n                            \"distance\": &#123;\n                                \"text\": \"7.4 英里\",\n                                \"value\": 11885\n                            &#125;,\n                            \"duration\": &#123;\n                                \"text\": \"10分钟\",\n                                \"value\": 591\n                            &#125;,\n                            \"end_location\": &#123;\n                                \"lat\": 34.12228899999999,\n                                \"lng\": -118.3404961\n                            &#125;,\n                            \"html_instructions\": \"靠\\u003cb\\u003e左\\u003c/b\\u003e继续沿\\u003cb\\u003eUS-101 N\\u003c/b\\u003e行驶\",\n                            \"maneuver\": \"keep-left\",\n                            \"polyline\": &#123;\n                                \"points\": \"w`&#123;nExsupUc@n@QRSVe@n@aAnASVIJST[`@UTk@j@EDSROJYTCBs@j@MJc@\\\\SPMJe@`@UPq@j@UP]X_@Zu@l@CBWRSPc@\\\\GDWTUPe@`@[XUROR[ZEDKNY^UZW^g@x@]h@ILIJm@`ASXQNc@n@ITMPQVEFKPOVSVGJINc@n@A@U`@UZQVEHA@W`@SZSZCDa@p@CFKPIP]n@GLi@lAGLKVKVCDKXKVCJGNIRENKXGTELEPGR?@ITIZQt@CHA@?@YhACFSz@CJYfAMd@Kd@WbA[lAMh@?@]pAAFA@WdAWbAGVSr@ADa@bBGRI^[nACHQr@Mf@]nAEPIZGNOh@Od@GTKVe@vA_@dASn@Ob@Wt@[~@O`@AB_@fAOd@KZUn@Qf@Qh@c@pAUt@Yz@Uv@c@vAa@tASn@ELIVKXOf@MZOb@EJCDM\\\\CFEHABYr@GNO\\\\IRQ`@KZO^g@rAOh@Y~@GPUx@ELCLCFIZI^Kb@GTCJKb@G\\\\Mj@YzAWrAGXI`@G^Kd@Kl@GZIZSfAQ`AMl@Ov@?BI`@GZG\\\\GZEPAFQx@EXI^ERCPIb@EPG^Id@Gb@Kh@Gd@O`ACVKp@Kv@_@lCAHKj@Kt@EZGb@ETCTCPSpAIj@Kx@U|AKt@CNAHE`@EXGn@Gh@Ed@G`@ARCVIn@Ef@Ih@ANGd@EVGj@ERETG\\\\GZETETCLERGTI\\\\Mf@W~@GTEJEPGPELM^Sf@ABKVABCFEHO\\\\GNSb@MZMVQ^GPO\\\\Q`@[r@KVMXOZGLELMXMZWp@Yr@MZM\\\\M\\\\IVWp@MZKVCJGNM\\\\IRUp@Qd@Yx@_@bAg@vAWp@ADKTK\\\\MZKVKZO\\\\EJEHCDIRO^O\\\\INGNEHGLCDm@hAS`@QVADU^QZYd@GJaA`BKLg@z@Yb@Wb@KPU^c@p@a@r@a@p@SZ&#123;@vA_@l@_@l@U^OV_@j@W^KNa@f@KLOPQPQR[Z]\\\\k@f@q@j@i@^mAx@_@RSLYN_CjAyBjA[N&#123;@d@_@PmAn@i@XSJWNCBSLUNUPUPe@`@CBa@b@i@j@STQVQRSXOVOVOXMRQ\\\\S\\\\c@z@U`@QXMXOXQXMVOVOVOX]n@QZKRCDOX]n@QZOTOXQVOVQTQTSXQRSVQRSTSTSRSRIHIFUTOLSPOJKHUPSNWPULA@SL&#125;@f@OHGBCBIBQJULUJWLs@\\\\UJWLULWLWL[NQHWNWJ[PSHWLULWLWLWLWLWJWNUJ[NQHm@\\\\SJCBUNWPGDMHUPGHKHQPURSTSRQTMPUZSZKNQZEFIPOXMXMXMZKXKZIXM^GXIZI^G\\\\GV?FGXE^E\\\\E\\\\C^C\\\\AVCd@A\\\\?ZA^?\\\\?\\\\AZ?D?XAl@?t@Ah@Aj@A\\\\ALC\\\\C^C\\\\E^ADE`@ETEZGVERCLIZI\\\\Ux@KZGPQ`@MZMXOXMVQ\\\\OXCDa@z@mA`CEHOXOXMXINKTCDEDMXABINIPILQ^KROXMVOXGJUf@MTA@OXMXOXMVOZOXIPKPOZOXKREHMVm@jAMXQZMVMVOZOVOXMX_@r@OVKRCDQVOVOTQV[b@KJORSTQTWTQPSRURUPA@QLWPGDMHWNUNWJ?@WLWJWJUH]LYHWFUFA@YFYFYFWFWH[F[HUDYHYFUF[FYFWHUD&#123;@RSDODWFYFWFYFSDE@YDWFWF[DYFYFYDI@ODYDWDMBKBYDYFYFOBa@JYFWHYHWHYHWHWHYJWJWJWJYLWJWLULWLWLWLUNIDMFQLC@SLSNc@XMHUPUPWPSPSPQNC@SRUPSRSRUTQRSRSTQRSTSV\"\n                            &#125;,\n                            \"start_location\": &#123;\n                                \"lat\": 34.0585201,\n                                \"lng\": -118.2446063\n                            &#125;,\n                            \"travel_mode\": \"DRIVING\"\n                        &#125;,\n                        &#123;\n                            \"distance\": &#123;\n                                \"text\": \"0.1 英里\",\n                                \"value\": 189\n                            &#125;,\n                            \"duration\": &#123;\n                                \"text\": \"1分钟\",\n                                \"value\": 9\n                            &#125;,\n                            \"end_location\": &#123;\n                                \"lat\": 34.1235942,\n                                \"lng\": -118.3417715\n                            &#125;,\n                            \"html_instructions\": \"下\\u003cb\\u003e11A-Exit 11A\\u003c/b\\u003e出口，前往\\u003cb\\u003eBarham Blvd\\u003c/b\\u003e\",\n                            \"maneuver\": \"ramp-right\",\n                            \"polyline\": &#123;\n                                \"points\": \"iogoEbkhqU[@?@GDQTWXGFc@d@_@`@QRc@f@IHOPKNMJ\"\n                            &#125;,\n                            \"start_location\": &#123;\n                                \"lat\": 34.12228899999999,\n                                \"lng\": -118.3404961\n                            &#125;,\n                            \"travel_mode\": \"DRIVING\"\n                        &#125;,\n                        &#123;\n                            \"distance\": &#123;\n                                \"text\": \"0.5 英里\",\n                                \"value\": 765\n                            &#125;,\n                            \"duration\": &#123;\n                                \"text\": \"1分钟\",\n                                \"value\": 56\n                            &#125;,\n                            \"end_location\": &#123;\n                                \"lat\": 34.1290257,\n                                \"lng\": -118.3467626\n                            &#125;,\n                            \"html_instructions\": \"走\\u003cb\\u003eCahuenga Blvd E\\u003c/b\\u003e\",\n                            \"maneuver\": \"merge\",\n                            \"polyline\": &#123;\n                                \"points\": \"mwgoE`shqUUVSXq@|@OPY\\\\Y\\\\Y\\\\MNGHCBA@KLKLCBKJKJSPKJIFEDEBGFGDIFKFGFQJC@QJWNEBIFA?[PIDODe@T?@_@Pa@R_@PYNC@]RSNg@f@_AbA[Zg@h@MNUTYZ[\\\\EDIHQNMLONIHA@IJEFOP\"\n                            &#125;,\n                            \"start_location\": &#123;\n                                \"lat\": 34.1235942,\n                                \"lng\": -118.3417715\n                            &#125;,\n                            \"travel_mode\": \"DRIVING\"\n                        &#125;,\n                        &#123;\n                            \"distance\": &#123;\n                                \"text\": \"0.4 英里\",\n                                \"value\": 705\n                            &#125;,\n                            \"duration\": &#123;\n                                \"text\": \"1分钟\",\n                                \"value\": 53\n                            &#125;,\n                            \"end_location\": &#123;\n                                \"lat\": 34.1338788,\n                                \"lng\": -118.3515796\n                            &#125;,\n                            \"html_instructions\": \"继续前行，上\\u003cb\\u003eW.C. Fields Dr\\u003c/b\\u003e\",\n                            \"polyline\": &#123;\n                                \"points\": \"myhoEfriqUS\\\\QPGHKLIHA@IJA?ABGFCBGDCDGFEDEFEBGFEDEDEDCDEBEFEBEFEDIHCBCBCBQPCBA@A@g@d@MJQPGDEDEDCBEBCBEBMLSLYNCBA@C@GDKFYPMDk@^EBWP]TQLMHGDWNWXc@d@MPU^GHINCBABQZGLA@ILIJEHCFEDCBCBCBC@EDEBEBC@EDCBEBEBCB?@CBC@CBEFCBCDEDEFINUb@\"\n                            &#125;,\n                            \"start_location\": &#123;\n                                \"lat\": 34.1290257,\n                                \"lng\": -118.3467626\n                            &#125;,\n                            \"travel_mode\": \"DRIVING\"\n                        &#125;,\n                        &#123;\n                            \"distance\": &#123;\n                                \"text\": \"256 英尺\",\n                                \"value\": 78\n                            &#125;,\n                            \"duration\": &#123;\n                                \"text\": \"1分钟\",\n                                \"value\": 8\n                            &#125;,\n                            \"end_location\": &#123;\n                                \"lat\": 34.134496,\n                                \"lng\": -118.3514803\n                            &#125;,\n                            \"html_instructions\": \"向\\u003cb\\u003e右\\u003c/b\\u003e转，进入\\u003cb\\u003eUniversal Studios Blvd\\u003c/b\\u003e\\u003cdiv style=\\\"font-size:0.9em\\\"\\u003e目的地在左侧\\u003c/div\\u003e\",\n                            \"maneuver\": \"turn-right\",\n                            \"polyline\": &#123;\n                                \"points\": \"wwioEjpjqUQNA@C@A@C@C?A?A?C?C?AAC?AAAAA??AA?CAEAC?A?A?A?A?A?A?OQCAAAECIE\"\n                            &#125;,\n                            \"start_location\": &#123;\n                                \"lat\": 34.1338788,\n                                \"lng\": -118.3515796\n                            &#125;,\n                            \"travel_mode\": \"DRIVING\"\n                        &#125;\n                    ],\n                    \"traffic_speed_entry\": [],\n                    \"via_waypoint\": []\n                &#125;\n            ],\n            \"overview_polyline\": &#123;\n                \"points\": \"kskmEdwvnU&#125;B&#123;@iDa@&#125;CFuGvAiCl@eAZeAXi@MOEcCw@e@Q&#123;A[qAB_ARwAbAaFfEoGrFABI`@c@\\\\y@p@oBhBmBpBmDvD&#123;OxP&#123;EjFmDzFqCpH&#123;AvHuC~RaAvEeAhDaH|OiKxUeMfY&#125;D~ImC|FeCnE_GfK&#123;DnJ_Ob_@oJnUcNf[uC`FuDhFqIjLwBhDi@jA&#125;AbF&#125;BzKcBbIkCpKsBbGgElJyIlOiDvGcBvDeFbLqLjXcJjSiM~XuAzBcEtF&#125;BhCeCxCkHpKuEbJsBrFqDdLeCpHoChHwGhO&#123;FjMaOlZ_JpQaFbLmHxQ&#125;FrNoGvOeChG_D`HcHpNyLbVkHvOwL|WiEhJ&#125;ErIoDdFeHfIsTdTqErEiC~CqCjE&#125;BlE&#125;GvNgElHsDdF&#123;ChDuGvFgH~EqFlDmRpLsHvEmSfMc_@hUeJbGqOrJmTpMiUbNaXpOsPvJkFjE&#125;BjCgI|LqLxQ&#125;Yhd@yKlPuB|B&#125;BjBgEfC&#125;FpBgZlG&#125;FlAoExAmDfByOlKiEbDeC`CmOlOoPpPyCdDaCpDeEbH_BxBmCnCyFrF&#125;HnH&#125;RdR&#123;NdN&#125;EzCiFpCiEfDmH~GwLdLePfR&#123;DfF&#123;BtEcCxDgEpEmFtEgCtCuBtDyB|FkJbXiCpIcAdFeA|Eq@rByAzCsApCyFzOuGnRiArDc@fB_AlGc@nHAzEBhY@dOKxFYtDcAhGcDvKsCpIqIlWqCnIkCtI[nAOpAu@`D_F`OaPje@&#125;CvHwBzD&#125;BdD&#123;ChD&#123;CdCuDrBeCt@oBViE@_CYoFIkGRkE_@gFs@mGYoNNoFb@aEx@gDfAqCjAqEjBeDtAiAt@gB`Cq@zAYrAEf@S|BI`BcApJqBdYSbD_@rH@fBFbFMfBu@xCoBtEgExHqGrL&#123;ApCuDhGcFtGeDbDsMpK&#125;CpC&#123;DpFuCjEgBnCiG`KmBpEu@|BcDjMeFlSuBbImCjIyI~W_ClHeAhCyClIkAnEiEpT&#125;BxLgDhUiC`So@zFs@hEqAbFcAnC&#125;E~KmFpNuFdOqBdEsDnGeLbReDhEwClCkDzByM~GyChBaBzAaBlB&#123;CnFuGvLkCxDiCpCwC~BoCzAkKfFuJdF&#123;BpBaCfDeBjEaAlEa@tFE`FSrGk@rDkBxFyDvHwDrH&#123;EnJmGxLoCtDuCbCkCvAoDfAoLlC&#123;IfBiDl@oEnAaEdBkCvAqDhCqCfCkApAg@l@[Bq@t@&#125;AbBaCpCiDfEyCnCiHrD&#125;AlAqCxC&#123;B|BoCdDyFtFaEhC&#123;BxAwBrC_A|Ae@\\\\a@\\\\&#125;@vAc@VUEk@WUM\"\n            &#125;,\n            \"summary\": \"I-5 N和US-101 N\",\n            \"warnings\": [],\n            \"waypoint_order\": []\n        &#125;\n    ],\n    \"status\": \"OK\"\n&#125;\n如何使用路况信息\n\ndriving 模式\ndeparture_time=now 或者未来\n需要为航点添加via: 前缀\n不能停靠航点\n\n显示多条路径\nthis.googleMap = new google.maps.Map(document.getElementById('googleMapNearBy'), &#123;\n    zoom: 10,\n    center: centerLocation,\n    disableDefaultUI: true,\n    zoomControl: true,\n    scaleControl: true,\n    fullscreenControl: true,\n    clickableIcons: false,\n    styles: [\n        &#123;\n            featureType: 'poi',\n            stylers: [&#123; visibility: 'off' &#125;]\n        &#125;\n    ],\n    mapId: \"6fd4c8a97d7e1f93\"\n&#125;);\n// 需要创建多个 directionsRenderer 实例\nconst directionsRenderer = new google.maps.DirectionsRenderer();\ndirectionsRenderer.setMap(this.googleMap);\nconst directionsRenderer2 = new google.maps.DirectionsRenderer();\ndirectionsRenderer2.setMap(this.googleMap);\nASCII 转码\n\n\n\n字符\nUTF-8\nWindows-1252\n\n\n\n\n|\n%7C\n%7C\n\n\n\n","slug":"google-map-directions","date":"2024-07-03T08:36:04.918Z","categories_index":"","tags_index":"google map","author_index":"Kidwen"},{"id":"f95226d9f0855b378f638cf659474409","title":"cloudflare work 随机获取bing图片","content":"Cloudflare Workers 是一个无服务器计算平台，允许开发人员在 Cloudflare 的边缘网络上运行 JavaScript 代码。它提供了强大的功能，适用于各种应用场景，包括动态内容生成、API 代理、负载均衡、认证和缓存管理等。\n本文介绍使用cloudflare work搭建一个可以随机获取bing图片的api\nCloudflare work 代码\naddEventListener('fetch', event => &#123;\n    event.respondWith(handleRequest(event.request));\n&#125;)\n\nasync function handleRequest(request) &#123;\n    const url = new URL(request.url);\n    const params = url.searchParams;\n\n    // 判断是否随机调用\n    let gettime;\n    if (params.get('rand') === 'true') &#123;\n        gettime = Math.floor(Math.random() * 8) - 1;\n    &#125; else &#123;\n        // 若不为随机调用则判断是否指定日期\n        let gettimebase = params.get('day');\n        if (!gettimebase) &#123;\n            gettime = 0;\n        &#125; else &#123;\n            gettime = parseInt(gettimebase, 10);\n        &#125;\n    &#125;\n\n    // 获取Bing Json信息\n    const apiUrl = `https://www.bing.com/HPImageArchive.aspx?format=js&#x26;idx=$&#123;gettime&#125;&#x26;n=1`;\n    const response = await fetch(apiUrl);\n    const data = await response.json();\n\n    // 提取基础url\n    const imgurlbase = \"https://www.bing.com\" + data.images[0].urlbase;\n\n    // 判断是否指定图片大小\n    const imgsizebase = params.get('size');\n    const imgsize = imgsizebase || \"1920x1080\";\n\n    // 建立完整url\n    const imgurl = `$&#123;imgurlbase&#125;_$&#123;imgsize&#125;.jpg`;\n\n    // 获取其他信息\n    const imgtime = data.images[0].startdate;\n    const imgtitle = data.images[0].copyright;\n    const imglink = data.images[0].copyrightlink;\n\n    // 判断是否只获取图片信息\n    if (params.get('info') === 'true') &#123;\n        return new Response(JSON.stringify(&#123; title: imgtitle, url: imgurl, link: imglink, time: imgtime &#125;), &#123;\n            headers: &#123; 'Content-Type': 'application/json' &#125;\n        &#125;);\n    &#125; else &#123;\n        // 若不是则跳转url\n        return Response.redirect(imgurl, 302);\n    &#125;\n&#125;\nBing api 参数介绍\n接口地址\n\n\n\n参数\n性质\n说明\n\n\n\n\nformat\n可选\n取值范围 [js, xml]，接口将根据此参数返回对应的 XML 或者 JSON 格式的数据，缺省（或缺失）将默认返回 XML 文档数据格式。\n\n\ncc\n可选\n国家（含地区）代码（Country Code）的英文缩写，表示获取相应地区的必应美图（需要国外主机，国内主机请求一律返回中国区的必应美图），目前已知的可取值范围 {ar、at、au、be、br、ca、ch、cl、cn、de、dk、es、fi、fr、hk、ie、in、it、jp、kr、nl、no、nz、ph、pt、ru、se、sg、tw、uk}，对应的地区请对照此列表 → 传送门，缺省（或缺失）将自动根据请求源 IP 所在的地区返回相应地区的美图信息（划重点，并非每个地区都有属于自己独一无二的美图，未预设美图的地区将直接引用国际版 Bing 美图。另外在配合国外主机使用此参数时抓取信息时，需要使用国际版或其它地区的必应首页地址，例如“www.bing.com”，才能获取到相应“cc”地区的美图，否则一律返回中国区的美图信息。国家（含地区）代码（Country Code）的英文缩写，表示获取相应地区的必应美图（需要国外主机，国内主机请求一律返回中国区的必应美图），目前已知的可取值范围 {ar、at、au、be、br、ca、ch、cl、cn、de、dk、es、fi、fr、hk、ie、in、it、jp、kr、nl、no、nz、ph、pt、ru、se、sg、tw、uk}\n\n\nidx\n可选\n取值范围 [-1, 7] 之间的整数，表示 {明天、今天、昨天、前天、三天前、依此类推……} 的图片，缺省（或缺失）则默认为“0”，表示今天的美图。\n\n\nn\n必选\n缺省（或缺失）将返回 null（空值），导致无法获取美图信息。取值范围是[1,8]之间的整数，表示从“idx”指定的日期开始往前推共“n”张美图信息。\n\n\nvideo\n可选\n取值范围 [0, 1]，缺省（或缺失）则默认为“0”，则不返回相应的流媒体信息（音频/视频），并不是每天都有流媒体视音频的，需要根据返回的字段键值对做判断。\n\n\n\n","slug":"bing-rand-image","date":"2024-06-11T03:50:02.722Z","categories_index":"TOOL","tags_index":"cloudflare,bing","author_index":"Kidwen"},{"id":"b28fd708a6b0cdabb2826b2e3d8e93bc","title":"一元加运算符","content":"一元加（+）对其操作数进行强制数字转换，对于大多数没有 @@toPrimitive 的对象，这意味着调用其 valueOf()。但是，如果对象没有自定义的 valueOf() 方法，则基本实现将导致忽略 valueOf()，而使用 toString() 的返回值。\n一元加结果\n+new Date(); // 当前时间戳；与 new Date().getTime() 相同\n+&#123;&#125;; // NaN（toString() 返回 \"[object Object]\"）\n+[]; // 0（toString() 返回一个空的字符串列表）\n+[1]; // 1（toString() 返回 \"1\"）\n+[1, 2]; // NaN（toString() 返回 \"1,2\"）\n+new Set([1]); // NaN（toString() 返回 \"[object Set]\"）\n+&#123; valueOf: () => 42 &#125;; // 42\nSymbol.toPrimitive\nSymbol.toPrimitive 是内置的 symbol 属性，其指定了一种接受首选类型并返回对象原始值的表示的方法。它被所有的强类型转换制算法优先调用。\nhint 参数的取值是 &quot;number&quot;、&quot;string&quot; 和 &quot;default&quot; 中的任意一个。\n&quot;number&quot; hint 用于强制数字类型转换算法。&quot;string&quot; hint 用于强制字符串类型转换算法。&quot;default&quot; hint 用于强制原始值转换算法。\nconst object1 = &#123;\n  [Symbol.toPrimitive](hint) &#123;\n    if (hint === 'number') &#123;\n      return 42;\n    &#125;\n    return null;\n  &#125;,\n&#125;;\n\nconsole.log(+object1);\n// Expected output: 42\n// 一个没有提供 Symbol.toPrimitive 属性的对象，参与运算时的输出结果\nconst obj1 = &#123;&#125;;\nconsole.log(+obj1); // NaN\nconsole.log(`$&#123;obj1&#125;`); // \"[object Object]\"\nconsole.log(obj1 + '') // \"[object Objext]\"\n\n// 接下来声明一个对象，手动赋予了 Symbol.toPrimitive 属性，再来查看输出结果\nconst obj2 = &#123;\n    [Symbol.toPrimitive](hint) &#123;\n        if(hint === 'number') &#123;\n            return 10;\n        &#125;\n        if(hint === 'string') &#123;\n            return 'hello';\n        &#125;\n        return true;\n    &#125;\n&#125;;\nconsole.log(+obj2); // 10 - hint 参数值是 'number'\nconsole.log(`$&#123;obj2&#125;`); // 'hello' - hint 参数值是 'string'\nconsole.log(obj2 + ''); // \"true\" - hint 参数值是 'default'\nSymbol.prototype[@@toPrimitive]\n[@@toPrimitive]() 方法可将 Symbol 对象转换为原始值。\nJavaScript 调用 [@@toPrimitive]() 方法将一个对象转换为原始值表示。你不需要自己调用 [@@toPrimitive]() 方法；当对象需要被转换为原始值时，JavaScript 会自动地调用该方法。\nconst sym = Symbol(\"example\");\nsym === sym[Symbol.toPrimitive](); // true\n\n","slug":"unary-plus","date":"2024-04-25T05:48:28.764Z","categories_index":"JAVASCRIPT","tags_index":"javascript","author_index":"Kidwen"},{"id":"f3b0ad915ecd5edf3452c4d2cf36b427","title":"[转载]Serv00搭建各种服务","content":"这个平台是个 Virtual Host ，没有 Root ，还是 FreeBSD 的系统，不是 Linux ，不太好用。但是优点是隔离性差， Memory 和 vCPU 能短时间内超过 100% 进行调用。\n面板自带功能\n域名\nServ00 上如果想要使用自己的域名，有两种方式，一种是通过 Cloudflare 提供的 Argo 隧道，不仅能绑域名，免配置 ssl ，还可以享受 Cloudflare 的免费 CDN 提速。第二种就是直接使用面板内自带的 DNS 服务器功能绑定自己的域名。\n在 Panel 中进入 DNS zones 选项卡，使用 Add new zone 功能添加自己的域名或者自己的域名的子域，然后在 Zone list 中找到刚刚添加的域名，点击 Edit 查看 DNS 记录，把当中列出的全部记录添加到自己的域名的 DNS 记录中即可完成域名的绑定。\nServ00 本身对于绑定在其上的域名提供了许多的服务支持，这里所说的绑定在Serv00上的域名包括自己绑定的自己的域名，以及 Serv00 在注册账户时赠送的域名 USERNAME.serv00.net ，其服务包括免费的一键申请式的 SSL 证书、域名邮箱、 DNS 管理等多种功能。\nSSL证书申请\n在 Panel 中进入 WWW websites 选项卡，点击 Manage SSL certificates ，在你需要申请 SSL 证书的域名的 A 记录指向的那个 IP 地址右侧点击 Manage ，再点击 Add certificate ， Type 选择 Generate Let’s Encrypt certificate ，Domain 选择要申请 SSL 证书的域名，再点击 Add 即可。\n域名邮箱\nPanel 中进入 E-mail 选项卡，注册账号后会自动注册一个域名邮箱，用户名是 USERNAME@USERNAME.serv00.net 是 Serv00 的账户密码。可以使用 Add new e-mail 功能新建邮箱账户。\n也可以在 Add new alias 功能中新建别名邮箱，其别名邮箱功能也提供了和 Cloudflare 一样的 Catch-all 的 Advanced settings 选项，用来批量注册东西十分方便。\n目前我的测试中，似乎没有在 Manage whitelist 中添加进白名单的域名邮箱发来的邮件全部都会被识别为垃圾邮件。所以有需要的话可以在 Manage whitlist 中添加你需要接受邮件的邮箱的域名，比如 qq.com 、 gmail.com 等等。\n如果绑定了自己的域名，想要使用自己的域名配置域名邮箱的话，要在 Domain list 中找到自己的域名，点击最右边的 DKIM ， action 选择 Add DNS record automatically ，然后 Sign domain 以注册域名，使得新的域名邮箱能够通过一些邮件接收服务器的验证。\nOpen web client 功能就可以进入邮箱的登录页面了，其使用方法与大多数的邮箱相同，不再赘述。\nDNS管理\nDNS zones 选项卡中在自己绑定的域名右侧点击 Edit ，即可查看当前域名的所有 DNS 记录，在 Add new record 中可以手动添加新的 DNS 记录，与大多数的域名服务商提供的 DNS 管理的功能类似。\nProxy\nWWW websites 选项卡中可以根据语言不同添加多种网站，其中 PHP 的 eval() function 和 exec() function 都要在添加完网站后，在Manage &gt; Details 中打开。不同类型的网页其 Details 中的选项也都有差异，可以按需查看配置，这里重点讲一下 Proxy 类型指向自己的应用程序监听端口的配置。\nAdd new website 功能中， Domain 填写自己的域名或者 serv00 分配的域名，或者它们的子域，展开 Advanced settings， Website type 选择 Proxy ，Proxy target 选择 localhost ， Proxy port 选择自己的应用监听的端口，其他选项留空或者保持默认，点击 Add 即可。接下来就能使用刚刚填写的域名访问自己部署的对应端口的应用了。如果需要 https 访问，再按前文的步骤去申请 SSL 证书即可。\n运行自己的应用\nAdditional services 选项卡中找到 Run your own applications 项目，将其设置为 Enabled 即可。如果不开启这一项，自己的用户目录下的所有文件都无法添加可执行权限。\nFile manager\n文件管理，有一定的在线编辑和预览的功能，兼具文件的上传下载，删除新建等各种管理功能，十分便利。\nPort reservation\n需要使用端口都得在这申请。\n数据库\nServ00 提供了 MySQL 、 PostgreSQL 、 MongoDB 三种数据库，可以按需新建数据库、数据库用户。同时， Serv00 还提供了三种数据库的 webui ，十分便利。\n需要注意的是，所有数据库在新建时，其用户名和数据库名都有一个 mxxx_ 的前缀，在使用时容易被忽视。\nCron jobs\nCron jobs 选项卡提供了一些计划性任务的设置功能，在这里可以设置开机自启任务，或者定时循环任务，当然常用的还是开机自启任务的设定， Specify time 选择 After reboot 即为开机自启。\n部署应用前的一些准备工作\n在部署自己的应用之前，我建议提前安装好 pm2 以及 Cloudflared （可选）。前者是进程管理工具，用来方便开机自启，以及程序崩溃后自启，查阅进程运行情况等等。后者是 Cloudflare 的 Argo 隧道客户端，用它也可以给自己部署的应用加域名。特别是 Uptime Kuma ，更加推荐使用 Cloudflared 加域名，而不建议使用面板自带的 Proxy 。\nPm2\n这个是重中之重，如果不是成功安装了 pm2 ，我甚至不会尝试探索 Serv00 这个玩具有什么用，所以 pm2 的安装方法记录在开头。\n在 SSH 连接 serv00 之后，直接使用一键脚本安装 pm2 ：\nbash &#x3C;(curl -s https://raw.githubusercontent.com/k0baya/alist_repl/main/serv00/install-pm2.sh)\n\n\n\n\n\n\n\n\n\n如果安装完成后执行 pm2 提示命令未找到，你可以断开 SSH 连接，再重新连接，即可。\nCloudflared (alist 中有实际操作)\nCloudflared 官方仓库并没有构建 FreeBSD 系统上能够使用的二进制文件，但是同样的，我找到了第三方的构筑。使用第三方构筑的二进制文件，就能愉快的使用隧道了。\n关于 Cloudflared 是什么，有什么用，ARGO_TOKEN 如何获取等部分，这里不再赘述，详细可以查看我的关于 CodeSandbox 和 Hax 的文章。\n创建并进入Cloudflared 的工作目录：\nmkdir -p ~/domains/cloudflared &#x26;&#x26; cd ~/domains/cloudflared\n下载 Cloudflared：\nwget https://cloudflared.bowring.uk/binaries/cloudflared-freebsd-latest.7z &#x26;&#x26; 7z x cloudflared-freebsd-latest.7z &#x26;&#x26; rm cloudflared-freebsd-latest.7z &#x26;&#x26; mv -f ./temp/* ./cloudflared &#x26;&#x26; rm -rf temp\n测试运行：\n./cloudflared tunnel --edge-ip-version auto --protocol http2 --heartbeat-interval 10s run --token ARGO_TOKEN\n\n\n\n\n\n\n\n\n\n其中 ARGO_TOKEN 要替换成自己的。确定运行没有问题后，按 Ctrl+c即可停止运行。\n使用 pm2 启动 Cloudflared：\npm2 start ./cloudflared -- tunnel --edge-ip-version auto --protocol http2 --heartbeat-interval 10s run --token ARGO_TOKEN\n\n\n\n\n\n\n\n\n\n其中 ARGO_TOKEN 要替换成自己的。\n接着去 CLoudflare 的面板中设置域名对应端口，即可使用域名访问自己搭建的服务了。\n安装 go1.22\n\n\n\n\n\n\n\n\n\n如果你有安装自己使用 go build 构建的需求，你可以选择安装最新的 go1.22 ，这里记录其安装过程。\n由于 Serv00 服务器上并未提供 go1.22 ，只提供了 go1.20.3 ，无法正常进行构建工作，所以需要手动安装 go1.22 环境。\n# 创建安装目录\nmkdir -p ~/local/soft &#x26;&#x26; cd ~/local/soft\n# 下载编译好的 go1.22 的程序包\nwget https://dl.google.com/go/go1.22.0.freebsd-amd64.tar.gz\n# 解压\ntar -xzvf go1.22.0.freebsd-amd64.tar.gz\n# 删除压缩文件\nrm go1.22.0.freebsd-amd64.tar.gz\n# 修改 .profile 文件\necho 'export PATH=~/local/soft/go/bin:$PATH' >> ~/.profile\n# 使 .profile 的修改生效\nsource ~/.profile\n# 检查 go 版本\ngo version\n部署自己的应用\n\n\n\n\n\n\n\n\n\n关于设定 PHP 版本、插件、参数等配置均可参考文档的 .htaccess 部分进行配置，由于 PHP 的应用部署实在是太简单，故本文不会过多介绍。\nWordPress\n实际上在 serv00 的文档中有搭建网站的示例，没错，示例就有 WordPress ，实际上 WordPress 确实可以搭建，十分简单好用。这里不做过多介绍，按照文档一步步操作即可。\n除了 WordPress 外，文档中还详细介绍了 Redis、Memcached、Imapsync、WP-CLI、Tomcat 等服务的搭建方法，有需求的都可以照着抄。\nKodBox\n虽然 Serv00 能够部署 KodBox，但是实在是不太好用。最直观的感受就是卡，因为 KodBox 运行期间需要调用多个 PHP 组件，而 Serv00 限制同时处理三个 PHP 进程，所以显得特别慢。其次， Serv00 没有 Root 权限，部分 PHP 插件没有安装，也无法安装，导致有一些 KodBox 的插件无法正常运行。\n当然如果只是图新奇搭一个玩玩，也是可以的。下面是步骤：\n首先在 Panel 中 Add a New Website ：\n\n\n\nKey\nValue\n\n\n\n\nDomain\nxxx.USERNAME.serv00.net（也可以把原有的USERNAME.serv00.net删掉后重新添加）\n\n\nWebsite Type\nPHP\n\n\n\n添加完新站点后，继续点击上方的 Manage SSL certificates ，接着在出口 IP 的右侧点击 Manage ，再点击 Add certificate ：\n\n\n\nType\nDomain\n\n\n\n\nGenerate Let’s Encrypted certificate\n与刚刚添加的站点域名保持一致（如果是原有的USERNAME.serv00.net ，可以省略此步）\n\n\n\n接着SSH登入，并进入刚刚你新建的域名目录下的 public_html 路径下：\n# 安装KodBox\nbash &#x3C;(curl -s https://pan.rappit.site/d/shell/kodbox1.49/serv00-kodbox-install.sh)\n然后去 Panel 中的 MySQL 选项卡，新建数据库和用户，用以接入 KodBox 。再去 WWW Websites 选项卡中找到 用户名.serv00.net ，点击右侧的 Manage &gt; Details 进入设置，把 GZIP compression、Allow PHP eval() function、Allow PHP exec() function 三个功能打开。\n然后使用浏览器访问你的 KodBxo 的域名，进行安装配置即可。初次启动需要较长的时间，请耐心等待。\nLsky-Pro\n一开始看兰空图床的文档没看到 webdav 功能的相关介绍，只看到几个我都不用的存储介质，遂不感兴趣的搁置了，然而群友近日又提起，我打开 GitHub 才发现首页有个 Commit 的标题就是 webdav 相关，即兰空图床支持 webdav 。于是我便部署了一下，体验感觉还不错，简单易用。\n本来无意在本篇文章再多写 PHP 相关的站点部署，因为过于简单。但是奈何群友有需求，遂做个简单的步骤记录：\n首先在 Panel 中 Add a New Website ：\n\n\n\nKey\nValue\n\n\n\n\nDomain\nxxx.USERNAME.serv00.net（也可以把原有的USERNAME.serv00.net删掉后重新添加）\n\n\nWebsite Type\nPHP\n\n\n\n添加完新站点后，继续点击上方的 Manage SSL certificates ，接着在出口 IP 的右侧点击 Manage ，再点击 Add certificate ：\n\n\n\nType\nDomain\n\n\n\n\nGenerate Let’s Encrypted certificate\n与刚刚添加的站点域名保持一致（如果是原有的USERNAME.serv00.net ，可以省略此步）\n\n\n\n接着SSH登入，并进入刚刚你新建的域名目录下：\n# 下载图床应用\nrelease_info=$(curl -s https://api.github.com/repos/lsky-org/lsky-pro/releases/latest)\nasset_url=$(echo \"$release_info\" | jq -r '.assets[] | select(.name != \"source code\") | .browser_download_url')\ncurl -L -o temp.zip \"$asset_url\" &#x26;&#x26; unzip -q temp.zip &#x26;&#x26; rm -f temp.zip\nrm -rf public_html &#x26;&#x26; ln -s \"$PWD/public\" \"$PWD/public_html\"\n接着在 Panel 中 WWW websites 选项卡内，点击自己刚刚创建的用于部署 Lsky-Pro 的域名的 Manage &gt; Details ，在 Open Basedir directories 的最末添加：\n:/usr/home/用户名/domains/xxx.USERNAME.serv00.net\n\n\n\n\n\n\n\n\n\n记得把用户名和最末的域名换成自己的。\n然后把 GZIP compression 、Allow PHP eval() function 、Allow PHP exec() function 都打开，点击 save changes 保存。\n然后去 Panel 中的 MySQL 选项卡，新建数据库和用户，用以接入 Lsky-Pro 。\n然后使用浏览器访问你的 Lsky-Pro 的域名，进行安装配置即可。\n\n\n\n\n\n\n\n\n\n上面的应用不需要占用端口。\n\n\n\n\n\n\n\n\n\n\n下面的应用每一个都能够 / 需要占用端口。\nVless\n这个肯定是第一时间部署的，每次遇到这样的平台，第一时间总是想着能不能搭建节点。\n①\n首先在 Panel 中放行一个端口，接着按照下表 Add a New Website ：\n\n\n\nKey\nValue\n\n\n\n\nDomain\nxxx.USERNAME.serv00.net（也可以把原有的 USERNAME.serv00.net 删掉后重新添加）\n\n\nWebsite Type\nproxy\n\n\nProxy Target\nlocalhost\n\n\nProxy URL\n留空\n\n\nProxy port\n你准备用来部署 Vless 的端口\n\n\nUse HTPPS\nFalse\n\n\nDNS support\nTrue\n\n\n\n添加完新站点后，继续点击上方的 Manage SSL certificates ，接着在出口 IP 的右侧点击 Manage ，再点击 Add certificate ：\n\n\n\nType\nDomain\n\n\n\n\nGenerate Let’s Encrypted certificate\n与刚刚添加的站点域名保持一致（如果是原有的USERNAME.serv00.net ，可以省略此步）\n\n\n\n接着SSH登入，并进入刚刚你新建的域名目录下：\n# 克隆源仓库\nrm -rf public_html &#x26;&#x26; git clone https://github.com/qwer-search/serv00-vless public_html &#x26;&#x26; cd public_html &#x26;&#x26; rm -f README.md\n使用vim编辑或者直接去 Panel 中的 File Manager 选项卡在线编辑 app.js 文件，修改端口为刚刚放行的端口。\n安装依赖：\nnpm install\n安装完毕后，使用pm2启动并守护vless进程：\npm2 start app.js --name vless\n接着去你的代理客户端软件中手动添加 vless 配置即可：\n\n\n\nKey\nValue\n\n\n\n\n地址\nPanel中WWW Websites 选项卡里的你的 Domain name\n\n\n端口\n你放行的端口\n\n\n用户 id\n37a0bd7c-8b9f-4693-8916-bd1e2da0a817\n\n\n传输协议\nws\n\n\n伪装域名\n同地址\n\n\nws path\n/\n\n\n\n上表没有给出的可以不填。\n②\n首先在 Panel 中放行一个端口，接着按照下表 Add a New Website ：\n\n\n\nKey\nValue\n\n\n\n\nDomain\nxxx.USERNAME.serv00.net（也可以把原有的 USERNAME.serv00.net 删掉后重新添加）\n\n\nWebsite Type\nproxy\n\n\nProxy Target\nlocalhost\n\n\nProxy URL\n留空\n\n\nProxy port\n你准备用来部署 Vless 的端口\n\n\nUse HTPPS\nFalse\n\n\nDNS support\nTrue\n\n\n\n添加完新站点后，继续点击上方的 Manage SSL certificates ，接着在出口 IP 的右侧点击 Manage ，再点击 Add certificate ：\n\n\n\nType\nDomain\n\n\n\n\nGenerate Let’s Encrypted certificate\n与刚刚添加的站点域名保持一致（如果是原有的USERNAME.serv00.net ，可以省略此步）\n\n\n\n接着SSH登入，并进入刚刚你新建的域名目录下的 public_html 路径下，再使用 npm 命令安装 @3Kmfi6HP/nodejs-proxy ：\nnpm install @3Kmfi6HP/nodejs-proxy\n\n\n\n\n\n\n\n\n\n被删库了可以自己换个源安装，比如：\nnpm --registry http://r.cnpmjs.org install @3Kmfi6HP/nodejs-proxy\n这个源如果也不行了请自己找其他源替换。\n再使用 pm2 启动：\n# 记得把 PORT 替换成自己放行的端口。\npm2 start npx --name vless -- nodejs-proxy -p PORT\n接着访问这个刚刚添加的站点，即可在网页上直接获取配置。\n哦对，有个小 bug ，端口需要改成 443 ，而网页中默认给的配置是 80 。\n\n\n\n\n\n\n\n\n\n之所以说这个 npm 包不安全，是因为其配置在网页上都可以看到，而且网页设计不太合理，有一个不带 uuid 的中转页面，所以可以使用 fofa 、 shodan 等网络空间扫描工具批量扫出来，而且不止 Serv00 一个平台有人使用，如果你感兴趣，你可以去搜搜看，可以收获一大批 Vless 节点。\n这里放一个 Serv00 上的，我在 fofa 上搜到的页面作为部署示例：https://pclwgdwv.serv00.net/\nAlist\nAlist 官方仓库没有构筑 FreeBSD 系统下能够运行的 Alist 可执行文件，但是我在 Github 上发现了一个使用 Github Workflow 自动构筑 FreeBSD 适用的 Alist 的仓库，使用这个仓库就可以很便利的在Serv00上部署 Alist。\nServ00本身提供的网站托管在~/domains路径下，所以我建议把Alist也部署到这个路径下的子目录：\nmkdir -p ~/domains/alist &#x26;&#x26; cd ~/domains/alist \n# 使用一键命令安装 Alist\n# wget -O alist-freebsd.sh https://raw.githubusercontent.com/k0baya/alist_repl/main/serv00/alist-freebsd.sh &#x26;&#x26; sh alist-freebsd.sh\n\n# 会报错，不用管\nwget https://github.com/uubulb/alist-freebsd/releases/download/v3.30.0/alist &#x26;&#x26; chmod +x alist &#x26;&#x26; ./alist server\n在 Panel 中进入 MySQL 选项卡，使用 Add database 功能新建一个数据库。\n\n\n\n\n\n\n\n\n\n密码要求含有大写字母、小写字母和数字三种字符，且长度必须超过6个字符。\n接下来进入 File manager 选项卡，进入 ~/domains/alist/data 路径，可以看到一个名为 config.json 的文件，右键点击，选择 View/Edit &gt; Source Editor ，进行编辑：\n我主要修改了 CDN、database、scheme 三个部分，其中CDN可以在 Alist 的官方文档找到，请选择你本地网络连接速度最快的一个。\nscheme 部分，我选择修改 adress 为 127.0.0.1本地回环，是为了避免被他人使用 http://ip:port的方式进行访问。至于自己怎么访问，我在本文后面的部分会进行介绍。port 要改成自己前面放行的端口。\ndatabase 部分，type 需要改成 mysql ，host 填写你在注册邮件中看到的 mysql 的地址， port 是默认的 3306，用户名、密码、数据库名则按照你创建的情况进行填写。\n\n\n\n\n\n\n\n\n\n最新版本的 Alist 如果不想开启 S3 Server，请把对应的配置文件中的端口配置为 0 。\n改完之后，点击 save 保存，接着回到 SSH 窗口中进行操作：\n测试启动 Alist：\n./alist server\n\n\n\n\n\n\n\n\n\n确定运行没有问题后，按 Ctrl+c即可停止运行。\n使用 pm2 启动并管理 alist：\npm2 start ./alist -- server\n\n\n\n\n\n\n\n\n\n同样的，你还可以使用 Cloudflared 隧道添加域名，而不选择使用 Proxy 。\n绑定域名\n此时还没有访问Alist的方法，因为监听的地址是本地回环，所以需要将其反向代理出来。我选择使用Cloudflare提供的Argo通道，顺带给Alist绑定自己的域名。\nCloudflared官方仓库没有提供FreeBSD平台的客户端，但是和Alist一样的，我找到了Unofficial的FreeBSD版本的构筑，接下来使用它打隧道：\n新建并进入Cloudflared的工作目录：\nmkdir -p ~/domains/cloudflared &#x26;&#x26; cd ~/domains/cloudflared\n下载Cloudflared：\nwget https://cloudflared.bowring.uk/binaries/cloudflared-freebsd-2023.10.0.7z &#x26;&#x26; 7z x cloudflared-freebsd-2023.10.0.7z &#x26;&#x26; rm cloudflared-freebsd-2023.10.0.7z &#x26;&#x26; mv -f ./temp/cloudflared-freebsd-2023.10.0 ./cloudflared &#x26;&#x26; rm -rf temp\n然后在Cloudflare的面板中，找到Networks分类下的Tunnels功能，点击Create a tunnel，选择Cloudflared，Next，随便取个名字，Next，往下翻，可以看到Run the following command，然后给了一串命令，将其复制出来，大概是这样的：\ncloudflared.exe service install eyJhIjoiNzh...............V5TWpBeSJ9\n前面的不需要管，只需要保留最后ey开头的那串很长的TOKEN，去SSH中测试运行Cloudflared：\n./cloudflared tunnel --edge-ip-version auto --protocol http2 --heartbeat-interval 10s run --token eyJhIjoiNzh...............V5TWpBeSJ9\n\n\n\n\n\n\n\n\n\n记得把最后的那一串替换成你的TOKEN。\n接着回到Cloudflare的面板，继续点击Next，然后添加一个自己的域名，Service中，Type选择HTTP，URL填写localhost:PORT，其中PORT为你的Alist对应的端口。点击Save Tunnel后，可以看到自己新建的Tunnel上线。\n接着使用Ctrl+c停止运行。然后安装进程管理工具pm2：\nbash &#x3C;(curl -s https://raw.githubusercontent.com/k0baya/alist_repl/main/serv00/install-pm2.sh)\n然后使用pm2启动Cloudflared：\n~/.npm-global/bin/pm2 start ./cloudflared -- tunnel --edge-ip-version auto --protocol http2 --heartbeat-interval 10s run --token eyJhIjoiNzh...............V5TWpBeSJ9\n\n\n\n\n\n\n\n\n\n记得把最后的那一串替换成你的TOKEN。\n再启动Alist：\ncd ~/domains/alist &#x26;&#x26; ~/.npm-global/bin/pm2 start ./alist -- server\n到这里，就可以直接通过你的域名访问刚刚部署的Alist了。\nSynctv\n群友仿照 alist-freebsd 的仓库的 workflow 进行构筑的。部署简单，与 alist 类似。首先在 Panel 中放行一个端口，接着按照下表 Add a New Website ：\n\n\n\nKey\nValue\n\n\n\n\nDomain\nxxx.USERNAME.serv00.net（也可以把原有的 USERNAME.serv00.net 删掉后重新添加）\n\n\nWebsite Type\nproxy\n\n\nProxy Target\nlocalhost\n\n\nProxy URL\n留空\n\n\nProxy port\n你准备用来部署 Synctv 的端口\n\n\nUse HTPPS\nFalse\n\n\nDNS support\nTrue\n\n\n\n添加完新站点后，继续点击上方的 Manage SSL certificates ，接着在出口 IP 的右侧点击 Manage ，再点击 Add certificate ：\n\n\n\nType\nDomain\n\n\n\n\nGenerate Let’s Encrypted certificate\n与刚刚添加的站点域名保持一致（如果是原有的USERNAME.serv00.net ，可以省略此步）\n\n\n\n接着 SSH 登入，并进入刚刚你新建的域名目录下的 public_html 路径下：\n# 下载可执行文件\nrelease_info=$(curl -s https://api.github.com/repos/shangskr/synctv-freebsd/releases/latest)\nasset_url=$(echo \"$release_info\" | jq -r '.assets[] | select(.name != \"source code\") | .browser_download_url')\ncurl -L -o synctv \"$asset_url\" &#x26;&#x26; chmod +x synctv\n新建启动脚本：\ncat > start.sh &#x3C;&#x3C; EOF\n#!/bin/sh\n# 如果不希望被使用 http://ip:port 的方式访问，取消注释下一行\n# export SYNCTV_SERVER_LISTEN=127.0.0.1\n# 把下一行的最末的PORT改成自己放行的端口\nexport SYNCTV_SERVER_PORT=PORT\nexec ./synctv server --data-dir ./\nEOF\n添加可执行权限：\nchmod +x start.sh\n测试运行：\n./start.sh\n\n\n\n\n\n\n\n\n\n确定运行没有问题后，按 Ctrl+c即可停止运行。\n使用pm2启动并管理：\npm2 start ./start.sh --name synctv\n\n\n\n\n\n\n\n\n\n同样的，你还可以使用 Cloudflared 隧道添加域名，而不选择使用 Proxy 。\nOne-api\n源仓库没有提供freebsd平台的二进制文件，需要自己构建，但是很简单。我已经写了一个仓库用于自动化构建 freebsd 版本的 one-api 二进制文件，可以直接下载使用。\n\n\n\n\n\n\n\n\n\n如果你想使用 New-API ，可以使用这个仓库k0baya/new-api-freebsd，用法与本节介绍的 One-API 基本一致，对比One-API添加了一些更方便的功能。也许之后 One-API 也会加入这些功能。\n首先在 Panel 中放行一个端口，接着按照下表 Add a New Website ：\n\n\n\nKey\nValue\n\n\n\n\nDomain\nxxx.USERNAME.serv00.net（也可以把原有的USERNAME.serv00.net删掉后重新添加）\n\n\nWebsite Type\nproxy\n\n\nProxy Target\nlocalhost\n\n\nProxy URL\n留空\n\n\nProxy port\n你准备用来部署 One-API 的端口\n\n\nUse HTPPS\nFalse\n\n\nDNS support\nTrue\n\n\n\n添加完新站点后，继续点击上方的 Manage SSL certificates ，接着在出口 IP 的右侧点击 Manage ，再点击 Add certificate ：\n\n\n\nType\nDomain\n\n\n\n\nGenerate Let’s Encrypted certificate\n与刚刚添加的站点域名保持一致（如果是原有的USERNAME.serv00.net ，可以省略此步）\n\n\n\n接着 SSH 登入，并进入刚刚你新建的域名目录下的 public_html 路径下：\n# 下载 one-api\nrelease_info=$(curl -s https://api.github.com/repos/k0baya/one-api-freebsd/releases/latest)\nasset_url=$(echo \"$release_info\" | jq -r '.assets[] | select(.name != \"source code\") | .browser_download_url')\ncurl -L -o one-api \"$asset_url\" &#x26;&#x26; chmod +x one-api\n新建启动脚本：\ncat > start.sh &#x3C;&#x3C; EOF\n#!/bin/sh\n# 如果你有设置主题的需要，可以取消注释下一行，然后按照自己的需求设置。\n# export THEME=\"berry\"\nexport TIKTOKEN_CACHE_DIR=\"$PWD\"\n# 把下一行的 PORT 改为自己放行的端口\nexec ./one-api --port PORT --log-dir ./logs\nEOF\n添加可执行权限：\nchmod +x start.sh\n保存后回到 terminal 中，测试运行：\n./start.sh\n\n\n\n\n\n\n\n\n\n\n确定运行没有问题后，按 Ctrl+c即可停止运行。\n使用pm2启动并管理：\npm2 start ./start.sh --name one-api\n\n\n\n\n\n\n\n\n\n同样的，你还可以使用 Cloudflared 隧道添加域名，而不选择使用 Proxy 。\nUptime-Kuma\n受限于 FreeBSD 的平台限制，1.23版本内置了 PlayWright ，无法运行，所以只能安装 1.22 版本。切记先去 Panel 中放行 TCP 端口。\n首先在 Panel 中放行一个端口，接着按照下表 Add a New Website ：\n\n\n\nKey\nValue\n\n\n\n\nDomain\nxxx.USERNAME.serv00.net（也可以把原有的USERNAME.serv00.net删掉后重新添加）\n\n\nWebsite Type\nproxy\n\n\nProxy Target\nlocalhost\n\n\nProxy URL\n留空\n\n\nProxy port\n你准备用来部署 Uptime-Kuma 的端口\n\n\nUse HTPPS\nFalse\n\n\nDNS support\nTrue\n\n\n\n添加完新站点后，继续点击上方的 Manage SSL certificates ，接着在出口 IP 的右侧点击 Manage ，再点击 Add certificate ：\n\n\n\nType\nDomain\n\n\n\n\nGenerate Let’s Encrypted certificate\n与刚刚添加的站点域名保持一致（如果是原有的USERNAME.serv00.net ，可以省略此步）\n\n\n\n接着 SSH 登入，并进入刚刚你新建的域名目录下：\n# 下载 v1.22.1 版本的源代码\ncd ~/domains &#x26;&#x26; wget https://github.com/louislam/uptime-kuma/archive/refs/tags/1.22.1.zip &#x26;&#x26; unzip 1.22.1.zip &#x26;&#x26; rm -rf public_html &#x26;&#x26; mv -f uptime-kuma-1.22.1 public_html &#x26;&#x26; rm -f 1.22.1.zip &#x26;&#x26; cd public_html\n设置生产模式：\nnpm ci --production\n下载dist文件：\nwget https://github.com/louislam/uptime-kuma/releases/download/1.22.1/dist.tar.gz &#x26;&#x26; tar -xzvf dist.tar.gz &#x26;&#x26; rm dist.tar.gz\n安装补充依赖：\nnpm install\n安装过程中多少会有报错，无视就好，实际上最后可以正常运行。内置的Cloudflared反向代理在FreeBSD平台上无法使用，但是可以使用上述的外置的Cloudflared进行反代，使用自己的域名。\n测试运行：\nnode server/server.js --port=PORT\n\n\n\n\n\n\n\n\n\n记得把PORT替换成你放行的端口。确定运行没有问题后，按 Ctrl+c即可停止运行。\n使用pm2管理后台运行：\npm2 start server/server.js --name uptime-kuma -- --port=PORT\n\n\n\n\n\n\n\n\n\n记得把PORT替换成你放行的端口。\n\n\n\n\n\n\n\n\n\n如果你不希望自己的Uptime-Kuma被人使用 http://IP:PORT的方式访问，你可以在最后的执行命令添加 --host=127.0.0.1的尾缀，这样就只能通过反向代理的域名进行访问了:\npm2 start server/server.js --name uptime-kuma -- --port=PORT --host=127.0.0.1\n\n\n\n\n\n\n\n\n\n同样的，你还可以使用 Cloudflared 隧道添加域名，而不选择使用 Proxy 。\nBingo（暂时无法正常使用）\n先放行一个端口。在 Panel 中进入 File manager 选项卡，点击左侧的 My Files 进入你的用户根目录，找到 .profile文件，右键选择 View/Edit &gt; Choose other &gt;Source Editor 进行编辑，在最末加上以上两行并保存：\nalias node='node20'\nalias npm='npm20'\n应用更改：\nsource ~/.profile\n\n\n\n\n\n\n\n\n\n先新建一个目录用于存放 Bingo 的相关文件，进入目录后执行下述操作。\n下载源码：\ngit clone https://github.com/weaigc/bingo\n进入源码所在目录：\ncd bingo\n安装依赖：\nnpm20 install\n下载build好的 .next资源：\nwget -O next.tar.gz https://pan.saika.free.hr/d/local/next.tar.gz &#x26;&#x26; tar -xzvf next.tar.gz &#x26;&#x26; rm next.tar.gz\n添加环境变量文件：\ncp .env.example .env\n接着在 Panel 中进入 File manager 选项卡，进入Bingo 源码所在的目录，找到 server.js文件，右键选择 View/Edit &gt; Choose other &gt;Source Editor 进行编辑，修改第7行中的端口为你放行的端口。再编辑 .env文件，添加你的 BING_HEADER。\n测试启动：\nnpm20 run start\n\n\n\n\n\n\n\n\n\n确定运行没有问题后，按 Ctrl+c即可停止运行。\n使用pm2启动并管理：\npm2 start npm --name bingo -- run start\nRefresh-gpt-chat\n用来对接 ninja、warpgpt 等能够使用 access_Token 作为 API Key 请求 GPT 的工具，以使用永久有效期的 Refresh_token 来获取更好的体验。\n首先在 Panel 中放行一个端口，接着按照下表 Add a New Website ：\n\n\n\nKey\nValue\n\n\n\n\nDomain\nxxx.USERNAME.serv00.net（也可以把原有的 USERNAME.serv00.net 删掉后重新添加）\n\n\nWebsite Type\nproxy\n\n\nProxy Target\nlocalhost\n\n\nProxy URL\n留空\n\n\nProxy port\n你准备用来部署 Refresh-gpt-chat 的端口\n\n\nUse HTPPS\nFalse\n\n\nDNS support\nTrue\n\n\n\n添加完新站点后，继续点击上方的 Manage SSL certificates ，接着在出口 IP 的右侧点击 Manage ，再点击 Add certificate ：\n\n\n\nType\nDomain\n\n\n\n\nGenerate Let’s Encrypted certificate\n与刚刚添加的站点域名保持一致（如果是原有的USERNAME.serv00.net ，可以省略此步）\n\n\n\n接着 SSH 登入，并进入刚刚你新建的域名目录下的 public_html 路径下：\n# 下载 refresh-gpt-chat\nwget -O refresh-gpt-chat.jar https://github.com/Yanyutin753/refresh-gpt-chat/releases/download/v0.0.3/refresh-gpt-chat-0.0.3-SNAPSHOT.jar\n使用 pm2 启动：\npm2 start java19 --name refresh-gpt-chat -- -jar refresh-gpt-chat.jar --server.port=端口 --server.servlet.context-path=/ --getAccessTokenUrl=https://你的ninja地址/auth/refresh_token --chatUrl=https://你的ninja地址/v1/chat/completions\n再套域名，接下来就可以直接使用 https://你套的域名/v1/chat/completions/ 当作API端点，使用 refresh_token 做 API_Keys ，使用 ChatGPT 了。\n然后在 one-api 中添加自定义渠道， Base URL 填写你 https://你套的域名，模型填入你的 refresh_token 对应的账号所支持的模型，如果和我一样手持大把 3.5 的账号想用来做 API 用，可以选择全部 GPT3.5 的相关模型，然后在 模型重定向中填入以下内容：\n&#123;\n  \"gpt-3.5-turbo-0301\": \"gpt-3.5-turbo\",\n  \"gpt-3.5-turbo-0613\": \"gpt-3.5-turbo\",\n  \"gpt-3.5-turbo-16k\": \"gpt-3.5-turbo\",\n  \"gpt-3.5-turbo-16k-0613\": \"gpt-3.5-turbo\",\n  \"gpt-3.5-turbo-1106\": \"gpt-3.5-turbo\",\n  \"gpt-3.5-turbo-instruct\": \"gpt-3.5-turbo\"\n&#125;\n密钥填写你的 refresh_token即可，如果你有多个账号，可以将批量勾选上，然后一行写一个 refresh_token。\n\n\n\n\n\n\n\n\n\n同样的，你还可以使用 Cloudflared 隧道添加域名，而不选择使用 Proxy 。\nGpt4-copilot-java\n支持 cocopilot 的 ccu 和 copilot 的 ghu 调用 copilot 转 GPT-4 的接口转换工具。 Java 写的，可以在 Serv00 运行。\n\n\n\n\n\n\n\n\n\n目前更推荐这个方法：lvguanjun/copilot-to-chatgpt4\n比起 Gpt4-copilot-java 更轻量更强大。\n首先在 Panel 中放行一个端口，接着按照下表 Add a New Website ：\n\n\n\nKey\nValue\n\n\n\n\nDomain\nxxx.USERNAME.serv00.net（也可以把原有的USERNAME.serv00.net删掉后重新添加）\n\n\nWebsite Type\nproxy\n\n\nProxy Target\nlocalhost\n\n\nProxy URL\n留空\n\n\nProxy port\n你准备用来部署 Gpt4-copilot-java 的端口\n\n\nUse HTPPS\nFalse\n\n\nDNS support\nTrue\n\n\n\n添加完新站点后，继续点击上方的 Manage SSL certificates ，接着在出口 IP 的右侧点击 Manage ，再点击 Add certificate ：\n\n\n\nType\nDomain\n\n\n\n\nGenerate Let’s Encrypted certificate\n与刚刚添加的站点域名保持一致（如果是原有的USERNAME.serv00.net ，可以省略此步）\n\n\n\n接着 SSH 登入，并进入刚刚你新建的域名目录下的 public_html 路径下：\n# 下载 fat jar 包\nRELEASE_INFO=$(curl -s \"https://api.github.com/repos/Yanyutin753/gpt4-copilot-java-sh/releases/latest\")\nJAR_DOWNLOAD_URL=$(echo \"$RELEASE_INFO\" | jq -r '.assets[] | select(.name|test(\".jar$\")) | .browser_download_url')\ncurl -L -o gpt4-copilot-java.jar \"$JAR_DOWNLOAD_URL\"\n测试运行：\n# 把PORT改为自己放行的端口，最后的server.servlet.context-path参数可以改成自己喜欢的尾缀\njava19 -jar gpt4-copilot-java.jar --server.port=PORT --server.servlet.context-path=/\n\n\n\n\n\n\n\n\n\n测试没有问题之后，按 Ctrl+c即可停止运行。\n使用 pm2 启动并管理：\npm2 start java19 --name gpt4-copilot-java -- -jar gpt4-copilot-java.jar --server.port=PORT --server.servlet.context-path=/\n\n\n\n\n\n\n\n\n\n始皇的公车：ghu_ThisIsARealFreeCopilotKeyByCoCopilot （已失效）\n免费公车白嫖请求示例：\ncurl --location 'http(s)://ip:port_or_URL/cocopilot/v1/chat/completions' \n--header 'Content-Type: application/json' \n--header 'Authorization: Bearer ghu_ThisIsARealFreeCopilotKeyByCoCopilot' \n--data '&#123;\n\"model\": \"gpt-4\",\n\"messages\": [&#123;\"role\": \"user\", \"content\": \"鲁迅打周树人\"&#125;]\n&#125;'\n\n\n\n\n\n\n\n\n\n同样的，你还可以使用 Cloudflared 隧道添加域名，而不选择使用 Proxy 。\nZfile\n首先在 Panel 中放行一个端口，接着按照下表 Add a New Website ：\n\n\n\nKey\nValue\n\n\n\n\nDomain\nxxx.USERNAME.serv00.net（也可以把原有的USERNAME.serv00.net删掉后重新添加）\n\n\nWebsite Type\nproxy\n\n\nProxy Target\nlocalhost\n\n\nProxy URL\n留空\n\n\nProxy port\n你准备用来部署 Zfile 的端口\n\n\nUse HTPPS\nFalse\n\n\nDNS support\nTrue\n\n\n\n添加完新站点后，继续点击上方的 Manage SSL certificates ，接着在出口 IP 的右侧点击 Manage ，再点击 Add certificate ：\n\n\n\nType\nDomain\n\n\n\n\nGenerate Let’s Encrypted certificate\n与刚刚添加的站点域名保持一致（如果是原有的USERNAME.serv00.net ，可以省略此步）\n\n\n\n接着 SSH 登入，并进入刚刚你新建的域名目录下的 public_html 路径下：\n# 下载 fat jar 包\nwget --no-check-certificate -O zfile.jar https://c.jun6.net/ZFILE/zfile-release.jar\n测试运行：\njava19 -jar -Duser.timezone=Asia/Shanghai zfile.jar --zfile.log.path=$PWD/logs --zfile.db.path=$PWD/zfile --server.port=PORT\n\n\n\n\n\n\n\n\n\n记得把端口改成自己的。测试没有问题之后，按 Ctrl+c即可停止运行。\n使用pm2启动并管理：\npm2 start java19 --name zfile -- -jar -Duser.timezone=Asia/Shanghai zfile.jar --zfile.log.path=$PWD/logs --zfile.db.path=$PWD/zfile --server.port=PORT\n\n\n\n\n\n\n\n\n\n同样的，你还可以使用 Cloudflared 隧道添加域名，而不选择使用 Proxy 。\nHalo\n\n\n\n\n\n\n\n\n\n慎重部署，内存会超100%，不知道会不会封号\nhalo 自从升级 2.0 版本开始，很长时间内都没有提供构筑好的 jar 包，甚至于在GitHub上都出现了第三方的，使用 GitHub workflow 自动化构筑 jar 包的仓库。但是，自从2.12.0-alpha.1版本开始，halo 的官方仓库又开始提供构筑好的 jar 包了，刚好这些天在玩 Serv00 ，遂尝试部署了一下，成功。现记录一下：\n首先在 Panel 中放行一个端口，接着按照下表 Add a New Website ：\n\n\n\nKey\nValue\n\n\n\n\nDomain\nxxx.USERNAME.serv00.net（也可以把原有的 USERNAME.serv00.net 删掉后重新添加）\n\n\nWebsite Type\nproxy\n\n\nProxy Target\nlocalhost\n\n\nProxy URL\n留空\n\n\nProxy port\n你准备用来部署 Halo 的端口\n\n\nUse HTPPS\nFalse\n\n\nDNS support\nTrue\n\n\n\n添加完新站点后，继续点击上方的 Manage SSL certificates ，接着在出口 IP 的右侧点击 Manage ，再点击 Add certificate ：\n\n\n\nType\nDomain\n\n\n\n\nGenerate Let’s Encrypted certificate\n与刚刚添加的站点域名保持一致（如果是原有的USERNAME.serv00.net ，可以省略此步）\n\n\n\n并在 MySQL 选项卡中中新建 MySQL 数据库，用于填入接入 Halo 。\n接着 SSH 登入，并进入刚刚你新建的域名目录下的 public_html 路径下：\n# 下载jar包\nrelease_info=$(curl -s https://api.github.com/repos/halo-dev/halo/releases/latest)\njar_url=$(echo \"$release_info\" | jq -r '.assets[] | select(.name | endswith(\".jar\")) | .browser_download_url')\ncurl -L \"$jar_url\" -o halo.jar\n在 halo.jar 所在路径下新建 .halo2 文件夹，进入其中，新建文件 application.yaml 然后并配置其内容：\n# 新建文件夹\nmkdir -p .halo2\n# 新建并填入配置\ncat > .halo2/application.yaml &#x3C;&#x3C; EOF\nserver:\n  port: 你在面板中放行的端口\n  # Response data gzip.\n  compression:\n    enabled: false\nspring:\n  #sql:\n  #  init.platform: mysql\n  r2dbc:\n    url: r2dbc:pool:mysql://数据库地址:3306/数据库名\n    username: 数据库用户名\n    password: 数据库密码\nhalo:\n  # Your admin client path is https://your-domain/&#123;admin-path&#125;\n  admin-path: admin\n  # memory or level\n  cache: level\nEOF\n在 halo.jar 所在路径下新建 run.sh 运行脚本：\ncat > run.sh &#x3C;&#x3C; EOF\n#!/bin/bash\nexport HALO_WORK_DIR=\"$PWD/.halo2\"\nexport HALO_EXTERNAL_URL=\"https://你的域名\"\nexec java17 -server -Xms128m -Xmx256m -jar -Duser.timezone=Asia/Shanghai $PWD/halo.jar --spring.config.additional-location=$PWD/.halo2/application.yaml\nEOF\n测试运行：\nchmod +x run.sh &#x26;&#x26; ./run.sh\n\n\n\n\n\n\n\n\n\n确定运行没有问题后，按 Ctrl+c即可停止运行。\n使用pm2管理运行：\nchmod +x run.sh &#x26;&#x26; pm2 start ./run.sh --name halo\n\n\n\n\n\n\n\n\n\n同样的，你还可以使用 Cloudflared 隧道添加域名，而不选择使用 Proxy 。\nGo-proxy-bingai\n这个仓库是 Bingo 的前身，当初玩 Replit 时我便有在使用，只可惜作者早已弃坑，所以当初我才找到了当时还能用的 Bingo 使用。\n在 Bingo 也长期未更新，无法正常使用的如今，我的目光转向了另一个二改仓库。Harry-zklcdc 维护的 Go-proxy-bingai 的分支仓库目前还能够正常使用。而且在与开发者反馈了几个 bug 之后，开发者都会花时间认真复现，并快速修复，其体验实在是不错。\n虽然原仓库的 Release 中并未提供 FreeBSD 系统适用的二进制文件，但是我们能够自己构建。我已经构建了一份放在这篇博客底部的QQ群的群文件中。我写了一个仓库用于自动化构建 FreeBSD 版本的 go-proxy-bingai ，可以从我的仓库下载使用。 作者已经开始提供 FreeBSD 的构建，故我的仓库已经存档。\n首先在 Panel 中放行一个端口，接着按照下表 Add a New Website ：\n\n\n\nKey\nValue\n\n\n\n\nDomain\nxxx.USERNAME.serv00.net（也可以把原有的 USERNAME.serv00.net 删掉后重新添加）\n\n\nWebsite Type\nproxy\n\n\nProxy Target\nlocalhost\n\n\nProxy URL\n留空\n\n\nProxy port\n你准备用来部署 Go-proxy-bingai 的端口\n\n\nUse HTPPS\nFalse\n\n\nDNS support\nTrue\n\n\n\n添加完新站点后，继续点击上方的 Manage SSL certificates ，接着在出口 IP 的右侧点击 Manage ，再点击 Add certificate ：\n\n\n\nType\nDomain\n\n\n\n\nGenerate Let’s Encrypted certificate\n与刚刚添加的站点域名保持一致（如果是原有的USERNAME.serv00.net ，可以省略此步）\n\n\n\n接着 SSH 登入，并进入刚刚你新建的域名目录下的 public_html 路径下：\n# 下载可执行文件\nrelease_info=$(curl -s https://api.github.com/repos/Harry-zklcdc/go-proxy-bingai/releases | jq -r '[.[] | select(.prerelease==false)][0]')\ndownload_url=$(echo \"$release_info\" | jq -r '.assets[] | select(.name==\"go-proxy-bingai-freebsd-amd64.tar.gz\") | .browser_download_url')\ncurl -L \"$download_url\" -o go-proxy-bingai-freebsd-amd64.tar.gz&#x26;&#x26; tar -xzf go-proxy-bingai-freebsd-amd64.tar.gz &#x26;&#x26; rm go-proxy-bingai-freebsd-amd64.tar.gz &#x26;&#x26; chmod +x go-proxy-bingai\n新建启动脚本：\ncat > entrypoint.sh &#x3C;&#x3C; EOF\n#!/bin/bash\n# 被注释的环境变量请根据自己的需求，按照原仓库的 wiki 中的介绍进行填入。\nexport BYPASS_SERVER=\"https://bypass.zklcdc.xyz\"  # 作者本人的公共bypass服务，可用性未知。\n# export Go_Proxy_BingAI_USER_TOKEN_1=\"xxx\"\n# export Go_Proxy_BingAI_USER_TOKEN_2=\"xxx\"\n# export USER_KievRPSSecAuth=\"xxx\"\n# export USER_RwBf=\"xxx\"\n# export USER_MUID=\"xxx\"\n# export APIKEY=\"sk-xxx\"\n# export BING_BASE_URL=\"https://www.bing.com\"\n# export SYDNEY_BASE_URL=\"https://sydney.bing.com\"\n# export HTTP_PROXY=\"http://172.17.0.1:18080\"\n# export HTTPS_PROXY=\"http://172.17.0.1:18080\"\n# export Go_Proxy_BingAI_AUTH_KEY=\"xxx\"\n# 请把下一行双引号中的内容替换成你放行的端口。\nexport PORT=\"xxx\"\nchmod +x go-proxy-bingai &#x26;&#x26; exec ./go-proxy-bingai\nEOF\n运行：\n# 测试运行\nchmod +x entrypoint.sh &#x26;&#x26; ./entrypoint.sh\n# 使用 pm2 管理运行\npm2 start ./entrypoint.sh --name go-proxy-bingai\n\n\n\n\n\n\n\n\n\n请注意，如果你需要使用其 web 功能，而不仅仅是 api 功能，请务必使用 https 访问，不然无法打开。你可以选择使用面板自带的 proxy 添加域名并申请 ssl 证书，亦或者直接使用 cloudflared 隧道。\n\n\n\n\n\n\n\n\n\n同样的，你还可以使用 Cloudflared 隧道添加域名，而不选择使用 Proxy 。\nPentaract\n\n\n\n\n\n\n\n\n\n不建议使用，目前 Bug 众多，而且对 Telegram 账号有一定要求，目前暂不清楚 Telegram 限制账号的评定标准。\n可以自行构建或者使用使用我构建的成品。由于该应用需要使用具有超级管理员权限的 PostgreSQL ，故不可使用 Serv00 自带的 PostgreSQL ，需要远程连接。\n编译成品下载地址：pentaract-freebsd_X64.tar.gz\n前端构建简单，这里不再赘述，而且由于其 Dockerfile 内构建前端使用的是 Node.js 21 而目前 FreeBSD Port 最高只有 Node.js 20 ，故不推荐在 FreeBSD 上直接构建，可以使用 GItHub Actions 进行构建，或是自己在 Node.js 21 的环境下构建再复制，甚至干脆直接从作者预构建的 Docker 镜像内打包出来使用。（经过测试，使用 Nodejs20 构建也可以正常使用。）\nServ00 上的构建法：\n# 切换 Node.js 版本为 Nodejs20\nalias node=node20\nalias npm=npm20\n# 全局安装 pnpm\nnpm install -g pnpm\nsource ~/.bashrc\n# 构建前端\npnpm install\nVITE_API_BASE='/api' pnpm run build\n# 移动构建产物到工作目录\nmkdir -p ~/pentaract/ui &#x26;&#x26; cp -R ./dist/* ~/pentaract/ui\n后端的构建，可以使用 GItHub Actions ，或者本地 FreeBSD 虚拟机，甚至直接在 Serv00 上构建。这里记录一下在 Serv00 上构建的方法：\n# 克隆仓库到 Serv00 上\ngit clone https://github.com/Dominux/Pentaract &#x26;&#x26; cd Pentaract/pentaract\n# 构建\nLIBCLANG_PATH=/usr/local/llvm16/lib cpuset -l 0 cargo build --release\n# 移动构建产物到工作目录\nmkdir -p ~/pentaract &#x26;&#x26; cp ./target/release/pentaract ~/pentaract/pentaract\n然后去 supabase 注册一个免费的PostgreSQL ，记录下数据库的用户名、密码、数据库名、地址，用于后续填入环境变量。\n接着在 ~/pentaract 路径下新建一个启动脚本，按照要求填入所有的环境变量：\ncat > start.sh &#x3C;&#x3C; EOF\n#!/bin/bash\nexport PORT=xxxx\nexport WORKERS=4\nexport CHANNEL_CAPACITY=32\nexport SUPERUSER_EMAIL=xxxx@xxxx.com\nexport SUPERUSER_PASS=xxxx\nexport ACCESS_TOKEN_EXPIRE_IN_SECS=1800\nexport REFRESH_TOKEN_EXPIRE_IN_DAYS=14\nexport SECRET_KEY=xxx\nexport TELEGRAM_API_BASE_URL=https://api.telegram.org\nexport DATABASE_USER=xxxx\nexport DATABASE_PASSWORD=xxxx\nexport DATABASE_NAME=xxxx\nexport DATABASE_HOST=xxxx\nexport DATABASE_PORT=5432\nchmod +x pentaract &#x26;&#x26; exec ./pentaract\nEOF\n给启动脚本赋权：\nchmod +x start.sh\n前端的 index-22eec6d1.js 文件内的 http://localhost:8000 需要更改为 serv00 的 url 或者 ip:port 。你可以去文件管理中编辑，查找替换即可，也可以使用sed命令简单更改一下： 已经重新构建前端并替换，现无需此步。\n测试运行：\n./start.sh\n使用 pm2 管理：\npm2 start ./start.sh --name pentaract\nOneList\n原作者似乎已经弃坑，故我的仓库没有做自动检测构建。但是体验还不错，有 Emby 既视感了，配合小雅的 Alist 岂不美哉。\n首先在 Panel 中放行一个端口，接着按照下表 Add a New Website ：\n\n\n\nKey\nValue\n\n\n\n\nDomain\nxxx.USERNAME.serv00.net（也可以把原有的USERNAME.serv00.net删掉后重新添加）\n\n\nWebsite Type\nproxy\n\n\nProxy Target\nlocalhost\n\n\nProxy URL\n留空\n\n\nProxy port\n你准备用来部署 OneList 的端口\n\n\nUse HTPPS\nFalse\n\n\nDNS support\nTrue\n\n\n\n添加完新站点后，继续点击上方的 Manage SSL certificates ，接着在出口 IP 的右侧点击 Manage ，再点击 Add certificate ：\n\n\n\nType\nDomain\n\n\n\n\nGenerate Let’s Encrypted certificate\n与刚刚添加的站点域名保持一致（如果是原有的USERNAME.serv00.net ，可以省略此步）\n\n\n\n接着SSH登入，并进入刚刚你新建的域名目录下的 public_html 路径下：\n# 下载 OneList\nwget https://github.com/k0baya/onelist-freebsd/releases/download/v2.0.5/onelist\n# 初始化配置\nchmod +x onelist &#x26;&#x26; ./onelist -run config\n接着回到 Panel 中，进入File manager选项卡，进入 OneList 所在路径，可以看到一个名为 config.env 的文件，右键点击，选择View/Edit &gt; Source Editor，进行编辑：\n# 服务设置\n# 注意要改为未被占用的端口\nAPI_PORT=5245\nFaviconicoUrl=https://wework.qpic.cn/wwpic/818353_fizV30xbQCGPQRP_1677394564/0\nAPI_SECRET=fRVvjcNd11gYGI85StVaeCtPVSmJTRRE\n\n# Env有两种模式，Debug及Release，主要用在数据库为mysql时候，需要注意修改Env环境和mysql密码对应\nEnv=Debug\n\n# 管理员账户设置，用于初始化管理员账户\nUserEmail=xxxx.@qq.com\nUserPassword=xxxxx\n\n# 数据库设置\nDB_DRIVER=sqlite\nDB_USER=root\nDbName=onelist\n\n# 如果上面DB_DRIVER类型为mysql，就需要正确填下以下参数\nDB_PASSWORD_Debug=123456\nDB_PASSWORD_Release=123456\n\n# TheMovieDb Key\n# 在https://www.themoviedb.org网站申请\nKeyDb=22f10ca52f109158ac7fe064ebbcf697\n你可以按照自己的需求配置端口、管理员账户、数据库。 MySQL 性能更好哦~\n测试运行：\n./onelist -run server\n使用 pm2 管理：\npm2 start ./onelist -- -run server\nWarpGPT\n这个没什么多说的，可以使用 access_Token 作为 API Key 请求 ChatGPT 接口，也就是所谓的 chat2api 。配合前文的 Refresh-gpt-chat 就可以把永久有效期的 Refresh_token 作为 API Key 来使用，十分的好用。\n源仓库没有 Release ，故我的仓库没有做自动检测构建。如果有更新需求需要手动触发 workflow 。你有需要也可以自己fork一份然后手动触发 workflow 。\n首先在 Panel 中放行一个端口，接着按照下表 Add a New Website ：\n\n\n\nKey\nValue\n\n\n\n\nDomain\nxxx.USERNAME.serv00.net（也可以把原有的USERNAME.serv00.net删掉后重新添加）\n\n\nWebsite Type\nproxy\n\n\nProxy Target\nlocalhost\n\n\nProxy URL\n留空\n\n\nProxy port\n你准备用来部署 WarpGPT 的端口\n\n\nUse HTPPS\nFalse\n\n\nDNS support\nTrue\n\n\n\n添加完新站点后，继续点击上方的 Manage SSL certificates ，接着在出口 IP 的右侧点击 Manage ，再点击 Add certificate ：\n\n\n\nType\nDomain\n\n\n\n\nGenerate Let’s Encrypted certificate\n与刚刚添加的站点域名保持一致（如果是原有的USERNAME.serv00.net ，可以省略此步）\n\n\n\n接着SSH登入，并进入刚刚你新建的域名目录下的 public_html 路径下：\n# 下载二进制文件\nwget https://github.com/k0baya/warpgpt-freebsd/releases/download/latest/warpgpt &#x26;&#x26; chmod +x warpgpt\n添加启动脚本：\ncat > start.sh &#x3C;&#x3C; EOF\n#!/bin/bash\nexport TMPDIR=\"$PWD\"\nchmod +x warpgpt &#x26;&#x26; exec ./warpgpt\nEOF\n给启动脚本赋权：\nchmod +x start.sh\n配置环境变量：\ncat > .env &#x3C;&#x3C; EOF\nproxy = \"http://127.0.0.1:10809\"   #代理地址 （选填）\nport = 5000                        #程序运行端口\nhost = '127.0.0.1'                 #可访问ip，0.0.0.0允许所有ip\nverify = false                     #是否对访问进行验证\nauth_key = \"\"                      #若开启访问验证，则需要在Header中添加AuthKey字段，且值为auth_key的值才能访问 （选填）\narkose_must = false                #是否强行gpt3.5进行验证\nOpenAI_HOST = \"chat.openai.com\"    #openai网页api接口地址 （选填）\nopenai_api_host = \"api.openai.com\" #openai官方api接口 （选填）\nproxy_pool_url=\"\"                  #ipidea代理池链接 （选填）\n#示例http://api.proxy.ipidea.io/getProxyIp?num=10&#x26;return_type=json&#x26;lb=1&#x26;sb=0&#x26;flow=1&#x26;regions=us&#x26;protocol=http，根据访问频次设置num值\nlog_level = \"debug\"                #日志等级\n\nredis_address = \"127.0.0.1:6379\"   #redis地址（若不开启代理池可选填）\nredis_passwd = \"\"                  #redis密码\nredis_db = 0                       #选择的redis数据库\nEOF\n\n\n\n\n\n\n\n\n\n如果有 redis 需求，可以查阅官方文档：Redis\n使用 pm2 管理运行：\npm2 start bash --name warpgpt -- start.sh\nCoze-discord-proxy\n代理 Discord 对话 Coze-Bot ，实现以 API 形式请求 GPT4 模型，提供对话、文生图、图生文、知识库检索等功能。功能不多赘述，详细去源仓库查看。\n同样的，我写了一个用于构建 FreeBSD 版本的仓库。在这里感谢论坛用户 Reno 的测试，没有测试人员的测试，也不会有部署的过程记录了。\n首先在 Panel 中放行一个端口，接着按照下表 Add a New Website ：\n\n\n\nKey\nValue\n\n\n\n\nDomain\nxxx.USERNAME.serv00.net（也可以把原有的USERNAME.serv00.net删掉后重新添加）\n\n\nWebsite Type\nproxy\n\n\nProxy Target\nlocalhost\n\n\nProxy URL\n留空\n\n\nProxy port\n你准备用来部署 Coze-discord-proxy 的端口\n\n\nUse HTPPS\nFalse\n\n\nDNS support\nTrue\n\n\n\n添加完新站点后，继续点击上方的 Manage SSL certificates ，接着在出口 IP 的右侧点击 Manage ，再点击 Add certificate ：\n\n\n\nType\nDomain\n\n\n\n\nGenerate Let’s Encrypted certificate\n与刚刚添加的站点域名保持一致（如果是原有的USERNAME.serv00.net ，可以省略此步）\n\n\n\n接着SSH登入，并进入刚刚你新建的域名目录下的 public_html 路径下：\n# 下载二进制文件\nrelease_info=$(curl -s https://api.github.com/repos/k0baya/coze-discord-proxy-freebsd/releases/latest)\nasset_url=$(echo \"$release_info\" | jq -r '.assets[] | select(.name != \"source code\") | .browser_download_url')\ncurl -L -o coze-discord-proxy \"$asset_url\" &#x26;&#x26; chmod +x coze-discord-proxy\n添加启动脚本：\ncat > start.sh &#x3C;&#x3C; EOF\n#!/bin/bash\n# 根据你的需求自行填入环境变量\nexport PORT=\"PORT\"\nexport USER_AUTHORIZATION=\"XXXXXX\"\nexport BOT_TOKEN=\"XXXXXX\"\nexport GUILD_ID=\"XXXXXX\"\nexport COZE_BOT_ID=\"XXXXXX\"\nexport PROXY_SECRET=\"XXXXXX\"\nexport CHANNEL_ID=\"XXXXXX\"\nexport TZ=\"Asia/Shanghai\"\nexport DATA_GYM_CACHE_DIR=\"$PWD\"\nchmod +x coze-discord-proxy &#x26;&#x26; exec ./coze-discord-proxy\nEOF\n给启动脚本赋权：\nchmod +x coze-discord-proxy\n添加多机器人配置文件：\nmkdir -p app/coze-discord-proxy/data/config\ntouch app/coze-discord-proxy/data/config/bot_config.json\n然后回到 Panel 中，进入File manager选项卡，进入 bot_config.json 所在路径，右键点击它，选择View/Edit &gt; Source Editor，进行编辑：\n[\n  &#123;\n    \"proxySecret\": \"123\", // 接口请求密钥(PROXY_SECRET)(注意:此密钥在环境变量PROXY_SECRET中存在时该Bot才可以被匹配到!)\n    \"cozeBotId\": \"12***************31\", // coze托管的机器人ID\n    \"model\": [\"gpt-3.5\",\"gpt-3.5-16k\"], // 模型名称(数组格式)(与请求参数中的model对应,如请求中的model在该json中未匹配到则会抛出异常)\n    \"channelId\": \"12***************56\"  // [可选]discord频道ID(机器人必须在此频道所在的服务器)(目前版本下该参数仅用来活跃机器人)\n  &#125;,\n  &#123;\n    \"proxySecret\": \"456\",\n    \"cozeBotId\": \"12***************64\",\n    \"model\": [\"gpt-4\",\"gpt-4-16k\"],\n    \"channelId\": \"12***************78\"\n  &#125;,\n  &#123;\n    \"proxySecret\": \"789\",\n    \"cozeBotId\": \"12***************12\",\n    \"model\": [\"dall-e-3\"],\n    \"channelId\": \"12***************24\"\n  &#125;\n]\n使用 pm2 管理运行：\npm2 start bash --name coze-discord-proxy -- start.sh\nMemos\n一款开源、轻量级的笔记服务。轻松捕捉并分享您的精彩想法。\n这个仓库比较难受的是，其在源码的这个位置强制要求其 gRPC 服务的端口为 Memos 监听端口+1，故这个应用需要占用两个端口，而且必须是两个连续的端口。\n同样的，我写了一个用于构建 FreeBSD 版本的仓库。\n首先在 Panel 中放行两个相邻的端口，接着按照下表 Add a New Website ：\n\n\n\nKey\nValue\n\n\n\n\nDomain\nxxx.USERNAME.serv00.net（也可以把原有的USERNAME.serv00.net删掉后重新添加）\n\n\nWebsite Type\nproxy\n\n\nProxy Target\nlocalhost\n\n\nProxy URL\n留空\n\n\nProxy port\n刚刚放行的两个相邻的端口中小的那一个\n\n\nUse HTPPS\nFalse\n\n\nDNS support\nTrue\n\n\n\n添加完新站点后，继续点击上方的 Manage SSL certificates ，接着在出口 IP 的右侧点击 Manage ，再点击 Add certificate ：\n\n\n\nType\nDomain\n\n\n\n\nGenerate Let’s Encrypted certificate\n与刚刚添加的站点域名保持一致（如果是原有的USERNAME.serv00.net ，可以省略此步）\n\n\n\n接着SSH登入，并进入刚刚你新建的域名目录下的 public_html 路径下：\nAPI_URL=\"https://api.github.com/repos/k0baya/memos-binary/releases/latest\"\nDOWNLOAD_URL=$(curl -s $API_URL | jq -r \".assets[] | select(.name == \\\"memos-freebsd-amd64.tar.gz\\\") | .browser_download_url\")\ncurl -L $DOWNLOAD_URL -o memos-freebsd-amd64.tar.gz\ntar -xzvf memos-freebsd-amd64.tar.gz &#x26;&#x26; rm memos-freebsd-amd64.tar.gz &#x26;&#x26; chmod +x memos\n关于运行，有两种方式进行：\n① SQLite\n如果选择使用 SQLite 作为数据库运行，则可以直接运行：\n# 假定你的数据文件打算存储在 /home/username/domains/xxx.USERNAME.serv00.net/public_html/data\n# 新建数据文件夹\nmkdir -p /home/username/domains/xxx.USERNAME.serv00.net/public_html/data\n# 测试运行\n./memos --mode prod --port PORT --data /home/username/domains/xxx.USERNAME.serv00.net/public_html/data\n# 使用 pm2 管理\npm2 start ./memos --name memos -- --mode prod --port PORT --data /home/username/domains/xxx.USERNAME.serv00.net/public_html/data\n② 外接 MySQL / PostgreSQL\n你可以使用面板自带的 MySQL / PostgreSQL 新建数据库，或者使用其他平台提供的远程数据库：\n# 假定你的数据文件打算存储在 /home/username/domains/xxx.USERNAME.serv00.net/public_html/data\n# 新建数据文件夹\nmkdir -p /home/username/domains/xxx.USERNAME.serv00.net/public_html/data\n# 测试运行（MySQL）（MySQL需要管理员权限，你可以选择远程连接）\n./memos --mode prod --port PORT --data /home/username/domains/xxx.USERNAME.serv00.net/public_html/data --driver mysql --dsn mysql://root:password123@localhost:3306/mydb\n# 测试运行（PostgreSQL）\n./memos --mode prod --port PORT --data /home/username/domains/xxx.USERNAME.serv00.net/public_html/data --driver postgres --dsn postgresql://user:password123@localhost:5432/mydb?sslmode=disable\n# 使用 pm2 管理（MySQL）（MySQL需要管理员权限，你可以选择远程连接）\npm2 start ./memos --name memos -- --mode prod --port PORT --data /home/username/domains/xxx.USERNAME.serv00.net/public_html/data --driver mysql --dsn mysql://root:password123@localhost:3306/mydb\n# 使用 pm2 管理（PostgreSQL）\npm2 start ./memos --name memos -- --mode prod --port PORT --data /home/username/domains/xxx.USERNAME.serv00.net/public_html/data --driver postgres --dsn postgresql://user:password123@localhost:5432/mydb?sslmode=disable\nFrps\n内网穿透嘛，懂的都懂，这里只做服务端的部署记录，客户端可以查看 Frp 的官方文档自行配置。感谢群友的率先测试：youyi\n首先在 Panel 中放行两个端口，接着按照下表 Add a New Website ：\n\n\n\nKey\nValue\n\n\n\n\nDomain\nxxx.USERNAME.serv00.net（也可以把原有的USERNAME.serv00.net删掉后重新添加）\n\n\nWebsite Type\nproxy\n\n\nProxy Target\nlocalhost\n\n\nProxy URL\n留空\n\n\nProxy port\n你准备用来映射转发内网服务的端口\n\n\nUse HTPPS\nFalse\n\n\nDNS support\nTrue\n\n\n\n添加完新站点后，继续点击上方的 Manage SSL certificates ，接着在出口 IP 的右侧点击 Manage ，再点击 Add certificate ：\n\n\n\nType\nDomain\n\n\n\n\nGenerate Let’s Encrypted certificate\n与刚刚添加的站点域名保持一致（如果是原有的USERNAME.serv00.net ，可以省略此步）\n\n\n\n\n\n\n\n\n\n\n\n\n同样的，你可以设置多个域名使用 Proxy 指向同一个端口，在 Frpc 客户端配置中使用域名分发不同的服务。具体可以查阅官方文档。\n接着SSH登入，并进入刚刚你新建的域名目录下的 public_html 路径下\nrelease_info=$(curl -s https://api.github.com/repos/fatedier/frp/releases/latest)\ndownload_url=$(echo \"$release_info\" | jq -r '.assets[] | select(.name | contains(\"freebsd_amd64.tar.gz\")) | .browser_download_url')\ncurl -L \"$download_url\" -o frp_freebsd_amd64.tar.gz \ntar -xzvf frp_freebsd_amd64.tar.gz --strip-components=1\nrm -rf frp_freebsd_amd64.tar.gz\n接着编辑配置文件：\n# 按照自己的实际情况和需求进行配置，这里只做最简单的http转发配置示例\ncat > frps.toml &#x3C;&#x3C; EOF\nbindPort = 监听端口\nvhostHTTPPort = 映射转发端口\nauth.token = \"密码\"\nEOF\n运行：\npm2 start ./frps -- -c frps.toml\n\n\n\n\n\n\n\n\n\n客户端配置示例：\nserverAddr = \"x.x.x.x\"\nserverPort = Frps 的监听端口\nauth.token = \"密码\"\n\n[[proxies]]\nname = \"web\"\ntype = \"http\"\nlocalPort = 80\ncustomDomains = [\"www.yourdomain.com\"]\n\n[[proxies]]\nname = \"web2\"\ntype = \"http\"\nlocalPort = 8080\ncustomDomains = [\"www.yourdomain2.com\"]\nRclone\nRclone 是一款管理云存储文件的命令行程序。它功能丰富，可替代云供应商的网络存储界面。超过 70 种云存储产品支持 Rclone，包括 S3 对象存储、企业和消费者文件存储服务以及标准传输协议。\n具体用法与配置请查阅其官方文档。\n如果你需要使用 Rclone 的 web ui ，你可以按照前文所述的大多数应用一样，先放行端口，添加域名，申请好 SSL 证书，并进入其目录下的 public_html 路径下再进行程序本体的下载部署。\n下载最新版 Rclone：\nrelease_info=$(curl -s https://api.github.com/repos/rclone/rclone/releases/latest)\ndownload_url=$(echo \"$release_info\" | jq -r '.assets[] | select(.name | contains(\"-freebsd-amd64.zip\")) | .browser_download_url')\ncurl -L \"$download_url\" -o rclone-freebsd-amd64.zip\nouter_folder=$(unzip -l rclone-freebsd-amd64.zip | grep '/' | sed -n '1p' | sed 's#^.* \\([^/]*\\)/.*$#\\1#')\nunzip rclone-freebsd-amd64.zip\nmv \"$outer_folder\"/* . &#x26;&#x26; rm -rf \"$outer_folder\" rclone-freebsd-amd64.zip\n经我测试，目前 v1.63.1 之后的版本的 FreeBSD 版的构建都有无法识别 mount 命令的问题，在我查阅其 issue —— #7432 、 #5843 后，确定这个 bug 已经好几个月没有修复了。所以我建议在此 bug 修复前，使用 v1.63.1 版本。\n下载 v1.63.1 版本 Rclone ：\ncurl -L https://github.com/rclone/rclone/releases/download/v1.63.1/rclone-v1.63.1-freebsd-amd64.zip -o rclone-freebsd-amd64.zip\nouter_folder=$(unzip -l rclone-freebsd-amd64.zip | grep '/' | sed -n '1p' | sed 's#^.* \\([^/]*\\)/.*$#\\1#')\nunzip rclone-freebsd-amd64.zip\nmv \"$outer_folder\"/* . &#x26;&#x26; rm -rf \"$outer_folder\" rclone-freebsd-amd64.zip\n配置 Rclone 的存储：\n./rclone config\n\n\n\n\n\n\n\n\n\n启动 web ui：\n./rclone rcd --rc-web-gui --rc-user 用户名 --rc-pass 密码 --rc-addr :端口\npm2 管理 web ui：\npm2 start ./rclone -- rcd --rc-web-gui --rc-user 用户名 --rc-pass 密码 --rc-addr :端口\nCloudreve\nCloudreve 可助你即刻构建出兼备自用或公用的网盘服务，通过多种存储策略的支持、虚拟文件系统等特性实现灵活的文件管理体验。\n同样的，我编写了一个用于自动化构建 FreeBSD 版本的 Cloudreve 的仓库：k0baya/cloudreve-freebsd 前后端分离构建，前端静态文件在 Cloudreve 本体同路径下的 static 文件夹内。\n首先在 Panel 中放行一个端口，接着按照下表 Add a New Website ：\n\n\n\nKey\nValue\n\n\n\n\nDomain\nxxx.USERNAME.serv00.net（也可以把原有的USERNAME.serv00.net删掉后重新添加）\n\n\nWebsite Type\nproxy\n\n\nProxy Target\nlocalhost\n\n\nProxy URL\n留空\n\n\nProxy port\n你准备用来部署 Cloudreve 的端口\n\n\nUse HTPPS\nFalse\n\n\nDNS support\nTrue\n\n\n\n添加完新站点后，继续点击上方的 Manage SSL certificates ，接着在出口 IP 的右侧点击 Manage ，再点击 Add certificate ：\n\n\n\nType\nDomain\n\n\n\n\nGenerate Let’s Encrypted certificate\n与刚刚添加的站点域名保持一致（如果是原有的USERNAME.serv00.net ，可以省略此步）\n\n\n\n接着SSH登入，并进入刚刚你新建的域名目录下的 public_html 路径下：\nrelease_info=$(curl -s https://api.github.com/repos/k0baya/cloudreve-freebsd/releases/latest)\ndownload_url=$(echo \"$release_info\" | jq -r '.assets[] | select(.name | contains(\"freebsd-amd64.tar.gz\")) | .browser_download_url')\ncurl -L \"$download_url\" -o cloudreve-freebsd-amd64.tar.gz \ntar -xzvf cloudreve-freebsd-amd64.tar.gz\nrm -rf cloudreve-freebsd-amd64.tar.gz\nCloudreve 在首次启动时，会创建初始管理员账号，请注意保管管理员密码，此密码只会在首次启动时出现。如果您忘记初始管理员密码，需要删除同级目录下的 cloudreve.db ，重新启动主程序以初始化新的管理员账户。\nCloudreve 默认会监听 5212 端口。首次启动时，Cloudreve 会在同级目录下创建名为 conf.ini 的配置文件，你可以修改此文件进行一些参数的配置（比如端口），保存后需要重新启动 Cloudreve 生效。\n一个完整的配置文件示例如下：\n[System]\n; 运行模式\nMode = master\n; 监听端口\nListen = :5212\n; 是否开启 Debug\nDebug = false\n; Session 密钥, 一般在首次启动时自动生成\nSessionSecret = 23333\n; Hash 加盐, 一般在首次启动时自动生成\nHashIDSalt = something really hard to guss\n; 呈递客户端 IP 时使用的 Header\nProxyHeader = X-Forwarded-For\n\n; SSL 相关\n[SSL]\n; SSL 监听端口\nListen = :443\n; 证书路径\nCertPath = C:\\Users\\i\\Documents\\fullchain.pem\n; 私钥路径\nKeyPath = C:\\Users\\i\\Documents\\privkey.pem\n\n; 启用 Unix Socket 监听\n[UnixSocket]\nListen = /run/cloudreve/cloudreve.sock\n; 设置产生的 socket 文件的权限\nPerm = 0666\n\n; 数据库相关，如果你只想使用内置的 SQLite 数据库，这一部分直接删去即可\n[Database]\n; 数据库类型，目前支持 sqlite/mysql/mssql/postgres\nType = mysql\n; MySQL 端口\nPort = 3306\n; 用户名\nUser = root\n; 密码\nPassword = root\n; 数据库地址\nHost = 127.0.0.1\n; 数据库名称\nName = v3\n; 数据表前缀\nTablePrefix = cd_\n; 字符集\nCharset = utf8mb4\n; SQLite 数据库文件路径\nDBFile = cloudreve.db\n; 进程退出前安全关闭数据库连接的缓冲时间\nGracePeriod = 30\n; 使用 Unix Socket 连接到数据库\nUnixSocket = false\n\n; 从机模式下的配置\n[Slave]\n; 通信密钥\nSecret = 1234567891234567123456789123456712345678912345671234567891234567\n; 回调请求超时时间 (s)\nCallbackTimeout = 20\n; 签名有效期\nSignatureTTL = 60\n\n; 跨域配置\n[CORS]\nAllowOrigins = *\nAllowMethods = OPTIONS,GET,POST\nAllowHeaders = *\nAllowCredentials = false\nSameSite = Default\nSecure = lse\n\n; Redis 相关\n[Redis]\nServer = 127.0.0.1:6379\nPassword =\nDB = 0\n\n; 从机配置覆盖\n[OptionOverwrite]\n; 可直接使用 `设置名称 = 值` 的格式覆盖\nmax_worker_num = 50\n你可以使用 vim 或者 Panel 中的 File manager 选项卡，进入 conf.ini 所在路径路径，右键点击，选择 View/Edit &gt; Source Editor ，进行编辑。\n修改完配置文件后，测试启动：\n./cloudreve\n使用 pm2 管理：\npm2 start ./cloudreve\nPanIndex\n一个简易的网盘目录列表。\n同样的，我编写了一个用于自动化构建 FreeBSD 版本的 PanIndex 的仓库：k0baya/panindex-freebsd。\n\n\n\n\n\n\n\n\n\n后台地址（默认）：http://ip:port/admin\n默认账号：admin\n默认密码：PanIndex\n首先在 Panel 中放行一个端口，接着按照下表 Add a New Website ：\n\n\n\nKey\nValue\n\n\n\n\nDomain\nxxx.USERNAME.serv00.net（也可以把原有的USERNAME.serv00.net删掉后重新添加）\n\n\nWebsite Type\nproxy\n\n\nProxy Target\nlocalhost\n\n\nProxy URL\n留空\n\n\nProxy port\n你准备用来部署 PanIndex 的端口\n\n\nUse HTPPS\nFalse\n\n\nDNS support\nTrue\n\n\n\n添加完新站点后，继续点击上方的 Manage SSL certificates ，接着在出口 IP 的右侧点击 Manage ，再点击 Add certificate ：\n\n\n\nType\nDomain\n\n\n\n\nGenerate Let’s Encrypted certificate\n与刚刚添加的站点域名保持一致（如果是原有的USERNAME.serv00.net ，可以省略此步）\n\n\n\n接着SSH登入，并进入刚刚你新建的域名目录下的 public_html 路径下：\nrelease_info=$(curl -s https://api.github.com/repos/k0baya/panindex-freebsd/releases/latest)\nasset_url=$(echo \"$release_info\" | jq -r '.assets[] | select(.name != \"source code\") | .browser_download_url')\ncurl -L -o panindex \"$asset_url\" &#x26;&#x26; chmod +x panindex\n创建配置文件：\ncat > config.json &#x3C;&#x3C; EOF\n&#123;\n  \"host\": \"0.0.0.0\",\n  \"port\": 5238,\n  \"log_level\": \"info\",\n  \"data_path\": \"\",\n  \"cert_file\": \"\",\n  \"key_file\": \"\",\n  \"config_query\": \"\",\n  \"db_type\": \"\",\n  \"dsn\": \"\",\n  \"ui\": \"\"\n&#125;\nEOF\n\n\n\n\n\n\n\n\n\n数据库支持 sqlite (默认)、mysql、postgres ，如果需要接入 MySQL 或者 PostgreSQL ，请写成数据库链接的方式填入 dsn 。注意，如果是 Serv00 自带的 PostgreSQL ，请在数据库链接最末加上 ?sslmode=disable 以禁用 SSL 连接。\n编写好配置文件后，测试运行：\n./panindex -c=config.json\n使用 pm2 管理：\npm2 start ./panindex -- -c=config.json\n收尾工作\n听说 Serv00 会不定时重启机器，所以我们把 pm2 添加开机自启，可以保证每次重启都能由 pm2 调动 Alist 和 Cloudflared 。而且 Serv00 每三个月内必须要有一次登录面板或者 SSH 连接，不然会删号，也可以通过一个脚本解决问题，接下来我会详细说明。\n自动续期\n青龙面板\n可以用青龙面板的自动任务定期登录SSH解决。在青龙面板中添加Linux依赖 sshpass，然后添加定时任务：名称随意，命令/脚本 sshpass -p '密码' ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -tt 用户名@地址 &quot;exit&quot;，定时规则 1 1 1 * *。这样就会每个月自动ssh连接一次，实现续期。\n服务器自身SSH\n\n\n\n\n\n\n\n\n\n你还可以使用自身 SSH 自身的方式进行自动续期，操作如下：\n进入一个自己喜欢的路径，使用 cat 命令新建 auto-renew.sh 脚本：\ncat > auto-renew.sh &#x3C;&#x3C; EOF\n#!/bin/bash\n\nwhile true; do\n  sshpass -p '密码' ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -tt 用户名@地址 \"exit\" &#x26;\n  sleep 259200  #30天为259200秒\ndone\nEOF\n记得把其中的密码、用户名、ssh的地址修改为你自己的。\n给 auto-renew.sh添加可执行权限：\nchmod +x auto-renew.sh\n使用pm2启动：\npm2 start ./auto-renew.sh\n这样就会每隔一个月自动执行一次SSH连接，自己SSH自己进行续期。\nGithub 自动登录\nServ00 - 控制面板自动登录脚本 克隆该仓库\n\n修改 .github/workflows/login.yml 比如5 2 */7 * *，每 7 天一次，每次执行的时间是凌晨 2 点 5 分 \n添加账号名称为 ACCOUNTS_JSON\n\n[\n&#123; \"username\": \"登录名1\", \"password\": \"密码\" &#125;,\n&#123; \"username\": \"登录名2\", \"password\": \"密码\" &#125;,\n&#123; \"username\": \"登录名3\", \"password\": \"密码\" &#125;\n]\n\n\n进入仓库 Actions 下启用 workflow\n\n自动启动\n听说 Serv00 的主机会不定时重启，所以需要添加自启任务。\n在 Panel 中找到 Cron jobs 选项卡，使用 Add cron job 功能添加任务，Specify time 选择 After reboot，即为重启后运行。Form type 选择 Advanced，Command 写：\n/home/你的用户名/.npm-global/bin/pm2 resurrect\n\n\n\n\n\n\n\n\n\n记得把你的用户名改为你的用户名\n添加完之后，在 SSH 窗口保存 pm2 的当前任务列表快照：\npm2 save\n这样每次 serv00 不定时重启任务时，都能自动调用 pm2 读取保存的任务列表快照，恢复任务列表。如果在保存了任务列表快照后又改变了任务 pm2 的任务列表，需要重新执行 pm2 save 以更新任务列表。\n原文作者：Saika\n原文链接：https://blog.rappit.site/2024/01/27/serv00_logs/#部署自己的应用\n","slug":"serv00","date":"2024-04-18T11:50:43.183Z","categories_index":"serv00","tags_index":"pm2,wordpress,kodbox,lsky-pro,vless,alist,synctv,one-api,uptime-kuma,bingo,refresh-gpt-chat,gpt4-copilot-java,zfile,helo,go-proxy-bingai,pentaract,onelist,warpgpt,coze-discord-proxy,memos,frps,rclone,cloudreve,panindex","author_index":"Kidwen"},{"id":"9957a2da37115597aba3967fbfc7d5d1","title":"使用Nuxt和Supabase做一个书签管理器","content":"这几天发现书签太多了并且不是很好找到想要的书签，所以我决定利用空闲时间写一个书签管理器。正好趁这个机会用一下基于vue的nuxt 3框架。数据库选择了免费的supabase,部署在vercel上. 因为本人没有服务器，😄😄😄。\n创建nuxt项目\n本次我选择从vercel模板市场直接fork一个项目模板并开始构建。\n\n\n\n\n\n\n\n\n\nNuxt.js 3 Boilerplate 进入并点击 Deploy 按钮。\n在 Repository Name 下输入自己项目名称并点击 Create，vercel会关联仓库并在每次提交后自动构建啦~\n\n创建Supabase数据库\n\n创建想要的表，也可以执行脚本创建。\n\n点击连接获取SUPABASE_URL和SUPABASE_KEY。\n\n\n[可选] 创建 Github Oauth\n\n\nHomepage URL 本地开发需要填入本地启动服务的地址（nuxt 默认 http://localhost:3000）。\nAuthorization callback URL 需要在 supabase中获取如下图。\nsupabase 中 Client ID 和 Client Secret 在 Github 用户 Setting =&gt; Developer settings=&gt;OAuth Apps=&gt;Client ID, 点击Generate a new client secret生成 Client Secret，填入supabase并开启Github Oauth\n\n\n\n\n\n开始coding\n\n\nclone 第一步创建的仓库\n\n\n安装依赖\n  yarn\n\n\n在根目录创建 .evn文件并将2.2截图内容填入\n\n\n运行项目\n  yarn dev\n\n\n发布到Vercel\n\n推送代码会自动部署\n需要给vercel设置.env中的环境变量\n\n参考链接\nhttps://supabase.nuxtjs.org/demo\nhttps://github.com/nuxt-modules/supabase/tree/main/demo\nhttps://supabase.com/docs/guides/auth/social-login/auth-github#find-your-callback-url\n","slug":"bookmark","date":"2024-04-13T14:35:01.997Z","categories_index":"NUXT","tags_index":"nuxt,pina,supabase,vercel,oauth","author_index":"Kidwen"},{"id":"d270d462daf0496aec69d3ecc94557ef","title":"angular time format","content":"Angular 拥有强悍的时间格式化管道以及方法，本文主要介绍formatDate方法的使用。\n引入\nimport &#123; formatDate &#125; from '@angular/common';\n参数\n\n\nvalue: string | number | Date\n\n可以传入符合规范的时间字符串（ISO 字符串规范），时间戳（UTC毫秒）或者Date对象，\n\n\n\nformat: string\n\n格式化的格式，例如 ‘yyyy-MM-dd hh:mm:ss’\nyyyy-MM-dd =&gt; 2023-11-21\nhh:mm:ss =&gt; 17:21:09\nhh:mm:ss a =&gt; 05:21:09 PM\nEEEE =&gt; Tuesday\nEEE =&gt; Tue\nMMMM =&gt; November\nMMM d =&gt; Nov 21\n\n\n\nlocale: string\n\n设置格式规则的区域设置代码\n‘en-US’\n\n\n\ntimezone?: string\n\n时区，如果没有设置则使用系统时区\n‘utc’\n‘+8’\n\n\n\n附录一\n如果遇到给了一个时区America/Los_Angeles,angular是不识别的，需要自己转换。\nexport function getTimeZoneOffset(timeZone: string): string &#123;\n    if (!timeZone) &#123;\n        return 'UTC';\n    &#125;\n    const dt = DateTime.now().setZone(timeZone);\n    // 获取时区偏移并格式化为 '+HH:mm' 形式\n    const timeZoneOffset = dt.toFormat('ZZ');\n    return timeZoneOffset;\n&#125;\n```\n附录二\nangular date管道和方法使用差不多，只是参数顺序不一样（timezone和locale交换）。\n\n\n\n\n\n\n\n\n\n需要注意：改变Date对象并不会触发管道，需要创建新对象才可以。\ntransform(value: Date | string | number, format?: string, timezone?: string, locale?: string): string | null;\n附录三\n\n\n\n选项\n等价于\n示例\n\n\n\n\nshort\nM/d/yy, h:mm a\n6/15/15, 9:03 AM\n\n\nmedium\nMMM d, y, h:mm:ss a\nJun 15, 2015, 9:03:01 AM\n\n\nlong\nMMMM d, y, h:mm:ss a z\nJune 15, 2015 at 9:03:01 AM GMT+1\n\n\nfull\nEEEE, MMMM d, y, h:mm:ss a zzzz\nMonday, June 15, 2015 at 9:03:01 AM GMT+01:00\n\n\nshortDate\nM/d/yy\n6/15/15\n\n\nmediumDate\nMMM d, y\nJun 15, 2015\n\n\nlongDate\nMMMM d, y\nJune 15, 2015\n\n\nfullDate\nEEEE, MMMM d, y\nMonday, June 15, 2015\n\n\nshortTime\nh:mm a\n9:03 AM\n\n\nmediumTime\nh:mm:ss a\n9:03:01 AM\n\n\nlongTime\nh:mm:ss a z\n9:03:01 AM GMT+1\n\n\nfullTime\nh:mm:ss a zzzz\n9:03:01 AM GMT+01:00\n\n\n\n附录四\n夏令时：以美国夏令时为例本地时间会+1，美国时区为-8，所以美国夏令时相对于utc时间是-7.\njs使用new Date()会返回如下结果，此时会给出夏令时时间\n\n但是当你只有时分秒的utc时间的话通过new Date(time)是不会认为这是一个夏令时时间所以要自己手动转换\n\n/**\n * 获取当前是否有夏令时时间偏移\n * @returns number\n */\nconst getDaylightTime = (timeUnix: Date): number => &#123;\n    var year = new Date(timeUnix).getFullYear();\n    // getTimezoneOffset()方法返回的是本地时间与 GMT 时间或 UTC 时间之间相差的分钟数。\n    var t1 = new Date(year, 0, 1).getTimezoneOffset();\n    var t2 = new Date(timeUnix).getTimezoneOffset();\n    // 获取夏令时时间偏移\n    return t1 - t2;\n&#125;;\n\nconst daylightOffset = getDaylightTime(new Date());\n\nconst getTimezoneOffsetTime = (timeNumber: number): number => &#123;\n    if (daylightOffset !== 0) &#123;\n        return timeNumber + daylightOffset * 60 * 1000;\n    &#125; else &#123;\n        return timeNumber;\n    &#125;\n&#125;\n\n/**\n * 获取转换 UTC 时间为当前时间\n * @param utcTime number\n * @param type TimeType\n * @returns number\n */\nexport const getConvertUtcToCurrentTime = (utcTime: number, type?: TimeType): number => &#123;\n    // 传 UTC 时间时，假如只传 28800000 (8:00) 减去时区会得到 28800000 - 28800000 = 0\n    if (type === 'HH:mm') &#123;\n        // 因为有夏令时，所以在格式化之前加上夏令时偏移\n        const utcTimeStr = formatDate(getTimezoneOffsetTime(utcTime), 'HH:mm', 'en-US');\n        // 1970年 7:30会出现负值，导致时间提交失败\n        return (Date.parse('2000-01-01T' + utcTimeStr + ':00') + new Date().getTimezoneOffset() * 60000);\n    &#125;\n    return (new Date(utcTime).getTime() + new Date().getTimezoneOffset() * 60000);\n&#125;\n\nexport type TimeType = 'HH:mm';\n\n/**\n * 获取转换字符串日期为当前时间\n * @param time string\n * @param type TimeType\n * @returns number\n */\nexport const getConvertStringTimeToCurrentTime = (time: string, type: TimeType): number => &#123;\n    if (type === 'HH:mm') &#123;\n        // 1970年 7:30会出现负值，导致时间提交失败\n        return Date.parse('2000-01-01T' + time + ':00');\n    &#125;\n&#125;\n\n/**\n * 获取当前时间\n * @param time string | number \n * @param type TimeType\n * @returns number | null\n */\nexport const getCurrentTime = (time?: string | number, type?: TimeType): number | null => &#123;\n    if (time === undefined || time === null) return null;\n    if (typeof time === 'string') &#123;\n        return getConvertStringTimeToCurrentTime(time, type);\n    &#125;\n    return getConvertUtcToCurrentTime(time, type);\n&#125;\n附录五 - moment-timezone\n// 获取指定时区的时间偏移量\nmoment.tz('America/Los_Angeles').utcOffset() * 60 * 1000;\n","slug":"angular-time","date":"2023-11-21T09:27:56.038Z","categories_index":"ANGULAR","tags_index":"angular,time format","author_index":"Kidwen"},{"id":"17123eb273eb28de4ba456a5c252cb7a","title":"GCM","content":"git凭据管理(git-credential-manager)-多用户\n帮助命令\ngit credential-manager github --help\n\n# Description:\n#   Commands for interacting with the GitHub host provider\n# \n# Usage:\n#   git-credential-manager github [command] [options]\n# \n# Options:\n#   --no-ui         Do not use graphical user interface prompts\n#   -?, -h, --help  Show help and usage information\n# \n# Commands:\n#   list              List all known GitHub accounts.\n#   login             Add a GitHub account.\n#   logout &#x3C;account>  Remove a GitHub account.\n查看凭据列表\ngit credential-manager github list\n\n# kidwen\n# levy\n删除用户凭据\ngit credential-manager github logout levy\n","slug":"credential-manager","date":"2023-10-28T15:09:09.608Z","categories_index":"GIT","tags_index":"git","author_index":"Kidwen"},{"id":"01d2f05fbd218c890b1d1ad74fd069bb","title":"使用qexo管理hexo博客并自动发布","content":"本文介绍使用 qexo后台管理 hexo博客并自动推送修改到 github仓库，然后由 github action自动部署并发布。由于我的博客分为两个仓库(博客源码的仓库，静态文件仓库)，所以本文将介绍两个仓库的用法，如果为单仓库可以参考hexo github action教程。\n准备\n\n两个代码仓库\nvercel账号\nsm.ms账号（有自己托管图片的工具则不需要）\n\n好了，我们开始吧！！！\n部署后台管理工具Qexo\nqexo是一个有趣的Hexo 编辑器，下面截图是后台管理主界面，可以看到有文章、页面、图片、配置、图片、友链、说说、自定义字段，这些都是对应博客仓库的。右上角有设置对应的是qexo初始化时候的配置信息，使用它我们就可以在线编辑博客啦～\n\n部署Qexo到Vercel\n\n\n\n\nfork 仓库并开始部署\n首次部署会报错, 请无视并继续\n\n\n\n申请 Vercel 数据库\n\n进入Vercel Storage 界面 然后点击右上角的 Create Database 并选择 Postgres 创建免费 PostgreSQL 数据库, 在 Connect 页面获取数据库连接信息。请注意在地区选择的位置选择与你上一步项目对应的地区（通常为 Washington, D.C., USA (East) - iad1）。\n\n\n\n绑定项目\n\n在左侧边栏选择 Projects 点击 Connect Project 连接到第一步创建的项目\n\n\n\n部署\n\n回到你的项目页面，在 Deployments 点击 Redeploy 开始部署, 若没有 Error 信息即可打开域名进入初始化引导。\n\n\n\n配置自定义域名（可选）\n\n进入vercel创建的项目中点击 Settings选择 Domains添加一个你拥有的域名吧！\n\n\n\n配置Qexo\n\n\n\n创建登陆用户-输入用户名和密码，API密匙可以留空。\n\n\n\ngithub token 创建位置: user setting -&gt; developer setting -&gt; personal access tokens -&gt; tokens(classic), ⚠️仓库地址填写博客源码的仓库不要带 https://github.com前缀\n\n\n\nVercel配置\n\nVercel 账户密钥 在 此处 生成\nQexo 部署所在项目的 ID 位于 Project Settings -&gt; General -&gt; Project ID\n\n\n\n配置Qexo图床\nQexo支持 远程API、S3协议、FTP协议和 GITHUB(不建议)\n\n\n我选择的是远程API使用SM.MS来保存图片，教程。但是其中遇到一些问，api调用一直失败json解析报错，原因：设置 -&gt; 图床配置 -&gt; 自定义请求头 {&quot;Authorization&quot;:&quot;XXXXXXXXXXXXXX&quot;}，冒号后面不能有空格！！！\n\nAuthorization字段地址\n\n\n\n代码仓库CI/CD\n\n\n创建Secrets\n   cd !/.ssh\n   ssh-keygen -f hexo-deploy-key -C 'email'\n   pbcopy &#x3C; hexo-deploy-key # 复制创建的私有key\n\n\n配置Secrets\n\n\n[ ]  源码仓库Settings -&gt; Secrets -&gt; Actions -&gt; new repository secret添加一个新的 Secret\n     Name: HEXO_DEPLOY_PRI # 名称后面要使用\n     Value: xxxx # ~/.ssh/hexo-deploy-key文件中的内容，刚刚已经被复制到剪切板中。\n\n\n[ ]  静态文件仓库 Settings -&gt; Deploy keys -&gt; add deploy key 页面添加新的 Secret\n     Title: hexo-deploy-key\n     Key: xxxxx # 填入 hexo-deploy-key.pub 中的公钥内容\n     # 勾选 Allow write access 选项，允许写入权限\n\n\n\n\n添加 github action\n\n\n[ ]  源码仓库创建文件 .github/workflows/hexo-deploy.yml并编辑\n     name: Hexo Deploy\n     # 只监听 source 分支的改动\n     on:\n       push:\n         branches:\n           - master\n\n     # 自定义环境变量，这个GIT_USER和GIT_EMAIL配置成你自己的，\n     # GIT_EMAIL尽量和上面的`ssh-keygen -f hexo-deploy-key -C \"email\"`中的email保持一致\n     env:\n       GIT_USER: your user name\n       GIT_EMAIL: your email addr\n\n     jobs:\n       build-and-deploy:\n         runs-on: ubuntu-latest\n\n         steps:\n           # 获取博客源码和主题\n           - name: Checkout\n             uses: actions/checkout@v2\n\n           # 这里用的是 Node.js 14.x，16.x 生成 Hexo 静态页面会有问题\n           - name: Set up Node.js\n             uses: actions/setup-node@v1\n             with:\n               node-version: '16'\n\n           # 安装依赖\n           - name: Install Dependencies\n             run: |\n               npm install\n\n           # 从之前设置的 secret 获取部署私钥\n           - name: Setup SSH Keys and known_hosts\n             env:\n               HEXO_DEPLOY_PRI: $&#123;&#123; secrets.HEXO_DEPLOY_PRI &#125;&#125; \n             run: |\n               sudo timedatectl set-timezone \"Asia/Shanghai\"\n               mkdir -p ~/.ssh\n               echo \"$HEXO_DEPLOY_PRI\" > ~/.ssh/id_rsa\n               chmod 600 ~/.ssh/id_rsa\n               ssh-keyscan github.com >> ~/.ssh/known_hosts\n               git config --global user.name $GIT_USER\n               git config --global user.email $GIT_EMAIL\n\n           # 生成并部署 `npx hexo clean &#x26;&#x26; npx hexo g -d` or `npm run deploy`\n           - name: Deploy\n             run: |\n               npx hexo clean &#x26;&#x26; npx hexo g &#x26;&#x26; npx hexo deploy\n\n\n\n\n","slug":"qexo-hexo","date":"2023-09-15T06:20:09.247Z","categories_index":"TOOL","tags_index":"qexo,hexo,ci/cd","author_index":"Kidwen"},{"id":"d471cbb5d3a5e8775b58ce1c8d851097","title":"常用CSS","content":"本文主要记录一些常用css，经常用但是还是记不住，每次都要上网搜好麻烦啊所以特此开了本文。本文包括文字，图片，背景，动画，定位，布局，滚动条等样式，以及一些样式属性的介绍。\n文本篇\n文本省略号\n// 单行省略号\n.text&#123;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n&#125;\n// 多行省略号\n.text &#123;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    display: -webkit-box;\n    -webkit-line-clamp: 2; // 2 代表显示的行数\n    -webkit-box-orient: vertical;\n&#125;\nplaceholder 省略号\ninput:placeholder-shown &#123;\n    text-overflow:ellipsis;\n&#125;\n// or\ninput[placeholder] &#123;\n    text-overflow:ellipsis;\n&#125;\n文本下划线距离\n.text &#123;\n    text-underline-offset: 1rem;\n&#125;\n图片\nimg, video &#123;\n    // 设置内容适应到其使用高度和宽度确定的框的方式\n    // contain: 内容将被缩放，保持填充元素在内容框内保持其宽高比。当内容的宽高比和框的宽高比不匹配将被添加黑边\n    // cover: 内容保持宽高比并填充元素的整个内容框，如果宽高比不一致则剪裁以适应内容框\n    // fill: 内容正好填充元素的内容框，整个对象将完全填充此框，如果宽高比不一致则拉伸以适应内容框\n    // none: 保持原有尺寸\n    object-fit: cover;\n\n    object-position: 50% 50%;\n&#125;\ndiv &#123;\n    background-image: url();\n    // contain: 在容器内尽可能大地缩放图像，而不裁剪或拉伸图像。如果容器大于图像，这将导致图像平铺，除非将background-repeat 属性设置为no-repeat。\n    // cover: 将图像（同时保留其比例）缩放到尽可能小的尺寸以填充容器（即：其高度和宽度完全覆盖容器），不留任何空白空间。如果背景的比例与元素不同，则图像将被垂直或水平裁剪。\n    background-size: cover;\n&#125;\n媒体查询篇\n打印\n@media print &#123;\n    .print-content &#123;\n        // 打印背景图片\n        -webkit-print-color-adjust: exact;\n    &#125;\n\n    .print-item &#123;\n        // 防止元素被截断\n        page-break-inside: avoid;\n    &#125;\n&#125;\n布局篇\nflex 布局\n.flex &#123;\n    display: flex;\n    // flex 方向：row => 水平；column：垂直；\n    flex-direction: row;\n    // 和 flex 方向垂直方向居中。\n    aligin-items: center;\n    // 和 flex 方向相同方向居中\n    justify-content: center;\n    // 如果项目溢出对齐容器，那么项目将按照对齐模式为 start 的方式进行对齐。所需的对齐方式将无法实现。\n    justify-content: safe center;\n    // 每个元素之间的间距 8 个像素\n    gap: 8px;\n&#125;\n\n.flex-item &#123;\n    // flex 代表三个属性：flex-grow, flex-shrink, flex-basis\n    // 默认值，相当于 flex：1 1 auto\n    flex: auto; \n    // flex: 1 => flex: 1 1 0%\n    flex: 1;\n&#125;\ngrid 布局\n.grid &#123;\n    display: grid;\n    // 两列均分，但是某个子元素宽度很大会出现不均分现象，可以给子元素添加 overflow: hidden;解决。\n    grid-template-columns: repeat(2, 1fr);\n    grid-template-rows: repeat(2, 1fr);\n    aligin-items: center;\n    justify-content: center;\n&#125;\n","slug":"css","date":"2023-09-14T03:15:44.609Z","categories_index":"CSS","tags_index":"css,多行文本省略号,下划线距离,图片size,打印样式,flex,grid","author_index":"Kidwen"},{"id":"59c81fa299a5b5a3e4d483bdbaaf4a4b","title":"Types vs interfaces","content":"在 TypeScript 中，有两种主要的工具来声明对象的形状，即接口（interfaces）和类型别名（type aliases）。\n它们非常相似，对于大多数常见情况，它们的行为都是相同的。\n由于 TypeScript 是一种结构类型系统，因此可以混合使用它们。\n相似之处\n\n\n用途相似: 类型别名和接口都用于声明和定义对象的形状或结构，以及自定义类型。\n\n\n扩展性: 它们都支持扩展其他接口和类型，以帮助组织和重用代码。\n\n\n混合使用: 由于 TypeScript 的结构类型系统，您可以混合使用它们，并根据需要选择使用接口或类型别名。\n\n\n不同之处\n\n\n开放性 vs 封闭性: 接口是开放的（open），可以在不同地方多次声明并扩展，而类型别名是封闭的（closed），一旦声明后无法在外部进行修改。\n\n\n错误消息: 通常情况下，使用接口会得到更清晰和更详细的错误消息，有助于更容易地诊断问题。\n\n\n关键字: 接口使用关键字 interface 来声明，而类型别名使用关键字 type 来声明。\n\n\n适用场景: 对于公开暴露的类型，特别是用于定义公共 API 的类型，更推荐使用接口，而类型别名可以更适用于描述固定和不变的类型结构。\n\n\n示例\ntype BirdType = &#123;\n    wings: 2;\n&#125;;\n\ninterface BirdInterface &#123;\n    wings: 2;\n&#125;;\n\nconst bird1: BirdType = &#123; wings: 2 &#125;;\nconst bird2: BirdInterface = &#123; wings: 2 &#125;;\n\nconst bird3: BirdInterface = bird1;\n\n// 它们都支持扩展其他接口和类型。\n// 类型别名通过交叉类型（intersection types）实现这一点，而接口则使用一个关键字。\n\ntype Owl = &#123; nocturnal: true &#125; &#x26; BirdType;\ntype Robin = &#123; nocturnal: false &#125; &#x26; BirdInterface;\n\ninterface Peacock extends BirdType &#123;\n    colourful: true;\n    flies: false;\n&#125;;\n\ninterface Chicken extends BirdInterface &#123;\n    colourful: false;\n    flies: false;\n&#125;;\n\nlet owl: Owl = &#123; wings: 2, nocturnal: true &#125;;\nlet chicken: Chicken = &#123; wings: 2, colourful: false, flies: false &#125;;\n\n// 尽管如此，建议是在使用时选择接口而不是类型别名。具体来说，因为接口定义可以获得更好的错误消息。\n// 鼠标悬停在以下错误上方，可以看到 TypeScript 在使用像 Chicken 这样的接口时如何提供更简洁和更专注的错误消息。\n\nowl = chicken;\nchicken = owl;\n\n// 类型别名和接口之间的一个主要区别是，接口是开放的（open），而类型别名是封闭的（closed）。\n// 在不同的地方可以多次声明同一个接口，并在每次声明时扩展它。\n// 这种方式允许您在不同部分的代码中逐渐增加接口的属性和方法，而不需要修改原始接口的定义。\n\ninterface Kitten &#123;\n    purrs: boolean;\n&#125;\n\ninterface Kitten &#123;\n    colour: string;\n&#125;\n\n// 在另一种情况下，类型别名在其声明之外无法更改。\n\ntype Puppy = &#123;\n    color: string;\n&#125;;\n\n// 错误信息:\n// Duplicate identifier 'Puppy'.(2300)\ntype Puppy = &#123;\n    toys: number;\n&#125;;\n\n// 根据您的目标，这种差异可能是积极的也可能是消极的。\n// 但是，对于公开暴露的类型，更好的做法是将它们定义为接口。\n// 查看 Stack Overflow 可以了解更多关于类型别名和接口之间的各种边界情况:\n// https://stackoverflow.com/questions/37233735/typescript-interfaces-vs-types/52682220#52682220\n\n\nOutput\n\"use strict\";\nconst bird1 = &#123; wings: 2 &#125;;\nconst bird2 = &#123; wings: 2 &#125;;\nconst bird3 = bird1;\nlet owl = &#123; wings: 2, nocturnal: true &#125;;\nlet chicken = &#123; wings: 2, colourful: false, flies: false &#125;;\n\n// 错误信息:\n// Type 'Chicken' is not assignable to type 'Owl'.\n//     Property 'nocturnal' is missing in type 'Chicken' but required in type '&#123; nocturnal: true; &#125;'.(2322)\n// input.tsx(row num, column num): 'nocturnal' is declared here.\nowl = chicken;\n\n// 错误信息:\n// Type 'Owl' is missing the following properties from type 'Chicken': colourful, flies(2739)\nchicken = owl;\n\n\n\n\nCompiler Options\n&#123;\n    \"compilerOptions\": &#123;\n        \"strict\": true,\n        \"noImplicitAny\": true,\n        \"strictNullChecks\": true,\n        \"strictFunctionTypes\": true,\n        \"strictPropertyInitialization\": true,\n        \"strictBindCallApply\": true,\n        \"noImplicitThis\": true,\n        \"noImplicitReturns\": true,\n        \"alwaysStrict\": true,\n        \"esModuleInterop\": true,\n        \"declaration\": true,\n        \"target\": \"ES2017\",\n        \"jsx\": \"react\",\n        \"module\": \"ESNext\",\n        \"moduleResolution\": \"node\"\n    &#125;\n&#125;\n\n\nPlayground Link: Provided\n","slug":"interface-type","date":"2023-09-06T02:30:00.000Z","categories_index":"TYPESCRIPT","tags_index":"typescript","author_index":"Kidwen"},{"id":"fb3363481004ec8369d06d0e47a49849","title":"stable diffusion prompt","content":"The first step to gennerate a image is to write a series of prompt. The prompt include positive and negative words.\nAlso you can use othe ai tools like chatgpt to generate the prompt.\nOr use 元  素  法  典 to select what you want.\n:::details Cute little gitl\nprompt\ncute little girl,solo,wind,pale-blonde hair, blue eyes,very long twintails,white hat,blue sky,laugh,double tooth,lens flare,dramatic, coastal,\nflying petal, flowery field, sky, sun,field, sunflower, masterpiece, best quality,\nnegative prompt\n(mutated hands and fingers:1.5 ),(mutation, poorly drawn :1.2),(long body :1.3),(mutation, poorly drawn :1.2),liquid body,text font ui,long neck,uncoordinated body,fused ears,(ugly:1.4),one hand with more than 5 fingers,one hand with less than 5 fingers,\nresult\n\n:::\nHow to write.\n\n\nThree stage.\nquality words, subject, background.\nThe words quality and effect are placed at the forefront.\nPut the description of the subject to be generated.\nBackground: flowerymeadow, feather, sunlight, river, Brokenglass\n\nBREAK: split the clip, split different description.\n\n\n\nNature language\n\n\n:::details angel girl\nprompt\nflat design,\n(official art:1.2)\n(white background:1.2),\ndepth of field, double exposure,\n(There is a big world tree with magic:1.2),\n(She is inside the world tree:1.2),\n1girl,solo,fullbody,\n(She is a angel with beautiful detailed eyes with crystal textured hair with beautiful detailed face with (clothes)+(beautiful transparent wing)),\n(She is a angel with red eyes with white hair with (clothes)+(light wings)),\n(She is a girl with long flowing hair with the hair between the eyes),\n(She with white dress with detached Sleeve with off_shoulder clothes),\n(She with symmetrical wings with transparent wings with mechanical wings),\n(She is a sitting girl with small breasts with (wariza:1.2)),\n(She is far away form viewers and looking at viewers with (from side:0.5)),\n(She is beside the floating cubes:1.4),\n(super fucking cool golden light:1.2),\n(white background:1.2),\nirradiance particles, ray tracing,(The broken floor:1.3),\ndepth of field, tyndall effect, double exposure,\nvisual impact,((Ink mist,Coloured lead painting,[[Gouache painting]]):1.5)\n(Glitch Art:1.414)\nresult\n\n:::\nSampler.\nEuler A is the best choice between speed and quality. DDIM and Euler are particularly good at delicate painting styles when they are lucky. The DPM series has its own advantages and disadvantages, and some of them have extremely good performance at low steps (the three DPM brothers are about the same at 15 to 20 steps)\nSyntax.\n\n\n[A:B:X]: render A to X step,then B.\n\n\n[A:0.5]: render A when step is 0.5.\n\n\n[A::X]: stop render A when step is X.\n\n\n[A|B]: alternate render A and B.\n\n\nInstall stable diffusion webui.\n:::danger\nNeed python v3.10.6.\n:::\nSuggestion Models.\n:::danger\nDo not use .ckpt model, unless you trust it.\n:::\n\n\nSDHK V3\n\n\nAnything V5/ink\n\n\nCF V3\n\n\nChilloutmix\n\n\n","slug":"prompt","date":"2023-09-04T03:00:00.000Z","categories_index":"AI","tags_index":"propmt","author_index":"Kidwen"},{"id":"14636ce7004e6638283e21fb0f0673ff","title":"linux","content":"linux 系统学习笔记，学习Linux系统的命令是一个循序渐进的过程，这里记录了一些常用命令和参数。包括文件和目录操作，文件内容查看和编辑，系统信息和管理。\n文件和目录操作命令：\nls: 列出目录内容\n\n示例：ls -l（显示详细信息）、ls -a（显示隐藏文件）。\n\n\n参数\n\n\n-l: 以详细列表形式显示文件和目录的信息，包括权限、所有者、大小、日期等。\n\ndrwxr-xr-x 表示一个目录，-rw-r--r-- 表示一个普通文件。\n\n\n\n-a: 显示所有文件和目录，包括隐藏文件（以.开头的文件和目录）。\n\n\n-h: 人类可读的文件大小，例如显示为 KB、MB 等。\n\n\n-t: 按修改时间排序显示文件和目录。\n:::\n\n\ncd: 切换目录。\n\n示例：cd /path/to/directory。\n\npwd: 显示当前工作目录的路径。\nmkdir: 创建新目录。\n\n示例：mkdir new_directory。\n\ntouch: 创建空文件。\n\n示例：touch new_file.txt。\n\ncp: 复制文件或目录。\n\n示例：cp file.txt /path/to/destination。\n\nmv: 移动文件或目录，也可用于重命名。\n\n示例：mv file.txt /path/to/destination、mv old_name new_name。\n\nrm: 删除文件或目录。\n\n示例：rm file.txt（删除文件）、rm -r directory（删除目录及其内容，慎用！）。\n\n文件内容查看和编辑命令：\ncat: 显示文件内容。\n\n示例：cat file.txt。\n\nmore / less 分页查看文件内容。\n\n示例：more file.txt、less file.txt。\n\nhead / tail: 查看文件开头或结尾部分。\n\n示例：head file.txt、tail -n 10 file.txt（显示最后10行）。\n\nnano / vim: 使用文本编辑器编辑文件。\n\n示例：nano file.txt、vim file.txt。\n\n系统信息和管理命令：\nuname: 显示系统信息。\n\n示例：uname -a。\n\ntop: 实时显示系统资源使用情况。\nps: 显示进程信息。\n\n示例：ps aux。\n\nkill: 终止进程。\n\n示例：kill process_id。\n\ndf: 显示磁盘空间使用情况。\n\n示例：df -h。\n\ndu: 显示文件和目录的磁盘使用情况。\n\n示例：du -sh directory。\n\nchmod: 修改文件或目录的权限。\n\n示例：chmod 755 file.txt、chmod +x script.sh。\n\nchown: 更改文件或目录的所有者。\n\n示例：chown user:group file.txt。\n\ndmesg | egrep -i -B100 ‘killed process’: 显示内核日志\n\n\n\n磁盘和文件系统管理命令：\nfdisk / parted: 磁盘分区管理工具。\n\n示例：fdisk /dev/sda。\n\nmkfs: 创建文件系统。\n\n示例：mkfs.ext4 /dev/sda1。\n\nmount / umount: 挂载和卸载文件系统。\n\n示例：mount /dev/sdb1 /mnt、umount /mnt。\n\n硬件信息和监控命令：\nlshw / hwinfo: 显示硬件信息。\n\n示例：sudo lshw。\n\niotop: 监控磁盘I/O使用情况。\n\n示例：sudo iotop。\n\nnvidia-smi: 显示NVIDIA GPU状态。\n\n示例：nvidia-smi。\n\n网络命令：\nping: 测试网络连接是否正常。\n\n示例：ping google.com。\n\nifconfig / ip: 显示网络接口信息。\n\n示例：ifconfig、ip addr show。\n\nnetstat: 显示网络统计信息。\n\n示例：netstat -tuln（显示开放的端口）。\n\nssh: 远程连接到其他计算机。\n\n示例：ssh user@hostname。\n\nscp: 在本地主机和远程主机之间复制文件。\n\n示例：scp file.txt user@remotehost:/path/to/destination。\n\n软件包管理命令（适用于基于包管理的发行版）：\napt / apt-get: Debian/Ubuntu系列的包管理工具。\n\n示例：sudo apt-get install package_name。\n\nyum / dnf: Red Hat/CentOS系列的包管理工具。\n\n示例：sudo yum install package_name。\n\npacman: Arch Linux系列的包管理工具。\n\n示例：sudo pacman -S package_name。\n\n用户和权限管理命令：\nuseradd / adduser: 添加新用户账号。\n\n示例：sudo adduser new_user。\n\npasswd: 更改用户密码。\n\n示例：passwd username。\n\nsudo: 以超级用户权限执行命令。\n\n示例：sudo command。\n\n压缩和解压命令：\ntar: 创建和解压 tar 归档文件。\n\n示例：tar -cvf archive.tar files、tar -xvf archive.tar。\n\n:::details 参数\n\n-c: 创建归档文件。\n-x: 解压缩归档文件。\n-f file: 指定归档文件的名称。\n-v: 显示操作的详细信息。\n-z: 以 gzip 压缩或解压缩。\n-j: 以 bzip2 压缩或解压缩。\n-t: 查看归档文件中的内容。\n\n在上面的示例中，显示了一些命令历史记录，每一行都包括一个序号和相应的命令。通过序号来重新执行之前执行过的命令，如 !5 将重新执行序号为 5 的命令。\n:::\ngzip / gunzip: 压缩和解压 .gz 文件。\n\n示例：gzip file.txt、gunzip file.txt.gz。\n\n时间和日期命令：\ndate: 显示当前日期和时间。\n\n示例：date。\n\ncal: 显示日历。\n\n示例：cal。\n\nShell脚本和编程命令：\nbash: 运行Bash脚本。\n\n示例：bash script.sh。\n\nsource / .: 在当前Shell环境中执行脚本。\n\n示例：. script.sh、source script.sh。\n\n数据处理和文本处理命令：\ngrep: 在文件中搜索匹配的文本。\n\n示例：grep &quot;pattern&quot; file.txt。\n\nsed: 使用正则表达式编辑文本。\n\n示例：sed 's/old/new/' file.txt。\n\nawk: 处理文本数据流并生成报告。\n\n示例：awk '{print $1}' file.txt。\n\n进程管理命令：\nbg / fg: 将进程放入后台 / 将进程带回前台。\njobs: 显示后台进程。\n定时任务和后台任务管理命令：\ncron / crontab: 设置定时任务。\n\n示例：crontab -e（编辑定时任务）。\n\nat: 在指定时间运行一次性任务。\n\n示例：at now + 1 hour。\n\nscreen / tmux: 创建会话以管理后台任务。\n\n示例：screen（启动会话）。\n\n其他实用命令：\nhistory: 显示最近执行过的命令历史。\n\n示例：history。\n\n:::details 参数\n\n-c: 清空命令历史记录。\n-a: 将当前会话的命令追加到历史记录中。\n-d num: 删除历史记录中指定序号的命令。\n\nls\ncd Documents\nnano file.txt\ngcc program.c -o program\n./program\nhistory\n在上面的示例中，显示了一些命令历史记录，每一行都包括一个序号和相应的命令。通过序号来重新执行之前执行过的命令，如 !5 将重新执行序号为 5 的命令。\n:::\n:::details 查询\n# 查询包含 grep 后面字符串的历史命令\nhistory | grep 'sudo vim'\n\n\nclear / Ctrl+L: 清屏。\necho: 打印文本到标准输出。\n\n示例：echo &quot;Hello, World!&quot;。\n\n","slug":"linux","date":"2023-08-29T08:30:00.000Z","categories_index":"LINUX","tags_index":"linux,terminal","author_index":"Kidwen"},{"id":"becd74c70d95c6147499a836d0737d46","title":"mermaid","content":" -->\nhexo with mermaind\n\n\ninstall dependence\n     yarn add hexo-filter-mermaid-diagrams\n\n\nconfig hexo\n     # /_config.yml\n    mermaid:\n      enable: true\n      version: \"7.1.2\"\n      # cdn: //cdn.jsdelivr.net/npm/mermaid@8.4.2/dist/mermaid.min.js\n      #cdn: //cdnjs.cloudflare.com/ajax/libs/mermaid/8.3.1/mermaid.min.js\n      options: # 更多配置信息可以参考 https://mermaidjs.github.io/#/mermaidAPI\n        theme: 'default'\n        startOnLoad: true\n        flowchart:\n          useMaxWidth: false\n          htmlLabels: true\n\n\n\n\n\n\n\n\n\n\n\n 🤡 🤡 🤡 \nI have used hexo theme with aurora, try inject script in _config.aurora.yml file like this:\ninjects:\n  scripts:\n    - &#x3C;script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'>&#x3C;/script>\nBut it not work.\nSo i add a polyfills file to listen the window history change and page refresh\n\nCheck what you want to copy to your config file\nconst rewriteHistoryChangeStateFn = (type, callback) => &#123;\n    const prevHistoryFn = window.history[type];\n    window.history[type] = (...args) => &#123;\n        const ret = prevHistoryFn.apply(window.history, > args);\n        callback();\n        return ret;\n    &#125;;\n&#125;;\n\nrewriteHistoryChangeStateFn(\"pushState\", () => addJs());\nwindow.addEventListener('popstate', () => addJs());\nwindow.addEventListener(\"load\", () => addJs());\n\nconst scripts = [];\nlet id = 0;\n\nconst addJs = () => &#123;\n    scripts.forEach(item => &#123;\n        item.remove();\n    &#125;);\n    if(window.location.href.includes('mermaid')) &#123;\n        createScript('/downloads/script/mermaid.js')\n    &#125;\n    if (window.location.href.includes('aiPhoto')) &#123;\n        createScript('/downloads/script/album.js')\n    &#125;\n&#125;\n\nconst createScript = (src) => &#123;\n    const script = document.createElement('script');\n    script.src = src;\n    script.id = id;\n    scripts.push(script)\n    document.getElementsByTagName('body')> [0].appendChild(script);\n&#125;\n\n\ninjects:\n  scripts:\n    - &#x3C;script src='/downloads/script/polyfills.js'>&#x3C;/script>\n\ngraph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;\nsequenceDiagram\n    participant Alice\n    participant Bob\n    Alice->>John: Hello John, how are you?\n    loop Healthcheck\n        John->>John: Fight against hypochondria\n    end\n    Note right of John: Rational thoughts prevail...\n    John-->>Alice: Great!\n    John->>Bob: How about you?\n    Bob-->>John: Jolly good!\ngantt\ndateFormat  YYYY-MM-DD\ntitle Adding GANTT diagram to mermaid\n\nsection A section\nCompleted task            :done,    des1, 2014-01-06,2014-01-08\nActive task               :active,  des2, 2014-01-09, 3d\nFuture task               :         des3, after des2, 5d\nFuture task2               :         des4, after des3, 5d\nclassDiagram\nClass01  C2 : Where am i?\nClass09 --* C3\nClass09 --|> Class07\nClass07 : equals()\nClass07 : Object[] elementData\nClass01 : size()\nClass01 : int chimp\nClass01 : int gorilla\nClass08  C2: Cool label\ngitGraph:\noptions\n{\n    \"nodeSpacing\": 150,\n    \"nodeRadius\": 10\n}\nend\ncommit\nbranch newbranch\ncheckout newbranch\ncommit\ncommit\ncheckout master\ncommit\ncommit\nmerge newbranch\n","slug":"mermaid","date":"2023-07-27T11:00:00.000Z","categories_index":"TOOL","tags_index":"chart","author_index":"Kidwen"},{"id":"67a0811293cd2bc9df0f8e11e20e867f","title":"angular v16 signal api 介绍","content":"本文介绍 Angular signal库的 API 接口和一些实现细节。\n\nsignal在Angular中是一种具有明确变更语义的值。在 Angular 中，signal通过一个零参数的getter函数来表示，该函数返回当前signal的值。\n在这个getter函数中会使用 SIGNAL 符号进行标记，这样Angular框架就能够识别它是一个signal，并且可以应用一些内部的优化措施来提升性能。\nsignal是只读的，意味着我们可以获取当前signal的值，但不能直接修改它。我们可以观察signal的变化通知，以便在值发生变化时做出相应的处理。这种只读的特性使得signal在响应式编程中非常有用，因为它们可以用于实现数据的观察和响应。\n这个getter函数被用于获取当前signal的值，并在响应式编程的上下文中记录signal的读取操作。这个操作对于构建响应式依赖图来说非常关键。在 Angular 中，响应式依赖图用于追踪数据的依赖关系，当依赖的数据发生变化时，相关的部分会得到更新。这种机制使得 Angular 能够高效地处理数据的变化和重新渲染视图。\n在响应式上下文之外，我们仍然可以对signal进行读取操作。这使得非响应式的代码（比如现有的、来自第三方的库）可以随时读取signal的值，而无需了解signal的响应式特性。这种设计使得signal可以在现有的代码中轻松地使用，而不需要对现有代码做任何修改。\ninterface Signal&#x3C;T> &#123;\n    (): T;\n    [SIGNAL]: unknown;\n&#125;\nWritable signals\nAngular signals库将提供可写signal的默认实现，可以通过内置的修改方法（set、update、mutate）进行更改：\ninterface WritableSignal&#x3C;T> extends Signal&#x3C;T> &#123;\n    /**\n     * 我们可以直接使用设置方法（set）将`signal`的值设置为一个新的值。\n     * 当`signal`的值发生变化，它会自动通知所有依赖于这个`signal`的部分，从而触发相应的更新。\n     * 这种自动通知机制是响应式编程的核心，它确保了数据的一致性和同步，使得我们能够有效地处理数据的变化，并及时反映到界面上。\n     *\n     * 使用可写`signal`的 set 方法在以下情况下非常有用：\n     * 1. 当我们需要更改原始值（例如数字、字符串等）时，直接使用 set 方法可以非常方便地更新`signal`的值。\n     * 2. 当新值与旧值之间没有依赖关系时，也就是说，新值不依赖于旧值的任何信息，我们可以直接使用 set 方法替换整个数据结构。\n     */\n    set(value: T): void;\n\n    /**\n     * 使用可写`signal`的 update 方法可以基于当前`signal`的值进行更新。\n     * 你可以提供一个更新函数，该函数将根据当前`signal`的值计算新的值，并将新值应用到`signal`上。\n     * 当`signal`的值发生变化，它会自动通知所有依赖于这个`signal`的部分，从而触发相应的更新。\n     * 使用 update 方法可以非常方便地对`signal`的值进行递增、递减或应用其他自定义的计算逻辑。\n     * 这使得数据的更新更加灵活和自由，同时保持了响应式编程的特性，确保数据的一致性和同步。\n     * \n     * 1. 当我们需要设置一个新值，而这个新值依赖于旧值时，可以使用 update 方法。\n     * 例如，我们要对一个不可变的数据结构进行更新，可以通过提供一个更新函数来计算新的数据结构，并将其应用到`signal`上。\n     * 2. 在不可变的数据结构中，我们不能直接修改已有的数据，而是需要创建一个新的数据结构来表示修改后的结果。\n     * 使用 update 方法可以方便地进行这样的操作，而不需要手动处理数据的复制和更新。\n     */\n    update(updateFn: (value: T) => T): void;\n\n    /**\n     * 使用可写`signal`的 mutate 方法可以直接在当前值上进行修改。\n     * 你可以提供一个修改函数，该函数将在当前值上进行原地修改，并将修改后的值应用到`signal`上。\n     * 当`signal`的值发生变化，它会自动通知所有依赖于这个`signal`的部分，从而触发相应的更新。\n     * 使用 mutate 方法可以方便地进行直接修改数据的操作，而不需要创建新的数据结构。\n     * 这对于某些特定的场景和数据结构的处理非常有帮助。\n     * 需要注意的是，这种方法是在原地修改数据，因此在使用时需要谨慎，确保不会导致数据的不一致或错误。\n     * \n     * 使用可写`signal`的 mutate 方法在以下情况下非常有用：\n     * 1. 当我们需要对`signal`的值进行内部修改，而不改变`signal`本身的引用（即身份）时，可以使用 mutate 方法。\n     * 例如，我们可以通过提供一个修改函数，在`signal`中存储的数组上添加新元素，而不需要创建一个新的数组，从而保持`signal`的引用不变。\n     * 1. mutate 方法可以用于原地修改`signal`的值，而不需要重新分配内存或创建新的数据结构，\n     * 这在一些性能敏感的情况下很有用。\n     */\n    mutate(mutatorFn: (value: T) => void): void;\n\n    /**\n     * 我们可以通过某种方式从一个可写`signal`派生出一个新的`signal`，这个新`signal`是只读的，即不能修改它的值。\n     * 这个只读`signal`仍然可以访问原始可写`signal`的值，但不允许对原始`signal`的值进行修改。\n     * \n     * 这种操作在某些场景下很有用，比如我们希望将一个可写`signal`暴露给其他部分，但不希望其他部分对该`signal`进行修改，以保持数据的一致性和可控性。\n     * 通过返回一个非可写`signal`，我们可以确保原始`signal`的值只能在特定的上下文中被修改，而其他地方只能读取它的值。\n     */\n    asReadonly(): Signal&#x3C;T>;\n&#125;\n我们可以通过调用signal的创建函数来创建一个可写signal实例。\n在 Angular 中，这个signal创建函数通常是指从 @angular/core 模块中导入的 createSignal 函数。\n通过调用这个函数，我们可以创建一个新的signal实例，这个signal实例可以用于存储和管理数据，并允许在需要时进行设置或更新。\n这样的signal实例通常是可写的，我们可以使用 set、update 或 mutate方法来改变它的值。\nfunction signal&#x3C;T>(\n  initialValue: T,\n  options?: &#123;equal?: (a: T, b: T) => boolean&#125;\n): WritableSignal&#x3C;T>;\n示例：\n// 创建一个可写 signal\nconst counter = signal(0);\n\n// 为 signal 设置新的值, 完全替换当前值\ncounter.set(5);\n\n// 基于当前值更新 signal 的值\ncounter.update(currentValue => currentValue + 1);\n在 Angular 中，Signal和WritableSignal的接口命名通常遵循以下命名约定：\nSignal 作为主要接口的命名，并且这个接口表示一个只读的值随时间变化。为 Signal 这个主要接口选择这个名称是因为其简短、易于发现，并且预计它会成为最常见的被导入和使用的接口。\n另一方面，WritableSignal 是一个相对特殊化的接口，它在名称中添加了 writable 表示在这些类型的signal上允许进行额外的操作，即允许对其值进行修改。\n这样的命名方案旨在提供清晰简洁的名称，使得开发者在使用该库时能够轻松区分只读signal和可写signal，并根据实际需求选择正确的接口。\nEquality\nIt is possible to, optionally, specify an equality comparator function. If the equality function determines that 2 values are equal, and if not equal, writable signal implementation will:\n\nblock update of signal’s value\nskip change propagation.\n\n默认情况下，当signal中的值为原始值（例如数字、字符串等）时，使用 === 来比较它们的相等性。如果新旧值相等，变更通知将被跳过，不会触发变更事件。但是，当signal中的值为对象或数组时，相等比较器函数将始终视它们为不相等，即使它们的内容相同也不会被认为是相等的。\n这样的默认行为允许signal存储和传播非原始值（例如对象、数组），即使对象或数组的内容没有实际改变，只要其引用发生了变化，signal仍然可以触发变更通知。这样可以确保signal对非原始值的处理更加灵活和准确，而不仅仅依赖于值的内容是否发生变化。\nconst todos = signal&#x3C;Array&#x3C;Todo>>([&#123;todo: 'Open RFC', done: true&#125;]);\n\n// 我们可以更新列表，即使没有使用不可变数据，仍然触发变更通知。\ntodos.update(todosList => &#123;\n    todosList.push(&#123;todo: 'Respond to RFC comments', done: false&#125;);\n    return todoList;\n&#125;);\nsignal概念的实现并不限于特定的方式。无论是Angular还是第三方库，都可以创建定制的signal实现，只要它们保持了与signal相关的底层契约（也就是接口和功能）不变即可。\n这种灵活性允许开发者根据自己的需求和场景来创建符合特定要求的signal实现。无论使用哪种实现方式，只要它们遵循signal的基本规则和契约，就能在Angular应用中实现类似的signal功能，并在需要时触发变更通知和响应式处理。这样的设计有助于推动模块化和可扩展性，让开发者能够更好地适应不同的业务需求。\n.set 是signal的基本操作，.update 是一个方便的方法。\n虽然signal的 API 表面上提供了三种不同的方法来改变signal的值，但实际上，.set(newValue) 是库中唯一需要的基本操作。这是设置signal值的主要方法，其他两种方法.update 和 .mutate 只是提供了更方便的方式来进行signal值的更新，其功能可以通过调用 .set 来实现。\n使用 .update 方法可以根据当前signal的值计算新的值并进行更新，而使用 .mutate 方法可以在当前值上进行原地修改。但这两种方法在功能上可以等效为使用 .set 方法，因为它们都是对signal的值进行更新。因此，.set 是signal库中唯一需要的基本操作，而其他两种方法只是在使用上更加便利和语法上更加简洁的方式。\n// 创建一个可写 `signal`\nconst counter = signal(0);\n\n// 基于当前值更新 `signal` 的值\ncounter.update(c => c + 1);\n\n// 相同功能可以不使用 .update, 而是 .set\ncounter.set(counter.get() + 1);\n尽管所有的操作都可以仅通过使用 .set 来完成，但在某些特定的使用情况下，使用 .update 会更加方便和简洁，因此它被添加到了公共 API 中。\n虽然 .set 是signal的基本操作，允许直接设置signal的值，但在某些场景中，使用 .update 更加方便，因为它允许我们提供一个更新函数，根据当前signal的值计算新的值并进行更新，从而使代码更加简洁和灵活。因此，尽管 .set 是必需的基本操作，.update 作为一种方便的操作也被引入到了公共 API 表面，以满足不同的使用需求。\n.mutate 用于就地更改值\n.mutate 方法的用途。.mutate 方法允许我们通过直接在signal值上进行原地修改来改变signal的值。这种操作主要适用于signal持有的值是非原始 JavaScript 值，例如数组或对象。\n例如，我们可以使用 .mutate 方法来对一个数组signal进行原地修改，比如向数组中添加元素、删除元素或对元素进行修改，而不是通过创建新的数组来实现。这样的原地修改在某些情况下可以提供更高的性能和效率，尤其是当signal值较大或需要频繁修改时。\n总的来说，.mutate 方法是一种用于在signal中原地修改值的方便方法，适用于非原始值的signal，如数组或对象。\nconst todos = signal&#x3C;Todo[]>([&#123;todo: 'Open RFC', done: true&#125;]);\n\n// 我们可以更新列表，即使没有使用不可变数据，仍然触发变更通知。\ntodos.mutate(todosList => &#123;\n    todosList.push(&#123;todo: 'Respond to RFC comments', done: false&#125;);\n&#125;);\n.mutate 方法的特点。无论signal使用何种自定义的相等性检查，.mutate 方法始终会触发变更通知。这意味着，即使修改了signal的值但未触发自定义相等性检查，仍会发送变更通知，确保其他依赖于signal的部分能够得到更新。\n通过使用 .mutate 方法和默认的相等比较器函数，signal库可以同时处理可变和不可变的数据。这使得signal在处理数据时更加灵活，无需局限于特定的数据处理方式。这样的设计决策有助于保持灵活性，让开发者可以根据具体场景选择最合适的数据处理方式，无论是可变数据还是不可变数据。\n读/写分离\nsignal库的设计选择。在该库中，主要的响应式基元是 Signal 类型，而且它是只读的。这意味着可以使用signal传播响应式的值给其他组件或订阅者，但是这些消费者不能直接修改signal的值。\n这样的设计可以带来一些好处。首先，它确保了响应式数据的单向流动，防止不必要的数据修改。其次，它增强了代码的可维护性和可预测性，因为只有特定的组件或服务可以修改signal的值，其他消费者只能读取数据。这种封装性使得代码更加健壮，并减少了潜在的副作用和数据冲突。\n通过将signal的读写能力分开，signal库鼓励在应用程序中采用良好的数据流架构模式。具体来说，signal库通过将signal设计为只读的 Signal&lt;T&gt; 类型和可写的 WritableSignal&lt;T&gt; 类型，使得对状态的修改必须通过持有 WritableSignal 的所有者来进行，而不能在应用程序的任意地方进行修改。\nGetter 方法\n在 Angular 中选择的实现中，signal是通过 getter 函数来表示的。以下是使用这种 API 的一些优点：\n\n它是内置的 JavaScript 结构，这使得signal的读取在 TypeScript 代码和模板表达式之间保持一致。\n它明确指示了signal的主要操作是读取（read）。\n它清楚地表明了不仅仅是简单的属性访问在发生。\n它的语法非常轻量级，因为读取signal是一个非常常见的操作。\n\ngetter 函数的缺点\n\n\n\n\n\n\n\n\n\n模板中的函数调用\n在 Angular 中，模板中的函数调用会触发组件的变更检测机制，而这个机制在频繁调用时可能会导致性能问题。因此，开发者通常会避免在模板中调用复杂或计算密集型的函数。\n但是，signal的 getter 函数是高效的访问器，它们执行的计算工作非常少。signal的 getter 函数通常只是返回signal的当前值，并不包含复杂的逻辑。因此，频繁调用signal的 getter 函数并不会引起性能问题，开发者无需担心在模板中使用signal的 getter 函数。\n这样的设计使得signal在 Angular 中成为一种高效和方便的方式来处理数据和状态，并可以在模板中直接使用，而不会导致性能上的问题。\n与类型缩窄的交互\n在代码中\nif (user.name()) &#123;\n  console.log(user.name().first); // 由于ts不能知道每次方法调用是否会返回相同的值所以此处会报错\n&#125;\n可以如下解决\nconst name = user.name();\nif (name) &#123;\n  console.log(name.first);\n&#125;\n但是在模版中没有办法声明中间变量（可以自动创建此类变量来解决此类问题）。\nComputed signals\n类似于 vue 计算属性\nconst counter = signal(0);\n\nconst isEven = computed(() => counter() % 2 === 0);\n\nconst color = computed(() => isEven() ? 'red' : 'blue');\n签名类型：\nfunction computed&#x3C;T>(\n  computation: () => T,\n  options?: &#123;equal?: (a: T, b: T) => boolean&#125;\n): Signal&#x3C;T>;\n与可写signal类似，计算signal可以（可选）指定等式函数。当提供时，如果确定两个值相等，则相等函数可以停止更深层次依赖链的重新计算。示例（默认相等）：\nconst counter = signal(0);\n\nconst isEven = computed(() => counter() % 2 === 0);\n\nconst color = computed(() => isEven() ? 'red' : 'blue');\n\n// 提供一个不同的复数值给 counter 意味着：\n// - isEven 重新计算（因为依赖值发生变化）\n// - color 不需要重新计算（因为isEvent()值没有发生变化）\ncounter.set(2);\nsignal在计算功能上所做的算法选择，并提供了这种实现的一些强大保证：\n\n延迟执行：计算函数只有在有人读取其值时才会被执行。这样可以避免不必要的计算开销，只有在需要计算值时才进行实际的计算操作。\n自动清理：一旦计算signal的引用超出作用域，它会自动成为垃圾回收的对象。这意味着不需要开发者显式地进行计算的清理操作，signal库会自动处理资源的释放。\n无故障执行：计算保证在依赖项发生变化时，只会执行最少次数的计算。这样可以避免计算过程中使用过时或中间状态的依赖值，从而确保计算的准确性和一致性。这种无故障执行机制也免除了需要显式执行“事务”或“批处理”操作的需求。\n\n在条件计算中，计算型signal可能根据读取的其他signal的不同值进行不同的计算。当计算型signal的计算过程中读取了其他signal时，它会将这些signal添加到自己的依赖集合中。如果后续这些依赖signal的值发生了变化，计算型signal会相应地知道自己需要重新计算，以确保计算的正确性。\n// 如果 `showName` `signal`发生变化，问候语将始终被重新计算，但如果 `showName` 为 `false`，则名称`signal`不是问候语的依赖项，也不会导致其重新计算。\nconst greeting = computed(() => showName() ? `Hello, $&#123;name()&#125;!` : 'Hello!');\nEffects\nEffect 是一种带有副作用的操作，它会读取一个或多个signal的值，并在任何这些signal发生变化时自动调度重新运行该操作。\n当一个 effect 被创建时，它会读取指定的signal的值，并在这些signal的值发生变化时自动触发重新运行。这样的设计使得 effect 能够对signal的变化作出相应的反应，并执行相应的副作用操作。\n例如，在一个 effect 中可以监听用户输入的变化signal和网络请求结果signal，一旦这些signal的值发生变化，effect 就会自动调度重新运行，执行与之相关的副作用操作，如更新界面或发起新的网络请求。\n一个 effect 的基本 API 具有以下签名：\nfunction effect(\n  effectFn: (onCleanup: (fn: () => void) => void) => void,\n  options?: CreateEffectOptions\n): EffectRef;\n使用：\nconst firstName = signal('John');\nconst lastName  = signal('Doe');\n\n// 这个 effect 会打印两个名字，也会在两个 signal 发生变化时自动打印\neffect(() => console.log(firstName(), lastName()));\nEffects 在应用程序中有多种用途，包括但不限于：\n\n同步多个独立模型之间的数据：当应用程序中存在多个独立的数据模型时，可能需要在它们之间保持数据同步。通过创建适当的effect，可以监听这些模型的变化并在数据发生变化时进行同步操作，从而确保各个模型之间的数据始终保持一致。\n触发网络请求：在应用程序中，常常需要根据用户的交互或其他条件触发网络请求，从而获取或更新数据。通过创建一个监听signal变化的 effect，可以在signal满足特定条件时自动发起网络请求，实现数据的获取和更新。\n执行渲染操作：在应用程序中，当数据发生变化时，需要将这些变化反映在界面上，以更新用户所见的内容。通过创建监听signal变化的 effect，可以在数据发生变化时自动执行渲染操作，更新界面，从而实现反应式的用户界面。\n除了上述的用例，Effect 还可以用于处理其他类型的副作用操作，如日志记录、权限控制、动画触发等。通过将这些副作用操作封装在 effect 中，可以实现代码的模块化和可维护性，并确保副作用操作的执行时机和正确性。\n\nEffect 函数可以选择性地注册一个清理函数。如果注册了清理函数，在下次 effect 运行之前，清理函数将被执行。清理函数可以用于“取消”之前的 effect 运行可能已经开始的任何工作。\neffect((onCleanup) => &#123;\n    const countValue = this.count();\n\n    let secsFromChange = 0;\n    const id = setInterval(() => &#123;\n      console.log(\n        `$&#123;countValue&#125; had its value unchanged for $&#123;++secsFromChange&#125; seconds`\n      );\n    &#125;, 1000);\n\n    onCleanup(() => &#123;\n      console.log('Clearing and re-scheduling effect');\n      clearInterval(id);\n    &#125;);\n&#125;);\neffects 调度时机\n在 Angular Signals 中，effect 必须在更改signal的操作完成后执行。\n考虑到 effect 的多种用例，存在各种可能的执行时间。因此，实际的 effect 执行时间不能保证，Angular 可能选择不同的策略。应用程序开发者不应依赖于任何观察到的执行时间。唯一可以保证的是：\n\neffect 将至少执行一次；\neffect 将在未来某个时刻响应其依赖项的变化而执行；\neffect 将最小化执行次数：如果一个 effect 依赖于多个signal，并且其中几个signal同时发生变化，只会调度一次 effect 执行。\n\neffect 执行的不确定性和最小化执行次数的保证。由于 effect 可能用于各种不同的场景，其执行时间可能会有很大的变化。Angular 并不保证 effect 的执行时间，可能会根据不同的情况选择不同的执行策略。\n虽然 effect 的执行时间不确定，但是 Angular 保证了上述的三个行为：effect 将至少执行一次，将在未来某个时刻响应其依赖项的变化而执行，并且在多个依赖项同时变化时最小化执行次数，只调度一次 effect 执行。这些保证使得 effect 的行为在合理范围内可预测，并且有助于提高应用程序的性能和可维护性。\n停止 effects\nEffect 在被创建后，会根据其依赖项的变化被自动调度运行，以响应数据的变化。这使得 effect 始终保持活动状态，并随时准备处理数据的变化。然而，这种“无限”生命周期并不是我们所期望的，因为 effect 应该在合适的时候进行关闭，以避免不必要的计算和资源浪费。\n为了解决这个问题，Angular 提供了一种机制来管理 effect 的生命周期，并在适当的时候关闭它们。通常情况下，effect 会在 Angular 组件或服务的生命周期结束时自动关闭。例如，当一个组件被销毁时，与该组件相关的 effect 也会被关闭。这样，我们可以确保在不再需要 effect 时，它们会被及时关闭，避免了不必要的计算和资源占用。\nAngular 的 effect 生命周期与组件或服务的销毁相关联。当一个组件或服务被销毁时，与之相关的 effect 也会被关闭，以确保它们不再执行任何副作用操作。\n在 Angular 中，组件和服务通常都会实现 OnDestroy 接口，该接口包含一个 ngOnDestroy() 方法，用于在组件或服务被销毁时进行一些清理操作。effect 会尝试注入当前组件或服务的 DestroyRef 实例，并在 ngOnDestroy() 方法中注册其停止函数。\n通过在 ngOnDestroy() 方法中注册 effect 的停止函数，我们可以确保 effect 在组件或服务被销毁时正确地进行关闭和清理。这样的设计使得 effect 能够与组件或服务的生命周期保持一致，并在合适的时候自动关闭，避免了可能出现的内存泄漏和资源浪费。\n对于需要更多对生命周期范围控制的情况，可以选择性地在创建 effect 时传递 manualCleanup 选项：\n// 如果设置了此选项，即使创建它的组件/指令被销毁，效果也不会自动销毁。\neffect(() => &#123;...&#125;, &#123;manualCleanup?: boolean&#125;);\n可以使用效果创建函数返回的 EffectRef 实例显式停止/销毁效果：\n// 创建 effect 并记录 effectRef\nconst effectRef = effect(() => &#123;...&#125;);\n\n// 显式停止/销毁此 effect\neffectRef.destroy();\nEffects 写入 signals\n不允许从 effect 中直接写入signal。Effect 函数用于处理副作用操作和响应式数据流的处理，其主要目的是读取signal并触发副作用操作，而不是用于写入signal的值。\n直接从 effect 中写入signal可能导致数据流的不稳定和难以跟踪的问题。例如，如果一个 effect 写入了一个signal的值，而该signal又被其他 effect 读取，可能会导致循环依赖和无限循环的问题。这样的数据流是难以理解和调试的，可能导致应用程序的不稳定性和性能问题。\n为了保持数据流的可靠性和可维护性，Angular 的设计决策是阻止在 effect 中直接写入signal。如果开发者尝试在 effect 中写入signal，Angular 将报告错误并阻止这样的操作。\n这种默认表现可以被配置项的allowSignalWrites覆盖。更建议使用计算signal。\nconst counter = signal(0);\nconst isBig = signal(false);\n\neffect(() => &#123;\n    if (counter() > 5) &#123;\n        isBig.set(true);\n    &#125; else &#123;\n        isBig.set(false);\n    &#125;      \n&#125;, &#123;allowSignalWrites: true&#125;);\n","slug":"angular-signal-api","date":"2023-07-21T08:00:00.000Z","categories_index":"ANGULAR","tags_index":"angular","author_index":"Kidwen"},{"id":"a7b5aeb1d279a19d567b0b432761bc79","title":"angular v16 signal 介绍","content":"2023年05月03日，angular v16 正式发布。此次更新添加了Signals作为angular新的响应单元(reactive primitive)。angular的响应式系统依赖于zone.js。但是zone.js对于模型的变更没有提供更细粒度的信息通知。zone.js只能够通知到angular程序中什么时候某些东西可能发生了改变，但是没有给到更多的信息关于发生了什么或者什么东西改变了。这代表着以后的某个版本zone.js将被移除。\nSignals 定义\nSignals 是值的包装，它能够在值发生变更的时候通知到相应的消费者。Signals 有多种类型。\n一些 Signals 可以通过 mutation Api 直接改变值，这些被称为 writable signals。模型的变更总是通过更改一个或者多个writable signals。\n由于读取signal是通过getter而不是访问普通变量或者值，所以signal可以知道他们在哪里被读取了。而且突变总是通过mutation Api完成的，所以Signals知道什么时候发生变更，并通知消费者有关变更的信息。\n\n\n\n\n\n\n\n\n\nSignals 特性\n\n能够通知 Angular 有关影响各个组件的模型更改。\n能够提供对模型的同步访问。\n读取值的时候无副作用。\n_glitch fre_e：读取值永远不应该返回不一致的状态。\n依赖性跟踪应该符合工程学。\n\n\n\n\n\n\n\n\n\n\nSignals 优点\n\n框架可以追踪模板中访问了那些signals，可以获取关于哪些组件被模型中的数据改变所影响的更细粒度的信息。\nSignals 可以同步获取到他们的值。\n读值不会造成副作用。\n现代Signals实现是无故障的，并且不会向用户暴露不一致的状态。\nSignals实现可以自动跟踪依赖关系。\nSignals可以在任何地方使用，而不仅仅是在组件中，这与 Angular 的依赖注入系统配合得很好。\n计算Signals可以是lazy，并且仅根据需要重新计算中间值。\n开发人员需要学习的概念相对较少。\n它们很容易与其他反应性系统组合，包括 RxJS 和 Angular 当前基于区域的反应性。\n\nComputed\ncomputed signal 不能直接改变，而是根据其他sinals的变化而变更，（类比vue的计算属性）。\nEffects\n当 Signals 发生变更后会通知消费者，当signals发生变更后执行的操作称为effect。例如当组件模板中的使用的signals发生变更时，angular会通过effect更新视图ui。\nAutomatic Dependency Tracking\n当computed signals 和effect运行时，它们会跟踪哪些signals被读取作为computed或effect函数的一部分。了解依赖关系允许signal系统在任何Signals依赖关系发生变化时自动重新运行computation或effect函数。\nSignals 集成\n:::danger\n由于zone.js和 signals基于不同的数据在应用程序中流经的不同的假设，而且使用zone.js编写的代码如果没有zone.js可能会无法运行。\n所以暂时不会移除zone.js，而是共存。\n:::\n\n\n\n\n\n\n\n\n\nSignals 将会影响 angular 多个地方\n数据流和模型同步\n变更检查过程\n组件生命周期\n框架产生的响应式数据（例如：@Input）\n与 zone.js 不同，Signals提供有关模型的哪些部分已更改的细粒度信息，基于Signals的组件不参与全局更改检测。相反，Angular 知道组件模板的不同部分使用了哪些Signals，并且仅在Signals更改时将该组件与 DOM 同步。\n当且仅当模板中读取的Signals通知 Angular 它已更改时，才会安排组件的更改检测。\n事实上，在当前的设计中，这种更改检测将针对组件内的每个视图独立发生。\nSignal-based 组件\n使用组件作为反应性系统之间的边界将允许应用程序开发人员逐渐选择在现有应用程序中发出反应性signal，并允许库作者将其库转换为以向后兼容的方式使用signal。\n局部变更检查\n当且仅当模板中读取的signal通知 Angular 它已发生更改时，才会安排组件的更改检测。\n在当前的设计中，这种变更检测将针对组件内的每个视图独立发生。\n\n\n\n\n\n\n\n\n\nangular 视图概念\nviews是angular模版中的静态片段 - 已知 UI 元素、指令和子组件的集合。视图组合在一起以创建可以表达 UI 的条件或重复部分的模板。\n下面的组件模版是一个视图\n&#x3C;div>\n    &#x3C;label>Who: &#x3C;input name=\"who\">&#x3C;/label>\n    &#x3C;label>What: &#x3C;input name=\"what\">&#x3C;/label>\n&#x3C;/div>\n而此模板有两个视图 - 带有“Who”和“What”的外部 DOM，以及一个有条件显示的嵌入视图，其中包含“Why”：\n&#x3C;div>\n    &#x3C;label>Who: &#x3C;input name=\"who\">&#x3C;/label>\n    &#x3C;label>What: &#x3C;input name=\"what\">&#x3C;/label>\n    &#x3C;ng-container *ngIf=\"showWhy\">\n        &#x3C;label>Why: &#x3C;input name=\"why\">&#x3C;/label>\n    &#x3C;/ng-container>\n&#x3C;/div>\nNgIf 或 NgSwitchCase 的每个分支以及 NgFor 的每一行都是 Angular 中独立视图的示例。\n局部变化检测的粒度\n\n整个应用程序：立即处理整个应用程序（zone.js 的作用，OnPush 优化除外）。\n组件树：遍历各个子树（单个组件及其子组件）\n单个组件：检查组件（包括其所有视图），但不检查其子组件\n视图：单独检查每个视图（angular当前颗粒度）\nDOM 元素：单独更新每个 DOM 元素的所有绑定（文本节点、元素等。SolidJS 在这个级别工作）\n绑定：单独更新每个 DOM 绑定\n\n为什么选择视图级别？\n\n\n依赖追踪开销\n设置依赖图解并不是免费的。signal速度很快，但跟踪越细粒度，图中需要分配和保存的节点就越多。这不仅需要时间，而且消耗内存。\n\n\n检单独视图已经带来了大部分好处。\n视图通常是具有可管理数量的绑定的 UI 小片段。评估和更改检测一小组绑定的成本已经非常低（Angular 现在对整个应用程序执行此操作）。\n使用变更检测处理的最昂贵的组件通常是那些具有大型、重复、高度动态结构的组件，例如具有数百或数千行的数据表。这些组件自然已经分解为许多单独的视图（每一行至少是一个视图，也许更多）。通过基于视图的更改检测和正确结构化的模型，signal已可用于仅驱动表中一行的更新，而无需处理其他未更改的行。\n\n\n基于视图的signal变更检测与基于zone.js的变更检测完美结合。\n针对视图运行变更检测的操作已经是构建现有的基于区域的全应用程序变更检测系统的主要语法。对signal使用相同的粒度使互操作性变得更加简单，并允许两个反应性模型共享大部分底层实现代码。这将使我们能够引入signal反应性，而不会极大地影响捆绑包的大小。\n\n\n@Input 是 signals\n在基于signal的组件中，输入将是signal！这种选择的直接目的是为数据如何流经应用程序建立一个清晰、统一的模型。\n基于signal的输入对数据流有重大影响，因为它们作为computed signal工作，而不是检测到变化的表达式。\n基于zone.js的inputs的工作方式\n在基于zone.js的应用程序中，输入是在变化检测期间设置的。假设 HomePageCmp 有以下模板：\n&#x3C;user-profile [userData]=\"authService.loggedInUser.data\" />\n如果loggedInUser 发生变化。 zone.js 会注意到发生了一些事情，但不知道具体发生了什么变化，并将触发整个应用程序的更改检测。更改检测将处理 HomePageCmp 并重新计算与 [userData] 的绑定：表达式 authService.loggedInUser.data。它会将 UserProfileCmp.userData 字段设置为新值，然后深入到 UserProfileCmp 并计算其模板（这可能会使用 userData）。\n基于signal的inputs的工作方式\n如果 HomePageCmp 和 UserProfileCmp 是基于signal的组件，则 userData 输入的功能将非常不同。当然，绑定必须使用 LoggedInUser signal：\n&#x3C;user-profile [userData]=\"authService.loggedInUser().data\" />\n当首次创建 HomePageCmp 并创建其 UserProfileCmp 子级时，Angular 将为 [userData] 绑定表达式创建一个computed signal：compute(() =&gt; authService.loggedInUser().data)。然后将此派生signal作为 UserProfileCmp 的 userData 输入的值提供。\n\n\n\n\n\n\n\n\n\ninput signal在变化检测之前解析\n对 userData 输入signal的更新发生在变更检测之前，而不是检测期间。\n\nExpressionChangedAfterItHasBeenChecked 错误不再是风险，因为模型在检查之前已完全同步。 （非确定性模型仍然会导致此类错误，但这是另一个问题）\n数据可以独立于 UI 层次结构流动，而不是被迫仅从父级流向子级。不需要 setTimeout 或 Promise.resolve 或其他技巧。\n\n\n\n\n\n\n\n\n\n\n输入绑定不会触发绑定方中的局部变更检测。\n因为 userData 的绑定是作为computed signal提供的，所以 HomePageCmp 中的任何视图都不依赖于它的值。根据基于signal的变更检测的黄金法则，其任何视图都不会被检测到变更。\n\n\n\n\n\n\n\n\n\n输入绑定不会自动触发接收者中的本地更改检测。\n因为 UserProfileCmp 接收 userData 作为computed signal并不意味着当 userData 更改时将检测到其任何视图的更改。根据黄金法则，只有在 UserProfileCmp 读取其模板中某处的 userData 输入signal时，才会检测到更改。\n换句话说，模板中实际未使用的输入不会触发基于signal的组件中的任何更改检测。\n查询 是 signals\n与输入类似，视图和子查询是框架“producing”代表组件模型某些方面的反应值的示例。在基于signal的组件中，查询也将作为signal公开。这允许组件自然地对通过计算属性或效果更改的查询做出反应，就像输入一样。\nSignal 和 Zone 混合组件\n可以在同一应用程序中自由混合signal和non-signal组件。只要遵守signal分量的黄金法则，即使跨越这些边界，变化检测也应该正确运行。\n当signal组件向non-signal组件提供输入绑定时，signal语义用于检测绑定何时发生更改，并设置non-signal组件的输入，在必要时将其标记为检查，并在需要时运行 ngOnChanges。\n当非signal组件绑定到signal组件的输入时，会发生类似的转换。在non-signal组件的更改检测期间，将评估绑定，如果值已更改，则更新传递给子组件的输入signal。\n:::danger\nnon-signal 问题\n有时，指令通过本地引用或 DI 系统为其使用者公开 API。例如，NgModel 将其当前值公开为公共属性，可通过本地引用访问：\n&#x3C;input ngModel #in=\"ngModel\">\n&#x3C;p>You typed: &#123;&#123; in.value &#125;&#125;&#x3C;/p>\n此类 API 在signal组件中可能会出现问题，因为 in.value 不是signal，不能用于触发signal组件的更改检测，即使它随着用户键入而更改。\n在基于zone的组件中，无论如何依赖来自子级的数据都是一个很大的问题。如果当前值的反射移动到  声明上方，则会导致 ExpressionChangedAfterItHasBeenChecked 错误。\n:::\nZoneless Angular\n有了signal，就可以在没有 zone.js 的情况下构建 Angular 应用程序。仅signal应用程序将直接安排各个视图的更改检测（可能通过 requestAnimationFrame 或其他一些浏览器语法），而不是依赖区域来进行更改检测。\n在此类应用程序中，尝试使用基于zone的组件将是错误的。\nzone.js\n\n\n\n\n\n\n\n\n\nAngular 使用 zone.js 来跟踪浏览器中的各种事件（例如 DOM 事件、网络请求和计时器）。 Zone.js 通过对任何可能导致应用程序模型更改的 API 进行猴子修补（在运行时包装和修补回调函数）来跟踪这些事件。然而，当发生此类事件时，Angular 没有任何关于发生了哪些具体更改的信息，或者即使根本没有任何更改。\n在收到来自 zone.js 的事件通知后，Angular 将读取（拉取）新的模型值，并根据之前看到的模型值的差异来更新 UI。\n","slug":"angular-v16","date":"2023-07-13T03:00:00.000Z","categories_index":"ANGULAR","tags_index":"angular","author_index":"Kidwen"},{"id":"50eebbead438db6dedc794be2c425ee4","title":"gulp","content":"利用 gulp 和 JavaScript 的灵活性来自动执行缓慢、重复的工作流程，并将其组合成高效的构建管道。\n","slug":"gulp","date":"2023-07-10T10:00:00.000Z","categories_index":"TOOL","tags_index":"build","author_index":"Kidwen"},{"id":"d7acadbeb31d4d41403b5db5aed2bd4c","title":"lodash","content":"一个现代 JavaScript 实用程序库，提供模块化、性能和附加功能。\n","slug":"lodash","date":"2023-07-10T09:00:00.000Z","categories_index":"TOOL","tags_index":"lodash","author_index":"Kidwen"},{"id":"9170303394444f49789e30f6c5748970","title":"rxjs","content":"RxJS（Reactive Extensions for JavaScript）是一个用于处理异步和事件驱动编程的库。它基于观察者模式和迭代器模式，并引入了一些函数式编程的概念。RxJS 提供了一组强大的工具和操作符，可以帮助开发者处理和组合异步数据流。\nRxJS 是一个用于响应式编程的库，它的核心概念是 Observable（可观察对象）。Observable 表示一个可能会产生多个值的异步数据源。通过使用 RxJS，你可以对这些数据流进行处理、转换和组合，从而实现更简洁和可维护的代码。\n通常在 RxJS 中，有两种类型的数据流：“冷”（cold）和“热”（hot）数据流。对于“冷”数据流，Observable 只有在被订阅时才会开始发出值，并且每个订阅者都会收到一份独立的数据流副本。而对于“热”数据流，数据可能在 Observable 被订阅之前就已经开始发出，并且所有订阅者共享同一个数据源。\nRxJS 提供了许多操作符，可以对 Observable 进行各种转换和过滤操作。这些操作符包括映射（map）、过滤（filter）、合并（merge）、延迟（delay）、缓冲（buffer）等等。通过组合这些操作符，你可以构建出复杂的数据流处理逻辑。\n除了操作符，RxJS 还提供了一些工具函数和实用程序，例如调度器（Scheduler）、主题（Subject）和订阅（Subscription）等。调度器用于控制 Observable 在何时发出通知，主题充当事件总线，而订阅则用于管理和取消订阅。\n总结：RxJS 是一个强大的前端库，用于处理异步数据流和事件驱动编程。它提供了丰富的操作符和工具函数，可以帮助开发者处理和组合复杂的数据流。通过使用 RxJS，你可以编写出更具可读性和可维护性的异步代码。\n\n\n\n\n\n\n\n\n\nRxJS 管理异步事件中的要素概念包括以下几点：\n\nObservable:   代表未来值或事件的可调用集合的想法。\nObserver:     是一个回调集合，它知道如何监听 Observable 传递的值。\nSubscription: 表示 Observable 的执行，主要用于取消执行。\nOperators:    是纯函数，支持使用函数式编程风格处理集合，例如map、filter、concat、reduce 等操作。\nSubject:      相当于EventEmitter，也是将值或事件多播到多个观察者的唯一方法。\nSchedulers:   是控制并发的集中调度程序，允许我们在计算发生时进行协调，例如setTimeout 或 requestAnimationFrame 或其他。\n\nObservable\n\n\nPull systems 消费者决定什么时候从数据生产者哪里获取数据，而生成者不知道什么时候将数据送给消费者。每一个js方法都是一个Pull system，包括 generator 函数。\n\n\nPush systems 生产者确定什么时候向消费者发送数据，而消费者不知道什么时候会收到这些数据。Promises 是Pull systems中最通用的类型。\n  import &#123; Observable &#125; from 'rxjs';\n\n  const observable = new Observable((subscriber) => &#123;\n      subscriber.next(1);\n      subscriber.next(2);\n      setTimeout(() => &#123;\n          subscriber.next(3);\n          subscriber.complete();\n      &#125;, 1000);\n  &#125;);\n\n  console.log('订阅开始');\n  observable.subscribe(&#123;\n      next(x) &#123;\n          console.log('got value ' + x);\n      &#125;,\n      error(err) &#123;\n          console.error('something wrong occurred: ' + err);\n      &#125;,\n      complete() &#123;\n          console.log('done');\n      &#125;,\n  &#125;);\n  console.log('订阅结束');\n\n  // 订阅开始\n  // 1\n  // 2\n  // 订阅结束\n  // got value 3\n  // done\n\n\nObserver\n\n\n观察者是 Observable 传递的值的消费者。观察者只是一组回调，每个回调对应 Observable 传递的每种类型的通知：下一步、错误和完成。\n  const observer = &#123;\n      next: x => console.log('Observer got a next value: ' + x),\n      error: err => console.error('Observer got an error: ' + err),\n      complete: () => console.log('Observer got a complete notification'),\n  &#125;;\n\n\n要使用观察者，可以将其提供给 Observable 的订阅：\n  observable.subscribe(observer);\n\n\n\n\n\n\n\n\n\n\n\n观察者只是具有三个回调的对象，每个回调对应 Observable 可能传递的每种类型的通知。\n\n\nRxJS 中的观察者也可能是片面的。如果你不提供其中一种回调，Observable 的执行仍然会正常发生，除了某些类型的通知将被忽略，因为它们在观察者中没有相应的回调。\n  // 没有 complete 回掉方法\n  const observer = &#123;\n      next: x => console.log('Observer got a next value: ' + x),\n      error: err => console.error('Observer got an error: ' + err),\n  &#125;;\n\n\n当订阅 Observable 时，也可以只提供下一个回调作为参数，而不附加到 Observer 对象，例如如下所示：\n  // 在 observable.subscribe 内部，它将使用回调参数作为下一个处理程序创建一个 Observer 对象。\n  observable.subscribe(x => console.log('Observer got a next value: ' + x));\n\n\nSubscription\nSubscription是一个代表一次性资源的对象，通常是 Observable 的执行。Subscription有一个重要的方法，unsubscribe，它不带任何参数，只处理订阅所持有的资源。在以前的 RxJS 版本中，订阅被称为“Disposable”。\nimport &#123; interval &#125; from 'rxjs';\n\nconst observable = interval(1000);\nconst subscription = observable.subscribe(x => console.log(x));\n\nsubscription.unsubscribe();\n\n\n\n\n\n\n\n\n\n订阅本质上只有一个 unsubscribe() 函数来释放资源或取消 Observable 执行。\n订阅也可以放在一起，以便调用一个订阅的 unsubscribe() 可以取消订阅多个订阅。您可以通过将一个订阅“添加”到另一个订阅中来完成此操作：\nimport &#123; interval &#125; from 'rxjs';\n\nconst observable1 = interval(400);\nconst observable2 = interval(300);\n\nconst subscription = observable1.subscribe(x => console.log('first: ' + x));\nconst childSubscription = observable2.subscribe(x => console.log('second: ' + x));\n\nsubscription.add(childSubscription);\n\nsetTimeout(() => &#123;\n  // 同时取消订阅 subscription 和 childSubscription\n  subscription.unsubscribe();\n&#125;, 1000);\n\n// second: 0\n// first: 0\n// second: 1\n// first: 1\n// second: 2\n订阅还有一个remove(otherSubscription)方法，以便撤消添加的子订阅。\nSubject\nSubject是一个复合结构体，它有双重身份，既可以是可观察对象Observable也可以是观察者Observer。Subject 实例被称为“热”的（hot），是因为它们在有订阅者（Subscribers）订阅之前就可能已经生成并发出数据了。\nBehaviorSubject\nBehaviorSubject 是 Subject 的一种变体，也就是说，BehaviorSubject 同时是一个 Observable 也是一个 Subject.\n\n\n\n\n\n\n\n\n\n不同：BehaviorSubject 在首次订阅前有一个初始值，并且会在订阅者首次订阅时提供一个与之前状态相关的初始值。\nReplaySubject\nReplaySubject 是 RxJS 库中的一种类型，属于热 Observable。ReplaySubject 存储并重新发送订阅操作前发布的数据。\n\n\n\n\n\n\n\n\n\nReplaySubject 可按指定的缓冲容量创建。例如，如果缓冲容量为 2，则会重放最后两个值。\n\nconst data$ = new ReplaySubject(2);\n\ndata$.next('data 1');\ndata$.next('data 2');\ndata$.next('data 3');\n\nconst subscription1 = data$.subscribe(&#123;\n  next: data => console.log(`Subscribe 1: $&#123;data&#125;`)\n&#125;);\n\nconst subscription2 = data$.subscribe(&#123;\n  next: data => console.log(`Subscribe 2: $&#123;data&#125;`)\n&#125;);\n\n// Output:\n// Subscribe 1: data 2\n// Subscribe 1: data 3\n// Subscribe 2: data 2\n// Subscribe 2: data 3\nSchedulers\nOperators\n\n\n\n\n\n\n\n\n\n创建类\n\nof: 根据传入的参数创建Observable对象，of 产生的是 Cold Observable，对于每一个Observer都会重复吐出同样的数据。\n// export function of&#x3C;A extends readonly unknown[]>(...values: A): Observable&#x3C;ValueFromArray&#x3C;A>>;\n\nimport &#123; of &#125; from 'rxjs';\nconst source$ = of(...[1, 2, 3]);\nsource$.subscribe(data => &#123;\n    console.log('First: ' + data);\n&#125;);\nsource$.subscribe(data => &#123;\n    console.log('Second: ' + data);\n&#125;);\n// 第一次监听的打印\n// First: 1\n// First: 2\n// First: 3\n// 第二次监听的打印\n// Second: 1\n// Second: 2\n// Second: 3\n转化类\n过滤类\n\n\n\n\n\n\n\n\n\nskip: 允许忽略源 observable 开头的n个值，可以用于忽略Replay或者BehaviorSubject的初始值，也可以用filter加索引模拟skip。\nconst sourse = interval(100);\n// 忽略前十个值\nsource.pip(skip(10)).subcribe(value => &#123;&#125;);\nfilter: 发出符合条件的值\n合并类\n多播类\n错误处理类\n辅助工具类\n条件分支类\n数学和合计类\n\n弹珠图\n","slug":"rxjs","date":"2023-07-10T02:30:00.000Z","categories_index":"TOOL","tags_index":"rxjs","author_index":"Kidwen"},{"id":"26df78b12ea8461da2d0f20e21f4a6a9","title":"响应式主题","content":"将页面自适应匹配用户的喜好，例如黑色模式\n可以调整网站的展示以匹配用户的喜好。首先，需要知道如何借力浏览器来增加网站曝光从而提高品牌知名度。\n自定义浏览器界面\n一些浏览器可以允许基于网站的调色板设置一个主题颜色。然后浏览器界面会自适应设置后的颜色。在页面head中名为theme-color的meta元素中添加颜色。\n&#x3C;meta name=\"theme-color\" content=\"#00D494\">\n\n\n\n\n\n\n\n\n\n像这样将样式信息放在HTML中而不是CSS中可能会显得有点怪异，但是这允许浏览器一旦加载好页面尽快更新它的界面而不是等待CSS加载好。\n使用JavaScript更新theme-color的值。请谨慎操作。如果浏览器的颜色模式变化太频繁会使用户难以接受。请考虑微调主题颜色的细微方式。如果变化过于明显，用户可能会因为感到烦恼而离开。\n也可以在网页manifest中指定一个主题色。这个JSON文件中包含了关于网站的元数据。\n将清单文件的链接放在文档的head。使用rel值为manifest的link元素\n&#x3C;link rel=\"manifest\" href=\"/manifest.json\">\n在manifest文件中，使用键值对（key/value）的方式列出所有元数据\n&#123;\n    \"short_name\": \"Clearleft\",\n    \"name\": \"Clearleft design agency\",\n    \"start_url\": \"/\",\n    \"background_color\": \"#00D494\",\n    \"theme_color\": \"#00D494\",\n    \"display\": \"standalone\"\n&#125;\n如果访问者决定将您的网站添加到他们的主屏幕上，浏览器将使用您清单文件中的信息来显示适当的快捷方式。\n\n\n\n\n\n\n\n\n\n了解如何添加 Web 应用manifest的更多信息\n\nWeb App Manifest - MDN Web Docs: Mozilla Developer Network (MDN) 提供的关于 Web App Manifest 的详细文档，包含各个属性和用法的解释。\nWeb App Manifest Specification - W3C: Web App Manifest 的官方规范文档，由 W3C（World Wide Web Consortium）提供，包含清单文件的详细规范。\nIntroduction to Web App Manifests - Google Developers: Google Developers 提供的关于 Web App Manifest 的简介和入门指南，包含示例和最佳实践。\n\n通过查阅以上资源，您将能够更深入地了解如何添加和配置 Web 应用清单（Web App Manifest）以及相关属性的使用方法。\n提供一个黑色模式\n许多操作系统允许用户指定一个黑色或者亮色主题，这是根据用户的主题偏好优化您的网站的好主意。可以通过在媒体特性中的prefers-color-scheme访问此首选项。\n@media (prefers-color-scheme: dark) &#123;\n    // 定义黑色主题样式\n&#125;\n\n在meta元素中使用prefers-color-scheme媒体特性指定主题颜色。\n&#x3C;meta name=\"theme-color\" content=\"#ffffff\" media=\"(prefers-color-scheme: light)\">\n&#x3C;meta name=\"theme-color\" content=\"#000000\" media=\"(prefers-color-scheme: dark)\">\n可以在svg中使用prefers-color-scheme媒体特性。如果使用一个SVG文件作为的图标，它也会被黑色模式调节。参考\n使用自定义属性主题化\n如果在多个地方的CSS中使用了相同的颜色值，在prefers-color-scheme媒体查询中重复所有选择器可能会非常乏味。\nbody &#123;\n  background-color: white;\n  color: black;\n&#125;\ninput &#123;\n  background-color: white;\n  color: black;\n  border-color: black;\n&#125;\nbutton &#123;\n  background-color: black;\n  color: white;\n&#125;\n@media (prefers-color-scheme: dark) &#123;\n  body &#123;\n    background-color: black;\n    color: white;\n  &#125;\n  input &#123;\n    background-color: black;\n    color: white;\n    border-color: white;\n  &#125;\n  button &#123;\n    background-color: white;\n    color: black;\n  &#125;\n&#125;\n使用CSS自定义属性来存储颜色值。自定义属性类似于程序中的变量。可以更新这些变量值而不更新其名称。\n如果在prefers-color-scheme媒体查询中更新自定义属性值，这样就没必要重复写各种选择器。\nhtml &#123;\n  --page-color: white;\n  --ink-color: black;\n&#125;\n@media (prefers-color-scheme: dark) &#123;\n  html &#123;\n    --page-color: black;\n    --ink-color: white;\n  &#125;\n&#125;\nbody &#123;\n  background-color: var(--page-color);\n  color: var(--ink-color);\n&#125;\ninput &#123;\n  background-color: var(--page-color);\n  color: var(--ink-color);\n  border-color: var(--ink-color);\n&#125;\nbutton &#123;\n  background-color: var(--ink-color);\n  color: var(--page-color);\n&#125;\n\n有关使用自定义属性进行主题化的更高级示例，请参阅构建配色方案。\n图片\n如果在HTML中使用SVG， 也可以应用自定义属性。\nsvg &#123;\n  stroke: var(--ink-color);\n  fill: var(--page-color);\n&#125;\n现在 icon 会跟着页面上的其他元素一起改变颜色。\n如果想在黑色模式下调节图片的亮度，可以在css中使用filter方法。\n\n\n\n对于一些图片，可能想完全替换他们在黑色模式下。例如，可能想在黑色模式下展示一个地图。使用&lt;picture&gt;元素包含一个使用prefers-color-scheme媒体查询的&lt;source&gt;元素。\n&#x3C;picture>\n  &#x3C;source srcset=\"darkimage.png\" media=\"(prefers-color-scheme: dark)\">\n  &#x3C;img src=\"lightimage.png\" alt=\"A description of the image.\">\n&#x3C;/picture>\n\n表单\n浏览器为表单字段提供默认调色板。让浏览器知道您的网站同时提供深色和浅色模式。这样，浏览器就可以为表单提供适当的默认样式。\n添加下面代码到CSS中：\nhtml &#123;\n  color-scheme: light;\n&#125;\n@media (prefers-color-scheme: dark) &#123;\n  html &#123;\n    color-scheme: dark;\n  &#125;\n&#125;\n也可以使用HTML。添加下面代码到的文档中：\n&#x3C;meta name=\"supported-color-schemes\" content=\"light dark\">\n\n使用accent-color属性设置checkboxs， radio 按钮和其他的表单元素的样式。\nhtml &#123;\n  accent-color: red;\n&#125;\n深色主题通常具有柔和的品牌颜色。更新深色模式的accent-color。\nhtml &#123;\n  accent-color: red;\n&#125;\n@media (prefers-color-scheme: dark) &#123;\n  html &#123;\n    accent-color: pink;\n  &#125;\n&#125;\n为此使用自定义属性是有意义的，这样您就可以将所有颜色声明保存在一个位置。\nhtml &#123;\n  color-scheme: light;\n  --page-color: white;\n  --ink-color: black;\n  --highlight-color: red;\n&#125;\n@media (prefers-color-scheme: dark) &#123;\n  html &#123;\n    color-scheme: dark;\n    --page-color: black;\n    --ink-color: white;\n    --highlight-color: pink;\n  &#125;\n&#125;\nhtml &#123;\n  accent-color: var(--highlight-color);\n&#125;\nbody &#123;\n  background-color: var(--page-color);\n  color: var(--ink-color);\n&#125;\n\n\n\n\n\n\n\n\n\n有关使用主题颜色对元素进行着色的更多信息，请参阅有关更多着色的部分。\n","slug":"theming","date":"2023-06-15T05:30:00.000Z","categories_index":"CSS","tags_index":"","author_index":"Kidwen"},{"id":"e2672fdc90bcdcecaee684b021564cfb","title":"Animations provided by angular","content":"Angular Animations is a built-in animation library in Angular framework that allows you to create rich and interactive animations in your application. It provides a powerful set of tools and APIs that make it easy to implement dynamic and smooth animation effects in Angular.\n\n\n\n\n\n\n\n\n\nHere are some features and capabilities of Angular Animations:\n\n\nDeclarative Syntax: Angular Animations uses a declarative syntax to describe animation effects. You can use specific directives and attributes in your templates, and define animation triggers and state transitions in your component classes to control the behavior of animations.\n\n\nDiverse Animation Support: Angular Animations supports various types of animation effects including fading, translation, rotation, scaling, color changes, and more. You can create complex animation sequences by combining and chaining multiple animations to achieve richer effects.\n\n\nTriggers and States: By defining triggers and states, you can control when and how animations are triggered based on specific conditions. Triggers can be mouse events, route navigation, component lifecycle hooks, and more, while states define the transitions between different animation states.\n\n\nEasing Functions: Angular Animations supports a variety of easing functions to define the speed curve of animations, making them smoother and more natural. You can use built-in easing functions or define custom ones.\n\n\nAnimation Groups and Parallel Effects: You can combine multiple animations into an animation group, allowing them to play simultaneously or sequentially. This enables you to create more complex animation effects, such as scaling and rotating an element at the same time.\n\n\nDynamic and Conditional Animations: Angular Animations allows you to enable or disable animations based on dynamic data or conditions. You can use Angular’s data binding and conditional statements to implement dynamic animations based on states or user interactions.\n\n\nHigh Performance and Optimization: Angular Animations is designed to be a high-performance animation library. It leverages Angular’s change detection mechanism and frame synchronization strategy, as well as utilizes the Web Animations API when available, to achieve hardware-accelerated animation effects.\n\n\nIn summary, Angular Animations is a powerful animation library provided by the Angular framework. With its declarative syntax and rich set of features, you can easily create interactive and smooth animation effects in your application. Whether it’s a simple element fade-in or a complex animation sequence, Angular Animations provides flexible tools and APIs to implement a wide range of animation effects.\n\n\n\nPreparation\n\n\n\n\n\n\n\n\n\nAdd relation module in NgModule\nimport &#123; NgModule &#125; from '@angular/core';\nimport &#123; BrowserModule &#125; from '@angular/platform-browser';\nimport &#123; BrowserAnimationsModule &#125; from '@angular/platform-browser/animations';\n\n@NgModule(&#123;\n    imports: [\n        BrowserModule,\n        BrowserAnimationsModule,\n    ],\n    declarations: [ ],\n    bootstrap: [ ],\n&#125;)\nexport class AppModule &#123; &#125;\n\n\n\n\n\n\n\n\n\nUse the method or property from @angular/animations\nimport &#123;\n    trigger,\n    state,\n    style,\n    animate,\n    transition,\n    // ...\n&#125; from '@angular/animations';\nIntroduction\nstate()\n\n\n\n\n\n\n\n\n\ndefine the custom state of animation, then you can conver one state to another state to use some animations, the defualt state such as void(the dom not render) and *(the dom rendered)\nstate('disable', style(&#123;\n    backgroundColor: 'rgba(0, 0, 0, .12)',\n    color: 'rgba(0, 0, 0, .38)'\n&#125;))\nstyle()\n\n\n\n\n\n\n\n\n\ndefine the style of state, must be cameCase for style attributes that contain dashes, such as backgroundColor or wrap them in quotes, such as ‘background-color’\nanimate()\n\n\n\n\n\n\n\n\n\nUse the animate() function to define the length, delay, and easing of a transition, and to designate the style function for defining styles while transitions are taking place. Use the animate() function to define the keyframes() function for multi-step animations. These definitions are placed in the second argument of the animate() function.\nanimate ('duration delay easing')\n\nduration such as 100, '100ms', '0.1s'\ndelay wait for the value time then run the animation\neasing suche as ease-in, ease-out, ease-in-out\n\ntransition()\n\n\n\n\n\n\n\n\n\nThe transition() function accepts two arguments: The first argument accepts an expression that defines the direction between two transition states, and the second argument accepts one or a series of animate() steps\ntransition('open => closed', [\n  animate('1s')\n]),\ntrigger()\n\n\n\n\n\n\n\n\n\nKicks off the animation and serves as a container for all other animation function calls. HTML template binds to triggerName. Use the first argument to declare a unique trigger name. Uses array syntax.\n@Component(&#123;\n    selector: 'app-open-close',\n    animations: [\n        trigger('openClose', [\n            state('open', style(&#123;\n                height: '200px',\n                opacity: 1,\n                backgroundColor: 'yellow'\n            &#125;)),\n            state('closed', style(&#123;\n                height: '100px',\n                opacity: 0.8,\n                backgroundColor: 'blue'\n            &#125;)),\n            transition('open => closed', [\n                animate('1s')\n            ]),\n            transition('closed => open', [\n                animate('0.5s')\n            ]),\n        ])\n    ]\nExample\n\nDetails\n@Component(&#123;\n    selector: 'app-animate',\n    templateUrl: `\n    &#x3C;div [@fadeInOut]=\"show ? 'show' : 'hidden'\" *ngIf=\"isAdd\">\n        content\n    &#x3C;/div>\n    `,\n    animations: [\n        trigger('fadeInOut', [\n            state('void', style(&#123; height: '0' &#125;)),\n            state('hidden', style(&#123; 'max-height': '0px', height: '0' &#125;)),\n            state('show', style(&#123; 'max-height': '9999px', height: '*' &#125;)),\n            transition('* &#x3C;=> void', animate(0)),\n            transition('hidden => show', animate('300ms ease-in')),\n            transition('show => hidden', animate('300ms ease-in')),\n        ])\n    ],\n&#125;)\nexport class AnimateComponent &#123;\n    // ...\n&#125;\n\n\n","slug":"angular-animate","date":"2023-06-15T02:00:00.000Z","categories_index":"ANGULAR","tags_index":"angular animate","author_index":"Kidwen"},{"id":"a19d5e0d55b52c82da47e7788eb0a54f","title":"git proxy","content":"当使用git工具拉取github仓库时由于某种特殊原因可能会拉取失败，拉取很慢，下面介绍如何给git配置代理.\n查看当前配置\ngit config -l\nSet proxy\ngit config --global http.proxy 127.0.0.1:10809\ngit config --global https.proxy 127.0.0.1:10809\nCancle proxy\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n","slug":"git","date":"2023-04-06T09:06:00.000Z","categories_index":"PROXY","tags_index":"git","author_index":"Kidwen"},{"id":"e10b3e307ab7cce969dd23a6ff7cab07","title":"python pip proxy","content":"Python is a high-level, general-purpose programming language. Its design philosophy emphasizes code readability with the use of significant indentation via the off-side rule.\npip 单次设置代理\npip install xxx --proxy=http://localhost:10809\npip 设置镜像源\n# C:\\Users\\[userName]\\pip\\pip.ini\n[global]\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\ntrusted-host = pypi.tuna.tsinghua.edu.cn\n\n[search]\nindex = https://pypi.tuna.tsinghua.edu.cn/simple\n","slug":"python","date":"2023-04-05T10:00:00.000Z","categories_index":"PROXY","tags_index":"python","author_index":"Kidwen"},{"id":"f47c8ac6f30df916a8383883258747a7","title":"eslint angular","content":"Angular 是一个应用设计框架与开发平台，旨在创建高效而精致的单页面应用。\nESLint 是一个很棒的 JavaScript 代码检查工具。\nTypeScript 是一种基于 JavaScript 的强类型编程语言。\n在angular项目中添加eslint\n\n\n\n\n\n\n\n\n\n此命令会默认安装angular-eslint相关依赖,包括@angular-eslint/builder,@angular-eslint/eslint-plugin,@angular-eslint/eslint-plugin-template,@angular-eslint/schematics,@angular-eslint/template-parser,@typescript-eslint/eslint-plugin,@typescript-eslint/parser,并在angular.json文件中自动添加如下配置（如果没有则手动添加）。\n&#123;\n    // ...\n    \"cli\": &#123;\n        // ...\n        \"schematicCollections\": [\"@angular-eslint/schematics\"]\n    &#125;\n&#125;\nng add @angular-eslint/schematics\n安装eslint插件\nnpm install eslint-plugin-import eslint-plugin-jsdoc eslint-plugin-prefer-arrow eslint-plugin-unicorn --save-dev\n配置eslint插件\n\n\n\n\n\n\n\n\n\n插件用于加载第三方规则集合，在 plugins 属性中，可以定义一个数组，数组中的每个元素都是一个字符串，代表要使用的插件的名称。一旦配置中定义了插件，可以在 rules 属性中使用插件的规则。插件的规则名称由插件名称和规则名称组成，中间使用 / 分隔。\n// .eslintrc.js\nmodule.exports = &#123;\n    // ...\n    \"plugins\": [\n        \"import\",\n        \"jsdoc\",\n        \"unicorn\",\n        \"prefer-arrow\",\n    ],\n    // ...\n&#125;\n配置lint规则\n// .eslintrc.js\nmodule.exports = &#123;\n    // ...\n    \"rules\":  &#123;\n        \"import/no-default-export\": \"error\",\n        // ...\n    &#125;,\n    // ...\n&#125;\n基于不同文件类型覆盖规则\n// .eslintrc.js\nmodule.exports = &#123;\n    // ...\n    \"overrides\": [\n        &#123;\n            \"files\": [\n                \"*.component.ts\"\n            ],\n            \"plugins\": [\n                \"@angular-eslint/eslint-plugin-template\",\n                \"@angular-eslint\",\n            ],\n            \"rules\": &#123;\n                \"@angular-eslint/no-empty-lifecycle-method\": \"error\",\n                // ...\n            &#125;\n        &#125;,\n    ]\n&#125;\n规则介绍\n@typescript-eslint\narray-type\n\n\n官方地址\n\n\n描述\n\n配置数组声明方式,error代表使用T[]\n\n\n\n类型\n\n‘error’|Array\n\n\n\n选项\n      &#123;\n        default?: \"array\" | \"generic\" | \"array-simple\";\n        readonly?: \"array\" | \"generic\" | \"array-simple\";\n    &#125;\n\n\n示例\n      &#123;\n        \"@typescript-eslint/array-type\": [\n            \"error\",\n            &#123;\n                \"default\": \"generic\"\n            &#125;\n        ],\n    &#125;\n\n\nban-ts-comment\n\n\n官方地址\n\n\n描述\n\n禁止@ts-&lt;directive&gt;注释或要求指令后的描述\n默认只允许@ts-check\nallow-with-description允许带描述的注释指令\n\n      // @ts-expect-error: description\n\ndescriptionFormat正则匹配指令注释后的描述,不匹配则报错\nminimumDescriptionLength指令注释后的描述最短长度\n\n\n\n选项\n      type DirectiveConfigSchema =\n        | boolean\n        | \"allow-with-description\"\n        | &#123;\n            descriptionFormat?: string;\n            &#125;;\n\n    interface Options &#123;\n        \"ts-expect-error\"?: DirectiveConfigSchema;\n        \"ts-ignore\"?: DirectiveConfigSchema;\n        \"ts-nocheck\"?: DirectiveConfigSchema;\n        \"ts-check\"?: DirectiveConfigSchema;\n        minimumDescriptionLength?: number;\n    &#125;\n\n    const defaultOptions: Options = [\n        &#123;\n            \"ts-expect-error\": \"allow-with-description\",\n            \"ts-ignore\": true,\n            \"ts-nocheck\": true,\n            \"ts-check\": false,\n            minimumDescriptionLength: 3,\n        &#125;,\n    ];\n\n\n示例\n      &#123;\n        \"@typescript-eslint/ban-ts-comment\": [\n            \"error\",\n            &#123;\n                \"ts-expect-error\": \"allow-with-description\",\n                \"ts-ignore\": true,\n                \"ts-nocheck\": true,\n                \"ts-check\": false,\n                \"minimumDescriptionLength\": 3\n            &#125;\n        ],\n    &#125;\n\n\nban-types\n\n\n官方地址\n\n\n描述\n\n\n使用小写类型以保持一致性\n\n\n使用正确的函数类型\n\n\n使用安全的object类型\n\n\n\n❌\n✅\n\n\n\n\nString\nstring\n\n\nBoolean\nboolean\n\n\nNumber\nnumber\n\n\nSymbol\nsymbol\n\n\nBigInt\nbigint\n\n\nFunction\n() =&gt; {}\n\n\nObject\nobject | 特定类型\n\n\n{}\n特定类型\n\n\n\n\n\n\n\n选项\n      interface Options &#123;\n    types?: &#123;\n        [k: string]:\n        | null\n        | boolean\n        | string\n        | &#123;\n            message?: string;\n            fixWith?: string;\n            suggest?: string[];\n            &#125;;\n    &#125;;\n    extendDefaults?: boolean;\n    &#125;\n\n    const defaultOptions: Options = [&#123;&#125;];\n\n\n示例\n      &#123;\n        \"@typescript-eslint/ban-types\": \"error\"\n    &#125;\n    // 或者\n    &#123;\n        \"@typescript-eslint/ban-types\": [\n            \"error\",\n            &#123;\n            \"types\": &#123;\n                // 自定义消息描述为什么不能使用此类型\n                \"Foo\": \"Don't use Foo because it is unsafe\",\n\n                // 添加一个自定义消息，并告知插件如何修复这个问题\n                \"OldAPI\": &#123;\n                \"message\": \"Use NewAPI instead\",\n                \"fixWith\": \"NewAPI\"\n                &#125;,\n\n                // 取消默认禁用的类型\n                \"&#123;&#125;\": false\n            &#125;,\n            \"extendDefaults\": true\n            &#125;\n        ]\n    &#125;\n\n\nconsistent-type-definitions\n\n\n官方地址\n\n\n描述\n\n强制使用interface或者type来声明类型\n\n\n\n选项\n      type Options = \"interface\" | \"type\";\n\n    const defaultOptions: Options = [\"interface\"];\n\n\n示例\n      &#123;\n       \"@typescript-eslint/consistent-type-definitions\": [\"error\", \"interface\"],\n       // 或者\n       \"@typescript-eslint/consistent-type-definitions\": [\"error\", \"type\"]\n    &#125;\n\n\ndot-notation\n\n\n官方地址\n\n\n描述\n\n\n尽可能强制执行点表示法\n\n\n\n❌\n✅\n\n\n\n\nobj[“property”]\nobj.property\n\n\n\n\n\n\n\n选项\n      interface Options extends BaseDotNotationOptions &#123;\n        allowPrivateClassPropertyAccess?: boolean;\n        allowProtectedClassPropertyAccess?: boolean;\n        allowIndexSignaturePropertyAccess?: boolean;\n    &#125;\n\n    const defaultOptions: Options = &#123;\n        ...baseDotNotationDefaultOptions,\n        allowPrivateClassPropertyAccess: false,\n        allowProtectedClassPropertyAccess: false,\n        allowIndexSignaturePropertyAccess: false,\n    &#125;;\n\n\n示例\n      &#123;\n        // 必须禁用基础规则\n        \"dot-notation\": \"off\",\n        \"@typescript-eslint/dot-notation\": \"error\"\n    &#125;\n\n\nexplicit-member-accessibility\n\n\n官方地址\n\n\n描述\n\n需要对类属性和方法进行显式可访问性修饰符。public, protected, private\n\n\n\n选项\n      type AccessibilityLevel = \"explicit\" | \"no-public\" | \"off\";\n\n    interface Options &#123;\n        accessibility?: AccessibilityLevel;\n        overrides?: &#123;\n            accessors?: AccessibilityLevel;\n            constructors?: AccessibilityLevel;\n            methods?: AccessibilityLevel;\n            properties?: AccessibilityLevel;\n            parameterProperties?: AccessibilityLevel;\n        &#125;;\n        ignoredMethodNames?: string[];\n    &#125;\n\n    const defaultOptions: Options = [&#123; accessibility: \"explicit\" &#125;];\n\n\n示例\n      &#123;\n        \"@typescript-eslint/explicit-member-accessibility\": \"error\"\n    &#125;\n\n\nno-empty-function\n\n\n官方地址\n\n\n描述\n\n不允许空方法\n\n\n\n选项\n  \n    type AllowOptionEntries =\n        | 'functions'\n        | 'arrowFunctions'\n        | 'generatorFunctions'\n        | 'methods'\n        | 'generatorMethods'\n        | 'getters'\n        | 'setters'\n        | 'constructors'\n        | 'private-constructors'\n        | 'protected-constructors'\n        | 'asyncFunctions'\n        | 'asyncMethods'\n        | 'decoratedFunctions'\n        | 'overrideMethods';\n\n    interface Options extends BaseNoEmptyFunctionOptions &#123;\n        allow?: Array&#x3C;AllowOptionEntries>;\n    &#125;\n    const defaultOptions: Options = &#123;\n        ...baseNoEmptyFunctionDefaultOptions,\n        allow: [],\n    &#125;;\n\n\n示例\n      &#123;\n        // 必须禁用基础规则\n        \"no-empty-function\": \"off\",\n        \"@typescript-eslint/no-empty-function\": [\n            \"error\",\n            &#123;\n                \"allow\": [\"decoratedFunctions\"]\n            &#125;\n        ]\n    &#125;\n\n\nno-for-in-array\n\n\n官方地址\n\n\n描述\n\n禁止使用 for-in 循环迭代数组。\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@typescript-eslint/no-for-in-array\": \"error\"\n    &#125;\n\n\nno-inferrable-types\n\n\n官方地址\n\n\n描述\n\n\n不允许对初始化为数字、字符串或布尔值的变量或参数进行显式类型声明。\n\n\n\n❌\n✅\n\n\n\n\nconst a: bigint = 10n;\nconst a = 10n;\n\n\nconst a: bigint = BigInt(10);\nconst a = BigInt(10);\n\n\nconst a: boolean = !0;\nconst a = !0;\n\n\nconst a: boolean = Boolean(null);\nconst a = Boolean(null);\n\n\nconst a: boolean = true;\nconst a = true;\n\n\nconst a: null = null;\nconst a = null;\n\n\nconst a: number = 10;\nconst a = 10;\n\n\nconst a: number = Infinity;\nconst a = Infinity;\n\n\nconst a: number = NaN;\nconst a = NaN;\n\n\nconst a: number = Number(‘1’);\nconst a = Number(‘1’);\n\n\nconst a: RegExp = /a/;\nconst a = /a/;\n\n\nconst a: RegExp = new RegExp(‘a’);\nconst a = new RegExp(‘a’);\n\n\nconst a: string = str;\nconst a = str;\n\n\nconst a: string = String(1);\nconst a = String(1);\n\n\nconst a: symbol = Symbol(‘a’);\nconst a = Symbol(‘a’);\n\n\nconst a: undefined = undefined;\nconst a = undefined;\n\n\nconst a: undefined = void someValue;\nconst a = void someValue;\n\n\n\n\n\n\n\n选项\n      interface Options &#123;\n        ignoreParameters?: boolean;\n        ignoreProperties?: boolean;\n    &#125;\n\n    const defaultOptions: Options = [\n        &#123; ignoreParameters: false, ignoreProperties: false &#125;,\n    ];\n\n\n示例\n      &#123;\n        \"@typescript-eslint/no-inferrable-types\": \"error\"\n    &#125;\n\n\nno-non-null-assertion\n\n\n官方地址\n\n\n描述\n\n禁止使用 ! 进行非空断言后缀运算符。\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@typescript-eslint/no-non-null-assertion\": \"error\"\n    &#125;\n\n\nno-require-imports\n\n\n官方地址\n\n\n描述\n\n禁止调用 require()\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@typescript-eslint/no-require-imports\": \"error\"\n    &#125;\n\n\nno-this-alias\n\n\n官方地址\n\n\n描述\n\n禁止使用 this 别名\n\n\n\n选项\n      interface Options &#123;\n        /**\n        * 是否忽略解构, 例如 `const &#123; props, state &#125; = this`.\n        */\n        allowDestructuring?: boolean;\n        /**\n        * 忽略的名称, 例如 [\"self\"] for `const self = this;`.\n        */\n        allowedNames?: string[];\n    &#125;\n\n    const defaultOptions: Options = [\n        &#123; allowDestructuring: true, allowedNames: [] &#125;,\n    ];\n\n\n示例\n      &#123;\n        \"@typescript-eslint/no-this-alias\": \"error\"\n    &#125;\n\n\nno-unnecessary-type-assertion\n\n\n官方地址\n\n\n描述\n\n禁止不更改表达式类型的类型断言。\n\n\n\n选项\n      interface Options &#123;\n        /**\n         * 忽略的类型名称列表。\n        */\n        typesToIgnore?: string[];\n    &#125;\n\n    const defaultOptions: Options = [&#123;&#125;];\n\n\n示例\n      &#123;\n        \"@typescript-eslint/no-unnecessary-type-assertion\": [\"error\", &#123; \"typesToIgnore\": [\"Foo\"] &#125;]\n    &#125;\n\n\nno-var-requires\n\n\n官方地址\n\n\n描述\n\n\n不允许 require 语句（导入语句中除外）\n\n\n\n❌\n✅\n\n\n\n\nvar foo = require(‘foo’);\nimport foo = require(‘foo’);\n\n\nconst foo = require(‘foo’);\nrequire(‘foo’);\n\n\nlet foo = require(‘foo’);\nimport foo from ‘foo’;\n\n\n\n\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@typescript-eslint/no-var-requires\": \"error\"\n    &#125;\n\n\nprefer-for-of\n\n\n官方地址\n\n\n描述\n\n尽可能强制使用 for-of 循​​环而不是标准 for 循环。\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@typescript-eslint/prefer-for-of\": \"error\"\n    &#125;\n\n\nprefer-readonly\n\n\n官方地址\n\n\n描述\n\n如果私有成员从未在构造函数外部修改过，则要求将其标记为只读\n\n\n\n选项\n      interface Options &#123;\n        // 用于限制仅检查立即分配 `lambda` 值的成员。\n        onlyInlineLambdas?: boolean;\n    &#125;\n\n    const defaultOptions: Options = [&#123; onlyInlineLambdas: false &#125;];\n\n\n示例\n      &#123;\n        \"@typescript-eslint/prefer-readonly\": [\"error\", &#123; \"onlyInlineLambdas\": true &#125;]\n    &#125;\n\n\nstrict-boolean-expressions\n\n\n官方地址\n\n\n描述\n\n禁止布尔表达式中的某些类型。\n\n\n\n选项\n      interface Options &#123;\n        allowString?: boolean;\n        allowNumber?: boolean;\n        allowNullableObject?: boolean;\n        allowNullableBoolean?: boolean;\n        allowNullableString?: boolean;\n        allowNullableNumber?: boolean;\n        allowNullableEnum?: boolean;\n        allowAny?: boolean;\n        allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing?: boolean;\n    &#125;\n\n    const defaultOptions: Options = [\n        &#123;\n            allowString: true,\n            allowNumber: true,\n            allowNullableObject: true,\n            allowNullableBoolean: false,\n            allowNullableString: false,\n            allowNullableNumber: false,\n            allowNullableEnum: true,\n            allowAny: false,\n            allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: false,\n        &#125;,\n    ];\n\n\n示例\n      &#123;\n        \"@typescript-eslint/strict-boolean-expressions\": \"error\"\n    &#125;\n\n\nawait-thenable\n\n\n官方地址\n\n\n描述\n\n禁止 await 不是 Thenable 的值。\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@typescript-eslint/await-thenable\": \"error\"\n    &#125;\n\n\nno-unnecessary-boolean-literal-compare\n\n\n官方地址\n\n\n描述\n\n禁止与布尔文字进行不必要的相等比较。\n\n\n\n选项\n      interface Options &#123;\n        /**\n        * 是否允许可空布尔变量和“true”之间的比较。\n        */\n        allowComparingNullableBooleansToTrue?: boolean;\n        /**\n        * 是否允许可为 null 的布尔变量和“false”之间进行比较。\n        */\n        allowComparingNullableBooleansToFalse?: boolean;\n    &#125;\n\n    const defaultOptions: Options = [\n        &#123;\n            allowComparingNullableBooleansToTrue: true,\n            allowComparingNullableBooleansToFalse: true,\n        &#125;,\n    ];\n\n\n示例\n      &#123;\n        \"@typescript-eslint/no-unnecessary-boolean-literal-compare\": \"error\"\n    &#125;\n\n\nno-unnecessary-qualifier\n\n\n官方地址\n\n\n描述\n\n禁止不必要的命名空间限定符。\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@typescript-eslint/no-unnecessary-qualifier\": \"error\"\n    &#125;\n\n\nno-unnecessary-type-arguments\n\n\n官方地址\n\n\n描述\n\n不允许类型参数等于默认值。\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@typescript-eslint/no-unnecessary-type-arguments\": \"error\"\n    &#125;\n\n\npromise-function-async\n\n\n官方地址\n\n\n描述\n\n要求任何返回 Promise 的函数或方法被标记为异步。\n\n\n\n选项\n      interface Options &#123;\n        /**\n        * 是否将“any”和“unknown”视为 Promise。\n        */\n        allowAny?: boolean;\n        /**\n        * 任何额外的类或接口名称都被视为 Promise。\n        */\n        allowedPromiseNames?: string[];\n        checkArrowFunctions?: boolean;\n        checkFunctionDeclarations?: boolean;\n        checkFunctionExpressions?: boolean;\n        checkMethodDeclarations?: boolean;\n    &#125;\n\n    const defaultOptions: Options = [\n        &#123;\n            allowAny: true,\n            allowedPromiseNames: [],\n            checkArrowFunctions: true,\n            checkFunctionDeclarations: true,\n            checkFunctionExpressions: true,\n            checkMethodDeclarations: true,\n        &#125;,\n    ];\n\n\n示例\n      &#123;\n        \"@typescript-eslint/promise-function-async\": \"error\"\n    &#125;\n\n\nrestrict-plus-operands\n\n\n官方地址\n\n\n描述\n\n要求加法的两个操作数类型相同，并且为 bigint number 或 string。\n\n\n\n选项\n      interface Options &#123;\n        /**\n        * 是否允许`any`类型值。\n\n        */\n        allowAny?: boolean;\n        /**\n        * 是否允许`boolean`类型值。\n        */\n        allowBoolean?: boolean;\n        /**\n        * 是否允许 `null` 或者 `undefined` 类型值.\n        */\n        allowNullish?: boolean;\n        /**\n        * 是否允许 `bigint`/`number` 类型值和 `string` 类型值相加。\n        */\n        allowNumberAndString?: boolean;\n        /**\n        * 是否允许 `regexp` 类型值。\n        */\n        allowRegExp?: boolean;\n        /**\n        * 是否检查复合赋值，例如`+=`。\n        */\n        checkCompoundAssignments?: boolean;\n    &#125;\n\n    const defaultOptions: Options = [&#123; checkCompoundAssignments: false &#125;];\n\n\n示例\n      &#123;\n        \"@typescript-eslint/restrict-plus-operands\": \"error\"\n    &#125;\n\n\nunbound-method\n\n\n官方地址\n\n\n描述\n\n强制以预期范围调用未绑定方法。\n\n\n\n选项\n      interface Options &#123;\n        /**\n        * 是否跳过检查“静态”方法是否正确绑定。\n        */\n        ignoreStatic?: boolean;\n    &#125;\n\n    const defaultOptions: Options = [&#123; ignoreStatic: false &#125;];\n\n\n示例\n      &#123;\n        \"@typescript-eslint/unbound-method\": \"error\"\n    &#125;\n\n\nno-unused-vars\n\n\n官方地址\n\n\n描述\n\n禁止使用未使用的变量。\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        // 必须禁用基础规则\n        \"no-unused-vars\": \"off\",\n        \"@typescript-eslint/no-unused-vars\": \"error\"\n    &#125;\n\n\nno-explicit-any\n\n\n官方地址\n\n\n描述\n\n禁用 any 类型\n\n\n\n选项\n      interface Options &#123;\n        /**\n        * 是否启用自动修复，将`any`类型转换为`unknown`类型。\n        */\n        fixToUnknown?: boolean;\n        /**\n        * 是否忽略其余参数数组。\n        */\n        ignoreRestArgs?: boolean;\n    &#125;\n\n    const defaultOptions: Options = [\n        &#123; fixToUnknown: false, ignoreRestArgs: false &#125;,\n    ];\n\n\n示例\n      &#123;\n        \"@typescript-eslint/no-explicit-any\": \"error\"\n    &#125;\n\n\nno-unsafe-argument\n\n\n官方地址\n\n\n描述\n\n禁止使用any类型的值调用函数。\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@typescript-eslint/no-unsafe-argument\": \"error\"\n    &#125;\n\n\nno-unsafe-assignment\n\n\n官方地址\n\n\n描述\n\n禁止将任何类型的值分配给变量和属性。\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@typescript-eslint/no-unsafe-assignment\": \"error\"\n    &#125;\n\n\nno-unsafe-call\n\n\n官方地址\n\n\n描述\n\n禁止调用any类型的值。\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@typescript-eslint/no-unsafe-call\": \"error\"\n    &#125;\n\n\nno-unsafe-member-access\n\n\n官方地址\n\n\n描述\n\n禁止成员访问any类型的值。\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@typescript-eslint/no-unsafe-member-access\": \"error\"\n    &#125;\n\n\nno-unsafe-return\n\n\n官方地址\n\n\n描述\n\n禁止从函数返回any类型的值。\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@typescript-eslint/no-unsafe-return\": \"error\"\n    &#125;\n\n\nno-useless-empty-export\n\n\n官方地址\n\n\n描述\n\n禁止不更改模块文件中任何内容的空导出。\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@typescript-eslint/no-useless-empty-export\": \"error\"\n    &#125;\n\n\n@angular-eslint/eslint-plugin\nno-empty-lifecycle-method\n\n\n官方地址\n\n\n描述\n\n禁止声明空生命周期方法\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/no-empty-lifecycle-method\": [\"error\"]\n    &#125;\n\n\nsort-ngmodule-metadata-arrays\n\n\n官方地址\n\n\n描述\n\n强制NgModule元数据按ASC字母顺序排序。\n\n\n\n选项\n      interface Options &#123;\n        // `BCP` 47 种语言标签。默认值：`en-US`。\n        locale?: string;\n    &#125;\n\n\n示例\n      &#123;\n        \"@angular-eslint/sort-ngmodule-metadata-arrays\": [\"error\"]\n    &#125;\n\n\ncomponent-class-suffix\n\n\n官方地址\n\n\n描述\n\n@Component 修饰的 class 必须以 Component(或自定义) 结尾。\n\n\n\n选项\n      interface Options &#123;\n        /**\n         * 默认值: `[\"Component\"]`\n        */\n        suffixes?: string[];\n    &#125;\n\n\n示例\n      &#123;\n        \"@angular-eslint/component-class-suffix\": [\"error\"]\n    &#125;\n\n\ndirective-class-suffix\n\n\n官方地址\n\n\n描述\n\n@Directive 修饰的 class 必须以 Directive(或自定义) 结尾。\n\n\n\n选项\n       interface Options &#123;\n        /**\n         * 默认值: `[\"Component\"]`\n        */\n        suffixes?: string[];\n    &#125;\n\n\n示例\n      &#123;\n        \"@angular-eslint/directive-class-suffix\": [\"error\"]\n    &#125;\n\n\ncomponent-selector\n\n\n官方地址\n\n\n描述\n\n组件选择器必须遵循指定的命名规则。\n\n\n\n选项\n      interface Options &#123;\n        type?: string | (\"element\" | \"attribute\")[];\n        prefix?: string | unknown[];\n        style?: \"camelCase\" | \"kebab-case\";\n    &#125;\n\n\n示例\n      &#123;\n        \"@angular-eslint/component-selector\": [\n            \"error\",\n            &#123;\n                \"type\": \"element\",\n                \"prefix\": \"sg\",\n                \"style\": \"kebab-case\"\n            &#125;\n        ]\n    &#125;\n\n\nuse-injectable-provided-in\n\n\n官方地址\n\n\n描述\n\n使用 providedIn 使 Injectables 可以 tree-shakable。\n\n\n\n选项\n      interface Options &#123;\n        // 忽略的class名的正则表达式\n        ignoreClassNamePattern?: string;\n    &#125;\n\n\n示例\n      &#123;\n        \"@angular-eslint/use-injectable-provided-in\": [\n            \"error\",\n            &#123;\n                \"ignoreClassNamePattern\": \"/Effects$/\"\n            &#125;\n        ]\n    &#125;\n\n\ncontextual-decorator\n\n\n官方地址\n\n\n描述\n\n确保类在其主体中正确使用上下文装饰器。\n\n\n\n选项\n\n\n示例\n      &#123;\n        \"@angular-eslint/contextual-decorator\": [\"error\"]\n    &#125;\n\n\ndirective-selector\n\n\n官方地址\n\n\n描述\n\n指令选择器命名必须遵循指定的规则\n\n\n\n选项\n      interface Options &#123;\n        type?: string | (\"element\" | \"attribute\")[];\n        prefix?: string | unknown[];\n        style?: \"camelCase\" | \"kebab-case\";\n    &#125;\n\n\n示例\n      &#123;\n        \"@angular-eslint/directive-selector\": [\n            \"error\",\n            &#123;\n                \"type\": \"element\",\n                \"prefix\": \"app\",\n                \"style\": \"kebab-case\"\n            &#125;\n        ]\n    &#125;\n\n\nno-attribute-decorator\n\n\n官方地址\n\n\n描述\n\n@Attribute 装饰器用于获取属性的单个值。与获取值流（使用 @Input）相比，这是一个不太常见的用例，因此当 @Input 是预期的用途时，经常会错误地使用 @Attribute 装饰器。该规则完全禁止使用 @Attribute 装饰器，以防止这些错误。\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/no-attribute-decorator\": [\n            \"error\"\n        ]\n    &#125;\n\n\n\nno-output-on-prefix\n\n\n官方地址\n\n\n描述\n\n确保输出绑定（包括别名）不被命名为on，也不以其为前缀。\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/no-output-on-prefix\": [\n           \"error\"\n        ]\n    &#125;\n\n\nno-pipe-impure\n\n\n官方地址\n\n\n描述\n\n不允许声明impure管道\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/no-pipe-impure\": [\n            \"error\"\n        ]\n    &#125;\n\n\nno-queries-metadata-property\n\n\n官方地址\n\n\n描述\n\n禁止在组件或指令中使用queries元数据属性。\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/no-queries-metadata-property\": [\n            \"error\"\n        ]\n    &#125;\n\n\nno-lifecycle-call\n\n\n官方地址\n\n\n描述\n\n禁止显式调用生命周期方法\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/no-lifecycle-call\": [\n            \"error\"\n        ]\n    &#125;\n\n\ncomponent-max-inline-declarations\n\n\n官方地址\n\n\n描述\n\n强制内联模板、样式和动画中的最大行数。\n\n\n\n选项\n      interface Options &#123;\n        /**\n        * 默认: `3`\n        */\n        template?: number;\n        /**\n        * 默认: `3`\n        */\n        styles?: number;\n        /**\n        * 默认: `15`\n        */\n        animations?: number;\n    &#125;\n\n\n示例\n      &#123;\n        \"@angular-eslint/component-max-inline-declarations\": [\n            \"error\",\n            &#123;\n                \"template\": 3,\n                \"styles\": 3,\n                \"animations\": 15\n            &#125;\n        ]\n    &#125;\n\n\nno-forward-ref\n\n\n官方地址\n\n\n描述\n\n禁止使用 DI 的 forwardRef 引用\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/no-forward-ref\": [\n            \"error\"\n        ]\n    &#125;\n\n\nno-input-prefix\n\n\n官方地址\n\n\n描述\n\n确保输入绑定（包括别名）不会以配置的不允许的前缀命名或添加前缀\n\n\n\n选项\n      interface Options &#123;\n        /**\n        * 默认: `[]`\n        */\n        prefixes?: string[];\n    &#125;\n\n\n示例\n      &#123;\n        \"@angular-eslint/no-input-prefix\": [\n            \"error\",\n            &#123;\n                \"prefixes\": [\n                    \"on\"\n                ]\n            &#125;\n        ]\n    &#125;\n\n\npipe-prefix\n\n\n官方地址\n\n\n描述\n\n强制管道前缀一致。\n\n\n\n选项\n      interface Options &#123;\n        /**\n        * 默认: `[]`\n        */\n        prefixes?: string[];\n    &#125;\n\n\n示例\n      &#123;\n        \"@angular-eslint/pipe-prefix\": [\n            \"error\",\n            &#123;\n                \"prefixes\": [\n                    \"ng\"\n                ]\n            &#125;\n        ]\n    &#125;\n\n\nno-output-native\n\n\n官方地址\n\n\n描述\n\n确保输出绑定（包括别名）不被命名为标准 DOM 事件\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/no-output-native\": \"error\"\n    &#125;\n\n\nprefer-output-readonly\n\n\n官方地址\n\n\n描述\n\n最好将 @Output 声明为只读，因为它们不应该被重新分配\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/prefer-output-readonly\": \"error\"\n    &#125;\n\n\nrelative-url-prefix\n\n\n官方地址\n\n\n描述\n\n./ 和 ../ 前缀是相对 URL 的标准语法；不要依赖 Angular 当前的能力来处理没有该前缀的情况。\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/relative-url-prefix\": [\n           \"error\"\n        ]\n    &#125;\n\n\nuse-component-selector\n\n\n官方地址\n\n\n描述\n\n必须声明组件选择器\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/use-component-selector\": [\n            \"error\"\n        ]\n    &#125;\n\n\nuse-component-view-encapsulation\n\n\n官方地址\n\n\n描述\n\n不允许使用 ViewEncapsulation.None\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/use-component-view-encapsulation\": [\n            \"error\"\n        ]\n    &#125;\n\n\ncontextual-lifecycle\n\n\n官方地址\n\n\n描述\n\n确保在正确的上下文中使用生命周期方法\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/contextual-lifecycle\": [\n            \"error\"\n        ]\n    &#125;\n\n\nprefer-on-push-component-change-detection\n\n\n官方地址\n\n\n描述\n\n确保组件的changeDetection设置为ChangeDetectionStrategy.OnPush\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/prefer-on-push-component-change-detection\": [\n            \"error\"\n        ]\n    &#125;\n\n\n模版相关规则\ntemplate/banana-in-box\n\n\n官方地址\n\n\n描述\n\n确保双向数据绑定语法正确\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/template/banana-in-box\": [\n            \"error\"\n        ]\n    &#125;\n\n\ntemplate/click-events-have-key-events\n\n\n官方地址\n\n\n描述\n\nAccessibility 确保单击事件至少伴随一个按键事件 keyup、keydown 或 keypress。\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/template/click-events-have-key-events\": [\n            \"error\"\n        ]\n    &#125;\n\n\ntemplate/cyclomatic-complexity\n\n\n官方地址\n\n\n描述\n\n根据指定的限制检查圈复杂度。它是对程序源代码中线性独立路径数量的定量度量\n\n\n\n选项\n      interface Options &#123;\n        /**\n         * 默认: `5`\n        */\n        maxComplexity?: number;\n    &#125;\n\n\n示例\n      &#123;\n        \"@angular-eslint/template/cyclomatic-complexity\": [\n            \"error\",\n            &#123;\n                \"maxComplexity\": 10\n            &#125;\n        ]\n    &#125;\n\n\ntemplate/mouse-events-have-key-events\n\n\n官方地址\n\n\n描述\n\n确保鼠标事件 mouseout 和 mouseover 分别伴随焦点和模糊事件。键盘编码对于无法使用鼠标的身体残疾用户、AT 兼容性和屏幕阅读器用户非常重要。\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/template/mouse-events-have-key-events\": [\n            \"error\"\n        ]\n    &#125;\n\n\ntemplate/no-any\n\n\n官方地址\n\n\n描述\n\n使用$any会抵消 Angular 类型系统的编译时优势\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/template/no-any\": [\n            \"error\"\n        ]\n    &#125;\n\n\ntemplate/no-autofocus\n\n\n官方地址\n\n\n描述\n\n确保不使用自动对焦属性\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/template/no-autofocus\": [\n            \"error\"\n        ]\n    &#125;\n\n\ntemplate/no-distracting-elements\n\n\n官方地址\n\n\n描述\n\n强制不使用分散注意力的元素\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/template/no-distracting-elements\": [\n            \"error\"\n        ]\n    &#125;\n\n\ntemplate/no-positive-tabindex\n\n\n官方地址\n\n\n描述\n\n确保 tabindex 属性不为正数\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/template/no-positive-tabindex\": [\n            \"error\"\n        ]\n    &#125;\n\n\ntemplate/use-track-by-function\n\n\n官方地址\n\n\n描述\n\n确保使用 trackBy 函数\n\n\n\n选项\n\nnone\n\n\n\n示例\n      &#123;\n        \"@angular-eslint/template/use-track-by-function\": [\n            \"error\"\n        ]\n    &#125;\n\n\ntemplate/i18n\n\n\n官方地址\n\n\n描述\n\n确保遵循 i18n 的最佳实践。检查元素和包含文本的属性上是否缺少 i18n 属性。还可以检查没有 i18n 属性的文本、不使用自定义 ID (@@) 功能的元素以及重复的自定义 ID\n\n\n\n选项\n      interface Options &#123;\n        boundTextAllowedPattern?: string;\n        /**\n        * 默认: `true`\n        */\n        checkAttributes?: boolean;\n        /**\n        * 默认: `true`\n        */\n        checkDuplicateId?: boolean;\n        /**\n        * 默认: `true`\n        */\n        checkId?: boolean;\n        /**\n        * 默认: `true`\n        */\n        checkText?: boolean;\n        /**\n        * 默认: `[\"autocomplete\",\"charset\",\"class\",\"color\",\"colspan\",\"dir\",\"fill\",\"for\",\"formArrayName\",\"formControlName\",\"formGroupName\",\"height\",\"href\",\"id\",\"lang\",\"list\",\"name\",\"ngClass\",\"ngProjectAs\",\"role\",\"routerLink\",\"routerLinkActive\",\"src\",\"stroke\",\"stroke-width\",\"style\",\"svgIcon\",\"tabindex\",\"target\",\"type\",\"value\",\"viewBox\",\"width\",\"xmlns\"]`\n        */\n        ignoreAttributes?: string[];\n        ignoreTags?: string[];\n        requireDescription?: boolean;\n        requireMeaning?: boolean;\n    &#125;\n\n\n示例\n      &#123;\n        \"@angular-eslint/template/i18n\": [\n            \"error\"\n        ]\n    &#125;\n\n\ntemplate/attributes-order\n\n\n官方地址\n\n\n描述\n\n确保 HTML 属性和 Angular 绑定根据预期顺序进行排序\n\n\n\n选项\n      interface Options &#123;\n        alphabetical?: boolean;\n        /**\n        * 默认: `[\"STRUCTURAL_DIRECTIVE\",\"TEMPLATE_REFERENCE\",\"ATTRIBUTE_BINDING\",\"INPUT_BINDING\",\"TWO_WAY_BINDING\",\"OUTPUT_BINDING\"]`\n        *\n        * @minItems 6\n        */\n        order?: [\n            (\n            | \"STRUCTURAL_DIRECTIVE\"\n            | \"TEMPLATE_REFERENCE\"\n            | \"ATTRIBUTE_BINDING\"\n            | \"INPUT_BINDING\"\n            | \"TWO_WAY_BINDING\"\n            | \"OUTPUT_BINDING\"\n            ),\n            (\n            | \"STRUCTURAL_DIRECTIVE\"\n            | \"TEMPLATE_REFERENCE\"\n            | \"ATTRIBUTE_BINDING\"\n            | \"INPUT_BINDING\"\n            | \"TWO_WAY_BINDING\"\n            | \"OUTPUT_BINDING\"\n            ),\n            (\n            | \"STRUCTURAL_DIRECTIVE\"\n            | \"TEMPLATE_REFERENCE\"\n            | \"ATTRIBUTE_BINDING\"\n            | \"INPUT_BINDING\"\n            | \"TWO_WAY_BINDING\"\n            | \"OUTPUT_BINDING\"\n            ),\n            (\n            | \"STRUCTURAL_DIRECTIVE\"\n            | \"TEMPLATE_REFERENCE\"\n            | \"ATTRIBUTE_BINDING\"\n            | \"INPUT_BINDING\"\n            | \"TWO_WAY_BINDING\"\n            | \"OUTPUT_BINDING\"\n            ),\n            (\n            | \"STRUCTURAL_DIRECTIVE\"\n            | \"TEMPLATE_REFERENCE\"\n            | \"ATTRIBUTE_BINDING\"\n            | \"INPUT_BINDING\"\n            | \"TWO_WAY_BINDING\"\n            | \"OUTPUT_BINDING\"\n            ),\n            (\n            | \"STRUCTURAL_DIRECTIVE\"\n            | \"TEMPLATE_REFERENCE\"\n            | \"ATTRIBUTE_BINDING\"\n            | \"INPUT_BINDING\"\n            | \"TWO_WAY_BINDING\"\n            | \"OUTPUT_BINDING\"\n            ),\n            ...(\n            | \"STRUCTURAL_DIRECTIVE\"\n            | \"TEMPLATE_REFERENCE\"\n            | \"ATTRIBUTE_BINDING\"\n            | \"INPUT_BINDING\"\n            | \"TWO_WAY_BINDING\"\n            | \"OUTPUT_BINDING\"\n            )[]\n        ];\n    &#125;\n\n\n\n示例\n      \"@angular-eslint/template/attributes-order\": [\n        \"error\"\n    ]\n\n\n完整示例\n\nCheck what you want to copy to your config file\n\n\n\n","slug":"eslint-angular","date":"2023-04-01T00:00:00.000Z","categories_index":"ANGULAR","tags_index":"angular,typescript,eslint,javascript","author_index":"Kidwen"},{"id":"587ccc5993ea7af286d7fe7fba152d8c","title":"javascript type check","content":"In this article, How to Check the Type of a Variable or Object in JavaScript? In JavaScript, the typeof operator is used to determine the typeof an object or variable. JavaScript, on the other hand, is a dynamically typed (or weakly typed) language. This indicates that a variable can have any type of value. The type of the value assigned to a variable determines the type of the variable.\nCheck Undefined\nA variable declared in scope but not assigned a value. This is different of undeclared.\nconst variable = undefined;\n\ntypeof variable; // 'undefined'\n// or\nObject.prototype.toString.call(variable); // '[object Undefined]'\nCheck Null\nconst empty = null;\n\nempty === null; // true\n// or\nObject.prototype.toString.call(empty); // '[object Null]'\n// or\n!empty &#x26;&#x26; typeof empty === 'object'; // true\nCheck Array\nconst arr = [];\n\narr instanceof Array; // true\n// or\nArray.isArray(arr); // true\n// or\nObject.prototype.toString.call(arr); // '[object Array]'\nCheck Map\nconst map = new Map();\n\nObject.prototype.toString.call(map); // '[object Map]'\nCheck Boolean\nconst bool = true;\n\nObject.prototype.toString.call(bool); // '[object Boolean]'\nCheck Number\nconst num = 1;\n\nObject.prototype.toString.call(num); // '[object Number]'\n\nNumber.isInteger(num); // true\n\ntypeof num; // 'number'\nCheck String\nconst str = 'str';\n\nObject.prototype.toString.call(str); // '[object String]'\nCheck Symbol\nconst sym = Symbol('sym');\n\nObject.prototype.toString.call(sym); // '[object Symbol]'\nCheck Object\nconst obj = &#123;&#125;;\n\nObject.prototype.toString.call(obj); // '[object Object]'\nCheck Function\nfunction fn () &#123;&#125;;\n// or\nconst fn = () => &#123;&#125;;\n// or\nconst fn = function () &#123;&#125;;\n\nObject.prototype.toString.call(fn); // '[object Function]'\n// or\ntypeof fn; // 'function'\nCheck Error\nconst err = new Error();\n\nObject.prototype.toString.call(err); // '[object Error]'\nCheck RegExp\nconst reg = new RegExp();\n\nObject.prototype.toString.call(reg); // '[object RegExp]'\nCheck Math\nObject.prototype.toString.call(Math); // '[object Math]'\nCheck Document\nconst doc = new Document();\n\nObject.prototype.toString.call(doc); // '[object Document]'\nCheck Window\nObject.prototype.toString.call(window); // '[object Window]'\n","slug":"type-check","date":"2023-03-23T08:00:00.000Z","categories_index":"JAVASCRIPT","tags_index":"","author_index":"Kidwen"},{"id":"2b246af8e1856d1e6c5516541b419cd5","title":"http server","content":"http-server is a simple, zero-configuration command-line static HTTP server. It is powerful enough for production usage, but it’s simple and hackable enough to be used for testing, local development and learning.\nInstall\nnpm i -g http-server\nUse\n# default ./public or ./\nhttp-server ./views\n","slug":"http-server","date":"2023-03-22T06:00:00.000Z","categories_index":"TOOL","tags_index":"server","author_index":"Kidwen"},{"id":"82b9fceb41cc85f8f9d6f13639094390","title":"Setting up a proxy for npm/yarn/nvm","content":"npm stands for Node Package Manager. It’s a library and registry for JavaScript software packages. npm also has command-line tools to help you install the different packages and manage their dependencies.\nYarn is a package manager that doubles down as project manager. Whether you work on one-shot projects or large monorepos, as a hobbyist or an enterprise user, we’ve got you covered.\nNPM\nShow config\n# show all config\nnpm config ls -l\n# or\nnpm get proxy\nSet proxy\nnpm config set proxy=http://127.0.0.1:10809\nCancle proxy\nnpm config delete proxy\nSet registry\nnpm config set registry https://registry.npmmirror.com\nSet loglevel\nnpm config set loglevel http\n\n# or\n\nnpm install --loglevel=http\nYarn\nShow config\nyarn config list\n# or\nyarn config get proxy\nSet proxy\nyarn config set proxy http://127.0.0.1:10809\nCancle proxy\nyarn config delete proxy\nSet registry\nyarn config set registry https://registry.npmmirror.com\nNvm\nShow proxy\nnvm proxy\nSet proxy\nnvm proxy http://127.0.0.1:10809\nCancle proxy\nnvm proxy none\n","slug":"npm-yarn","date":"2023-03-20T08:12:22.000Z","categories_index":"PROXY,REGISTRY","tags_index":"npm,yarn","author_index":"Kidwen"},{"id":"99549990e3a692a5bd343420bd9e2a64","title":"terminal proxy","content":"terminal is a task automation and configuration management program from Microsoft, consisting of a command-line shell and the associated scripting language.\nPowershell Show Proxy\nnetsh winhttp show proxy\nPowershell Set Proxy\nnetsh winhttp set proxy 127.0.0.1:10808\n\n# 临时设置代理，关闭powershell会清掉\n$env:HTTP_PROXY=\"http://127.0.0.1:10808\"\nPowershell Cancle Proxy\nnetsh winhttp reset proxy\nCmd Temporary Set Proxy\nset http_proxy=http://127.0.0.1:10809\nset https_proxy=http://127.0.0.1:10809\n\n# cancel proxy for localhost\nset no_proxy=localhost, 127.0.0.1, ::1\n","slug":"powershell","date":"2023-03-20T08:10:22.000Z","categories_index":"PROXY","tags_index":"terminal","author_index":"Kidwen"},{"id":"e45789ed6a6c4dccaf366d2080a7ca21","title":"webpack","content":"Webpack is a module bundler. Its main purpose is to bundle JavaScript files for usage in a browser, yet it is also capable of transforming, bundling, or packaging just about any resource or asset.\nConfig\n\nCheck what you want to copy to your config file\n\n\n\n","slug":"webpack","date":"2023-03-20T04:13:22.000Z","categories_index":"TOOL","tags_index":"build","author_index":"Kidwen"},{"id":"234ca5fd8ee7c41e1376bd4bc2b2e5c4","title":"develope with hexo","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start\n# install hexo global\nnpm i -g hexo-cli\n\n# goto workspace\nnpm i\n# or\nyarn\n\n\n\n\n\n\n\nremove the aurora home page comments list\n\nGoto node-modules/hexo-theme-aurora/source/static/js/app.6d2c358d.js and delete ye.render = ie;\nOr\nAdd this style in global css file.\n.block .sidebar-box:not(:last-child) &#123;\n  display: none;\n&#125;\n\n.relative > :not(.block) .sidebar-box:last-child &#123;\n  display: none;\n&#125;\n\n#sticky-sidebar .sidebar-box &#123;\n  display: block;\n&#125;\n\n\nCreate a new post\nhexo new 'My New Post'\n# or\nhexo n page 'My New Page'\nMore info: Writing\nRun server\nyarn start\nMore info: Server\nMore info: Generating\nDeploy to remote sites\nyarn deploy\nMore info: Deployment\n","slug":"hexo","date":"2023-03-15T08:10:22.000Z","categories_index":"TOOL","tags_index":"doc","author_index":"Kidwen"}]